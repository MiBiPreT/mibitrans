{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documention for <code>mibitrans</code> python package","text":""},{"location":"#how-to-use-mibitrans","title":"How to use mibitrans","text":"<p>A collection of analytical and semi-semianalytical solutions for hydrogeological transport phenomena</p>"},{"location":"#installation","title":"Installation","text":"<p>To install mibitrans from GitHub repository, do:</p> <pre><code>git clone git@github.com:MiBiPreT/mibitrans.git\ncd mibitrans\npython -m pip install .\n</code></pre>"},{"location":"background/bioscreen/","title":"BIOSCREEN","text":""},{"location":"background/bioscreen/#general","title":"General","text":"<p>BIOSCREEN has been developed by the U.S. Environmental Protection Agency (EPA) in collaboration with the U.S. Air Force as natural attenuation decision support tool. Its is meant as screening tool to determine if a full-scale evaluation of a contaminated site is needed. Thereby it is not replacing a more involved numerical model, but serves as preliminary step to evaluate the necessity of an involved numerical model. </p> <p>BIOSCREEN calculates contaminant concentration distributions in 3D for a constant source under uniform flow conditions based on the advection dispersion equation. The source domain can contain several zones of different concentrations. Three modes of decay can be chose to represent degradation processes: * no decay * linear decay * instantaneous biodegradation reaction</p> <p>Input parameters for BIOSCREEN are few compared to numerical models. After parameter entry, visualization of concentrations at the plume centreline or as a 3D plume can be performed for each of the three decay modes. Version 1.4 provides the option to calculate mass balances of the plume and the source. BIOSCREEN comes with two sets of example data.</p> <p>BIOSCREEN is implemented in Excel, and provides a graphical interface. The latest version is BIOSCREEN 1.4. It was released to be compatible with Microsoft Excel 5.0. Analysis is performed using macro scripts and cellular calculations. Calculations inside the Excel sheets are hidden in the background, and give insight into the actual calculations behind the model. The spatial resolution of the plume is fixed to 11 steps over the plume length and 5 steps lateral to the plume. Temporal resolution is fixed to 10 time steps. This resolution is relative to the set model extent and time.</p>"},{"location":"background/bioscreen/#transport-model","title":"Transport model","text":"<p>Transport is modeled based on the three-dimensional advection-dispersion equation (ADE) with linear equilibrium adsorption for uniform flow in \\(x\\)-direction:</p> \\[ \\begin{equation}\\tag{1}\\label{eq:01_ADE3D}     R\\frac{\\partial C}{\\partial t} = -v\\frac{\\partial C}{\\partial x} + D_{x}\\frac{\\partial ^2 C}{\\partial x^2} + D_y \\frac{\\partial^2 C}{\\partial y^2} + D_z \\frac{\\partial^2 C}{\\partial z^2} + r_{sinks} \\end{equation} \\] <p>Here \\(C(x,y,z,t)\\) is the contaminant concentration in space \\((x,y,z)\\) and time \\(t\\), \\(R\\) is the linear equilibrium retardation factor, \\(v\\) is the uniform groundwater velocity in \\(x\\)-direction, \\(D_{x}\\), \\(D_{y}\\) and \\(D_{y}\\) are the longitudinal, transverse horizontal and transverse vertical dispersion coefficients, respectively. \\(r_{sinks}\\) represents the sink term as result to decay/degradation. \\(r_{sinks} = 0\\) represents no decay/degradation. For linear decay, \\(r_{sinks} = -\\lambda C\\). In the equation \\(\\frac{\\partial C}{\\partial t}\\) represents the change of the concentration over time. \\(-v\\frac{\\partial C}{\\partial x}\\) is the change of concentration in the direction of the groundwater gradient due to advection. \\(D_{x}\\frac{\\partial ^2 C}{\\partial x^2} + D_{y}\\frac{\\partial ^2 C}{\\partial y^2}+ + D_{z}\\frac{\\partial^2 C}{\\partial z^2}\\) represent the change in concentration to dispersion. </p> <p>A specific solution of the ADE \\(\\eqref{eq:01_ADE3D}\\), depends on the specific form of the sink-term \\(r_{sinks}\\) as well as initial and boundary conditions. Transport in BIOSCREEN is modelled based on the analytical model of Domenico, [1987]. </p>"},{"location":"background/bioscreen/#domenico-model","title":"Domenico Model","text":"<p>An analytical model for the ADE for initial and boundary conditions representing typical spill field situation has been presented by Domenico, 1987. The solution has not been derived mathematically rigorous as analytical solution of the ADE, but has been composed of analytical solutions for the individual processes. As Domenico, [1987] writes, an exact solution to this problem cannot avaid some form of numerical integration. The provided analytical expression approximates the concentration distribution of a decaying species that is released to the aquifer as an extended pulse. West et al., 2007 provides a detailed overview on the effects of the approximations in the Domenico-solution and potential error it can introduce to solute transport predictions.</p> <p>Specifically, the Domenico-model takes the following assumption on initial and boundary conditions: * Flow is uniform in \\(x\\) direction with constant velocity \\(v\\). * The contaminant decays continuously at a rate of \\(\\lambda\\) (independent of position). * There is no adsorption/retardation of the contaminant. * The contaminant is released to the aquifer within a source plane of width \\(Y\\), height \\(Z\\), located at \\(x=0\\) and centered at \\(y=0\\) and \\(z=0\\), so the center of plume is always located along the \\(x\\)-axis. * The input of contaminant at the source is constant over time with an amount of \\(C_0\\) that does not change over time. Specifically, it assumes that the source is not subject to depletion or internal decay/degradation that reduced source concentrations.</p> <p>The equation describing the solute distribution in time and space of the Domenico-model reads:</p> \\[ \\begin{align}\\tag{2}     C(x, y, z, t) &amp;= \\frac{C_{0}}{8} \\exp \\left[ \\frac{x\\left(1-\\sqrt{1+4\\lambda \\alpha_x/v}\\right)}{2\\alpha_x}\\right] \\\\     &amp;\\quad \\cdot \\operatorname{erfc} \\left[ \\frac{x - vt\\sqrt{1+4\\lambda \\alpha_x/v}}{2\\sqrt{\\alpha_x vt }} \\right] \\\\     &amp;\\quad \\cdot \\left\\{ \\operatorname{erf} \\left[ \\frac{y + Y/2}{2\\sqrt{\\alpha_y x}} \\right] - \\operatorname{erf} \\left[ \\frac{y - Y/2}{2\\sqrt{\\alpha_y x)}} \\right] \\right\\} \\\\     &amp;\\quad \\cdot \\Biggl. \\left\\{ \\operatorname{erf} \\left[ \\frac{z +Z/2}{2\\sqrt{\\alpha_z x)}} \\right] - \\operatorname{erf} \\left[ \\frac{z-Z/2}{2\\sqrt{\\alpha_z x}} \\right] \\right\\} \\nonumber \\end{align} \\] <p>where \\(C(x,y,z,t)\\) is the contaminant concentration in \\(M/V^3\\) at position \\((x,y,z)\\) and time \\(t\\). \\(v\\) is the groundwater flow velocity in \\(m/d\\). \\(\\alpha_x\\) is the longitudinal dispersivity (in the x-direction). \\(\\alpha_y\\) is the transverse horizontal dispersivity (in the y-direction). \\(Y\\) and \\(Z\\) are the width and thickness/height of the source in the saturated zone in \\(m\\).</p> <p>The first two terms account for the transport of contaminants in horizontal direction due to advection and longitudinal dispersion while being subject to continuous decay. This part is based on the plug flow model of Bear, 1979 and is in line with other derivations of analytical solutions for the 1D ADE assuming uniform flow, constant decay and continuous input of contaminant.</p> <p>The two terms in the second row account for the dilution of the plume due to transverse dispersion. They were derived by Domenico and Palciauskas, 1982. The model is formulated as a boundary value problem that approximates the spreading. However, the terms are not in line with mathematically rigorous derived analytical solutions for this process. The terms \\(\\sqrt{\\alpha_{y/z} x)}\\) in the denominator should read \\(\\sqrt{\\alpha_{y/z} vt)}\\). Consequently, this form effectively assumes a linear increase of lateral dispersion as function of the plume travel distance. This is a misinterpretation of the concept of transverse spreading. Lateral spreading takes place at every distance. Note, that this should not be mixed up with the characteristics of longitudinal dispersion that is evolving over distance up to a asymptotic value that depends on aquifer heterogeneity (i.e. also not linearly with plume travel distance).</p> <p>Bioscreen makes use of the Domenico-model in various adaptions (Newell et al., 1996, 1997).</p>"},{"location":"background/bioscreen/#bioscreen-implementation-of-decay-and-no-decay-solutions","title":"BIOSCREEN Implementation of Decay and No-decay solutions","text":"<p>Bioscreen does not directly use the Domenico model, but an extension regarding source handling and retardation. For the cases of linear decay of the contaminant (\\(\\lambda \\neq 0\\)) and the case of no decay (\\(\\lambda = 0\\)), they include a source decay term accounting for reduction/depletion of the input concentration from the source in the form of \\(C_0(x,t) = C_0 \\exp{\\left( -k_s \\left( t-\\frac{x}{v}\\right)\\right)}\\).</p> <p>The analytical expression used by BIOSCREEN for no-decay (\\(\\lambda = 0\\)) and linear decay (\\(\\lambda \\neq 0\\)) reads (Newell et al., 1997):</p> \\[ \\begin{align}\\tag{3}     C(x, y, z, t) &amp; = \\frac{C_{0}}{8}\\exp{\\left( -k_s \\left( t-\\frac{x}{v}\\right)\\right)} \\\\      &amp;\\quad \\cdot  \\exp \\left[ \\frac{x\\left(1-\\sqrt{1+4\\lambda \\alpha_x/v}\\right)}{2\\alpha_x}\\right]      \\cdot \\operatorname{erfc} \\left[ \\frac{x - vt\\sqrt{1+4\\lambda \\alpha_x/v}}{2\\sqrt{\\alpha_x vt }} \\right] \\\\     &amp;\\quad \\cdot \\left\\{ \\operatorname{erf} \\left[ \\frac{y + Y/2}{2\\sqrt{\\alpha_y x}} \\right] - \\operatorname{erf} \\left[ \\frac{y - Y/2}{2\\sqrt{\\alpha_y x)}} \\right] \\right\\} \\\\     &amp;\\quad \\cdot \\Biggl. \\left\\{ \\operatorname{erf} \\left[ \\frac{Z/2}{2\\sqrt{\\alpha_z x)}} \\right] - \\operatorname{erf} \\left[ \\frac{Z/2}{2\\sqrt{\\alpha_z x}} \\right] \\right\\} \\nonumber \\end{align} \\] <p>Note that here \\(z=0\\) compared to Eq. \\(\\eqref{eq:02_domenico}\\), indicating that Bioscreen only evaluates the solution \\(z=0\\) and does not provide a vertically resolved solution.</p> <p>Bioscreen also uses the Domenico model in Eq. \\(\\eqref{eq:02_domenico}\\) as starting point for developing the model for the instantaneous reaction. </p> \\[ \\begin{align}\\tag{4}     C(x, y, z, t) &amp;= \\frac{C_{0}}{8}\\exp{\\left( -k_s \\left( t-\\frac{x}{v}\\right)+BC\\right)} \\\\     &amp;\\quad \\cdot \\operatorname{erfc} \\left[ \\frac{x - vt}{2\\sqrt{\\alpha_x vt }} \\right] \\\\     &amp;\\quad \\cdot \\left\\{ \\operatorname{erf} \\left[ \\frac{y + Y/2}{2\\sqrt{\\alpha_y x}} \\right] - \\operatorname{erf} \\left[ \\frac{y - Y/2}{2\\sqrt{\\alpha_y x)}} \\right] \\right\\} \\\\     &amp;\\quad \\cdot \\Biggl. \\left\\{ \\operatorname{erf} \\left[ \\frac{Z/2}{2\\sqrt{\\alpha_z x)}} \\right] - \\operatorname{erf} \\left[ \\frac{Z/2}{2\\sqrt{\\alpha_z x}} \\right] \\right\\} -BC \\nonumber \\end{align} \\]"},{"location":"background/bioscreen/#bioscreen-implementation-of-instant-reaction-model","title":"BIOSCREEN Implementation of Instant reaction model","text":"<p>BIOSCREEN uses a superposition approach in combination with the Domenico-model to model instantaneous aerobic and anaerobic reactions in groundwater, based on available concentrations of electron acceptors (EAs). They argue that the comparison to more complex models resolving the processes shows good agreement (within the range of assumptions) justifying the use of this heuristic approach for reactive transport modelling.</p>"},{"location":"background/bioscreen/#principle","title":"Principle","text":"<p>The general model idea is: * Calculate how much contaminant can be consumed by an instantaneous reactions with all present EA\u2019s based on their global concentrations. That amount is called biodegredation capacity BC. The BC is a lumped value that reflects the potential contaminant mass removal of available EAs. * Calculate the spatially distributed contaminant concentration as if there is no decay. But adapt the handling of the source concentration: the source zone concentration is the sum of the measured source zone concentration and the biodegradation capacity BC. * Subtract the BC from the calculated concentration for every location and time, i.e. reduce the concentration by what can be consumed by reactions.</p> <p>This procedure is implemented as a superposition of the reaction to the Domenico model. By this method, contaminant mass concentrations are transported conservatively and then corrected at any location and time within the flow field by subtracting 1 mg/L organic mass for each mg/L of BC provided by all of the available electron acceptors.</p> <p>Specifically, the equation for the instant reaction model in BIOSCREEN reads:</p> \\[ \\begin{align}\\tag{5}     C(x, y, t) + BC &amp;= \\sum_{i=0}^{n} \\Biggl\\{ \\left( C^*_{0,i} \\exp \\left[-k_s^{inst} \\left(t - \\frac{xR}{v} \\right)\\right] + BC \\right) \\bigr. \\\\     &amp;\\quad \\quad \\quad \\cdot \\left\\{ \\frac{1}{8} \\operatorname{erfc} \\left[ \\frac{x - \\frac{vt}{R}}{2\\sqrt{\\alpha_x \\frac{vt}{R}}} \\right] \\right\\}  \\\\     &amp;\\quad \\quad \\quad \\cdot \\left\\{ \\operatorname{erf} \\left[ \\frac{y + Y^*_i}{2\\sqrt{\\alpha_y x}} \\right] - \\operatorname{erf} \\left[ \\frac{y - Y^*_i}{2\\sqrt{\\alpha_y x)}} \\right] \\right\\} \\\\     &amp;\\quad \\quad \\quad \\cdot \\Biggl. \\left\\{ \\operatorname{erf} \\left[ \\frac{Z}{2\\sqrt{\\alpha_z x)}} \\right] - \\operatorname{erf} \\left[ \\frac{-Z}{2\\sqrt{\\alpha_z x}} \\right] \\right\\} \\Biggr\\}  \\end{align} \\]"},{"location":"background/bioscreen/#biodegradation-capacity-bc","title":"Biodegradation Capacity BC","text":"<p>The Biodegradation capacity is calculated via:</p> \\[ \\begin{equation}\\tag{6}    BC = \\sum_{O,N,S} (\\bar C_i^\\mathrm{upgradient} - C_i^\\mathrm{source})/UF_i + \\sum_{Fe2+,CH_4^+}  \\bar C_j^\\mathrm{source}/UF_j  \\end{equation} \\] <p>here \\(\\bar C_i^\\mathrm{upgradient}\\) is the average upgradient concentrations and \\(C_i^\\mathrm{source})\\) is the minimum source concentration of \\(i=\\)  oxygen, nitrate, sulfate. \\(\\bar C_j^\\mathrm{source}\\) is the average source concentration of \\(j=Fe2+,CH_4^+\\).  \\(UF_i\\) and \\(UF_j\\) are the utilization factors for each EA that was developed based on the stoichimetric ratios of the reactions (see below).</p> <p>The usage of measured concentrations is based on the following assumption for the different EAs: * Available EA from oxygen, nitrate and sulfate are transported with the groundwater, thus their concentrations are replenished.Their available concentrations for biodegradation are equal to the difference between average upgradient and minimum source concentrations (which is considered the available background concentration). A key assumptions here is that GW upstream is unaffected and their is full consumption of these AE in source zone. * Available EA from iron-reducing and methanogenesis reactions are determined from measure concentrations of metabolic by-products: ferrous iron (Fe2+) and methane in source zone. EAs of these reaction are difficult to quantify (C02 is produced as end product of other reactions and ferric iron (Fe3+) is dissolved from the aquifer matrix. A key assumption here is that the model does not account for depletion of \\(Fe3+\\) in aquifer matrix.</p> <p>The calculated value of BC for the given global concentrations of EAs/EA-byproducts provides an estimate of the biodegradation capacity of the groundwater flowing through the source zone and plume and the aquifer soil matrix. In the instantaneous reaction model, it is assumed that EA\u2019s are consumed to full capacity for contaminant reduction. This includes the assumption that all reactions occur over the entire area of the contaminant plume.</p>"},{"location":"background/bioscreen/#utilization-factors-uf","title":"Utilization factors UF","text":"<p>Utilization factors are based on the stoichimetric ratios of the reactions between the four BTEX compounds and each of the EAs as presented in Wiedemeier, 1995. The utilization factor for oxygen, nitrate, and sulfate can be developed showing the stoichiometric ratio of EA consumed to the mass of dissolved hydrocarbon degraded in the biodegradation reactions. Utilization factors for iron reduction and methanogenesis can be developed from the ratio of generated mass of metabolic by-products to mass of dissolved hydrocarbon degraded. </p> EA/Byproduct UF (gm/gm) Oxygen 3.14 Nitrate 4.9 Sulfate 4.7 Ferrous Iron 21.8 Methane 0.78 <p>Table: BTEX utilization factors (UF) for redox reactions</p> <p>Note that UFs are limited to reactions of EAs with BTEX constituents. When aiming to model other contaminants, the utilization factors would need to be adapted. Alternatively, available oxygen, nitrate, iron, sulfate, and methane concentrations could be adjusted accordingly to reflect alternate utilization factors. </p>"},{"location":"background/bioscreen/#references","title":"References","text":"<p>Bear, J., Hydraulics of groundwater, London ; New York : McGraw-Hill International Book Co., 1979</p> <p>Domenico, P. A., and V. V. Palciauskas, Alternative Boundaries in Solid Waste Management, Groundwater, 20 (3), 303\u2013311, 1982</p> <p>[Domenico, P., An analytical model for multidimensional transport of a decaying contaminant species, Journal of Hydrology, 91, 49\u201358, doi:10.1016/0022-1694(87)90127-2, 1987.] (https://doi.org/10.1016/0022-1694(87)90127-2)</p> <p>Newell, C. J., R. K. Mcleod, J. R. Gonzales, and J. T. Wilson, BIOSCREEN natural attenuation decision support system user\u2019s manual version 1.3, Tech. rep., U.S. EPA, 1996.</p> <p>Newell, C. J., R. K. Mcleod, J. R. Gonzales, and J. T. Wilson, BIOSCREEN Natural Attenuation Decision Support System Version 1.4 Revisions, U.S. EPA, 1997.</p> <p>West, M. R., B. H. Kueper, and M. J. Ungs, On the use and error of approximation in the Domenico (1987) solution, Groundwater, 45 (2), 126\u2013135, 2007</p> <p>Wiedemeier, T. H., J. T. Wilson, D. H. Kampbell, R. N. Miller, and J. E. Hansen, Technical protocol for implementing intrinsic remediation with long-term monitoring for natural attenuation of fuel contamination dissolved in groundwater. Volume II, Tech. Rep. AD-A\u2013324247/6/XAB, Parsons Engineering Science, Inc., Denver, CO (United States), 1995</p>"},{"location":"background/bioscreen/#bugs-in-bioscreen","title":"Bugs in BIOSCREEN","text":"<p>During the setup of <code>mibitrans</code>, BIOSCREEN has been thoroughly tested. It was found to be host to a minor erroneous calculation for the instant reaction model. BIOSCREEN uses calculations from the no decay model and corrects them for the different source decay coefficient and source zone concentrations. However, in these corrections, the wrong source decay coefficient is used, resulting in an underestimation of modelled biodegradation. The size of the error is determined by choice of parameters relating to source decay and biodegradation capacity. </p>"},{"location":"development/development/","title":"<code>mibitrans</code> developer documentation","text":""},{"location":"development/development/#development-install","title":"Development install","text":"<pre><code># Create a virtual environment, e.g. with\npython -m venv env\n\n# activate virtual environment\nsource env/bin/activate\n\n# make sure to have a recent version of pip and setuptools\npython -m pip install --upgrade pip setuptools\n\n# (from the project root directory)\n# install mibitrans as an editable package\npython -m pip install --no-cache-dir --editable .\n# install development dependencies\npython -m pip install --no-cache-dir --editable .[dev]\n</code></pre> <p>Afterwards check that the install directory is present in the <code>PATH</code> environment variable.</p>"},{"location":"development/development/#running-the-tests","title":"Running the tests","text":"<p>There are two ways to run tests.</p> <p>The first way requires an activated virtual environment with the development tools installed:</p> <pre><code>pytest -v\n</code></pre> <p>The second is to use <code>tox</code>, which can be installed separately (e.g. with <code>pip install tox</code>), i.e. not necessarily inside the virtual environment you use for installing <code>mibitrans</code>, but then builds the necessary virtual environments itself by simply running:</p> <pre><code>tox\n</code></pre> <p>Testing with <code>tox</code> allows for keeping the testing environment separate from your development environment. The development environment will typically accumulate (old) packages during development that interfere with testing; this problem is avoided by testing with <code>tox</code>.</p>"},{"location":"development/development/#test-coverage","title":"Test coverage","text":"<p>In addition to just running the tests to see if they pass, they can be used for coverage statistics, i.e. to determine how much of the package\u2019s code is actually executed during tests. In an activated virtual environment with the development tools installed, inside the package directory, run:</p> <pre><code>coverage run\n</code></pre> <p>This runs tests and stores the result in a <code>.coverage</code> file. To see the results on the command line, run</p> <pre><code>coverage report\n</code></pre> <p><code>coverage</code> can also generate output in HTML and other formats; see <code>coverage help</code> for more information.</p>"},{"location":"development/development/#running-linters-locally","title":"Running linters locally","text":"<p>For linting and sorting imports we will use ruff. Running the linters requires an  activated virtual environment with the development tools installed.</p> <pre><code># linter\nruff check .\n\n# linter with automatic fixing\nruff check . --fix\n</code></pre> <p>To fix readability of your code style you can use yapf.</p> <p>You can enable automatic linting with <code>ruff</code> on commit by enabling the git hook from <code>.githooks/pre-commit</code>, like so:</p> <pre><code>git config --local core.hooksPath .githooks\n</code></pre>"},{"location":"development/development/#cleaning-notebooks","title":"Cleaning notebooks","text":"<p>The linter tests now also check that the example notebooks are \u201cclean\u201d. This means they do not contain the output and execution metadata that Jupyter adds when you execute them. Removing this reduces the size and noisiness of the diffs and consequently makes reviewing changes easier.</p> <p>To clean the notebooks locally before each commit, you can use the <code>nb-clean</code> tool, which is listed as one of the <code>[dev]</code> dependencies of the project. They are installable with: <pre><code>python -m pip install .[dev]\n</code></pre></p> <p>You can then run: <pre><code>nb-clean add-filter\n</code></pre> This adds a git hook that will automatically clean any staged notebooks before they are committed. If you would rather run this manually, you can instead use: <pre><code>nb-clean clean mynotebook.ipynb\n</code></pre> replacing with the name of the notebook in question.</p>"},{"location":"development/development/#testing-docs-locally","title":"Testing docs locally","text":"<p>To build the documentation locally, first make sure <code>mkdocs</code> and its dependencies are installed: <pre><code>python -m pip install .[doc]\n</code></pre></p> <p>Then you can build the documentation and serve it locally with <pre><code>mkdocs serve\n</code></pre></p> <p>This will return a URL (e.g. <code>http://127.0.0.1:8000/mibitrans/</code>) where the docs site can be viewed.</p> <p>Note that this will only create the \u201cnon-versioned\u201d documentation, which should be fine for testing changes to the docs. The versioned documentation is created using the python utility called mike and its corresponding mkdocs integration. In general it should not be necessary to test this, but if necessary, use the mike documentation to inspect locally.</p>"},{"location":"development/development/#versioning","title":"Versioning","text":"<p>Bumping the version across all files is done with bump-my-version, e.g.</p> <pre><code>bump-my-version bump major  # bumps from e.g. 0.3.2 to 1.0.0\nbump-my-version bump minor  # bumps from e.g. 0.3.2 to 0.4.0\nbump-my-version bump patch  # bumps from e.g. 0.3.2 to 0.3.3\n</code></pre>"},{"location":"development/development/#making-a-release","title":"Making a release","text":"<p>To create a release you need write permission on the repository.</p> <p>This section describes how to make a release:</p> <ol> <li>preparation</li> <li>making a release on GitHub</li> </ol>"},{"location":"development/development/#12-preparation","title":"(1/2) Preparation","text":"<ol> <li>Checkout the main branch locally</li> <li>Verify that the information (especially the author list) in <code>CITATION.cff</code> is correct.</li> <li>Make sure the version has been updated.</li> <li>Run the unit tests with <code>pytest -v</code></li> <li>Make sure the docs build and look good</li> </ol>"},{"location":"development/development/#22-github","title":"(2/2) GitHub","text":"<p>When all is well, navigate to the releases on GitHub.</p> <ol> <li>Press draft a new release button</li> <li>Select the \u201cChoose a tag\u201d drop down and write out the new version (e.g. v1.3.2)</li> <li>Press \u201cGenerate release notes\u201d to automatically fill the title (with the version number) and generate a description (the changelog from the merge pull requests)</li> <li>Press the Publish release button</li> </ol> <p>This will create the release on github and automatically trigger:</p> <ol> <li>The <code>.github/workflows/publish.yml</code> workflow which will build the package and publish it on PyPI</li> <li>The Zenodo-Github integration into making a snapshot of your repository and sticking a DOI on it and adding the new version to the main Zenodo entry for your software.</li> </ol>"},{"location":"examples/example_mibitrans_anatrans_comparison/","title":"Comparison Mibitrans-Anatrans","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\nfrom mibitrans.data.parameters import AttenuationParameters\nfrom mibitrans.data.parameters import HydrologicalParameters\nfrom mibitrans.data.parameters import ModelParameters\nfrom mibitrans.data.parameters import SourceParameters\nfrom mibitrans.transport.models import Anatrans\nfrom mibitrans.transport.models import Mibitrans\nfrom mibitrans.visualize.animation import animate_1d\n</pre> import matplotlib.pyplot as plt import numpy as np from mibitrans.data.parameters import AttenuationParameters from mibitrans.data.parameters import HydrologicalParameters from mibitrans.data.parameters import ModelParameters from mibitrans.data.parameters import SourceParameters from mibitrans.transport.models import Anatrans from mibitrans.transport.models import Mibitrans from mibitrans.visualize.animation import animate_1d In\u00a0[2]: Copied! <pre>hydro = HydrologicalParameters(\n    velocity=0.277, # Flow velocity [m/d]\n    porosity=0.25,           # Effective soil porosity [-]\n    alpha_x=10,         # Longitudinal dispersivity, in [m]\n    alpha_y=1,          # Transverse horizontal dispersivity, in [m]\n    alpha_z=0.1                # Transverse vertical dispersivity, in [m]\n)\n\natt = AttenuationParameters(\n    retardation=1,\n    # Molecular diffusion, in [m2/day]\n    diffusion=0,\n    # Contaminant half life, in [days]\n    half_life=0#5*365\n)\n\nsource = SourceParameters(\n    source_zone_boundary=np.array([10]),\n    source_zone_concentration=np.array([11]),\n    depth=2.5,\n    total_mass=\"inf\"\n)\n\nmodel = ModelParameters(\n    # Model extent in the longitudinal (x) direction in [m].\n    model_length = 800,\n    # Model extent in the transverse horizontal (y) direction in [m].\n    model_width = 150,\n    # Model duration in [days].\n    model_time = 5*365,\n    # Model grid discretization step size in the longitudinal (x) direction, in [m].\n    dx = 2,\n    # Model grid discretization step size in the transverse horizontal (y) direction, in [m].\n    dy = 1,\n    # Model time discretization step size, in [days]\n    dt = 25\n)\n</pre> hydro = HydrologicalParameters(     velocity=0.277, # Flow velocity [m/d]     porosity=0.25,           # Effective soil porosity [-]     alpha_x=10,         # Longitudinal dispersivity, in [m]     alpha_y=1,          # Transverse horizontal dispersivity, in [m]     alpha_z=0.1                # Transverse vertical dispersivity, in [m] )  att = AttenuationParameters(     retardation=1,     # Molecular diffusion, in [m2/day]     diffusion=0,     # Contaminant half life, in [days]     half_life=0#5*365 )  source = SourceParameters(     source_zone_boundary=np.array([10]),     source_zone_concentration=np.array([11]),     depth=2.5,     total_mass=\"inf\" )  model = ModelParameters(     # Model extent in the longitudinal (x) direction in [m].     model_length = 800,     # Model extent in the transverse horizontal (y) direction in [m].     model_width = 150,     # Model duration in [days].     model_time = 5*365,     # Model grid discretization step size in the longitudinal (x) direction, in [m].     dx = 2,     # Model grid discretization step size in the transverse horizontal (y) direction, in [m].     dy = 1,     # Model time discretization step size, in [days]     dt = 25 ) In\u00a0[3]: Copied! <pre>mbt_object = Mibitrans(hydro, att, source, model)\nmbt_object.run()\n\nana_object = Anatrans(hydro, att, source, model)\nana_object.run()\n</pre> mbt_object = Mibitrans(hydro, att, source, model) mbt_object.run()  ana_object = Anatrans(hydro, att, source, model) ana_object.run() Out[3]: <pre>&lt;mibitrans.transport.model_parent.Results at 0x7feafef47ed0&gt;</pre> In\u00a0[4]: Copied! <pre>%matplotlib notebook\n</pre> %matplotlib notebook In\u00a0[5]: Copied! <pre>ani = animate_1d(x_axis_parameter=mbt_object.y,\n                 y_axis_parameter=[mbt_object.cxyt[:,:,25], mbt_object.cxyt[:,:,50],\n                                   mbt_object.cxyt[:,:,100],mbt_object.cxyt[:,:,200],\n                                   ana_object.cxyt[:,:,25], ana_object.cxyt[:,:,50],\n                                   ana_object.cxyt[:,:,100], ana_object.cxyt[:,:,200]],\n                 time_parameter=mbt_object.t,\n                 y_colors=[\"darkgreen\", \"limegreen\", \"cornflowerblue\", \"blue\",\n                           \"green\", \"greenyellow\", \"darkturquoise\", \"dodgerblue\"],\n                 y_names=[\"Mibitrans x=50m\", \"Mibitrans x=100m\", \"Mibitrans x=200m\", \"Mibitrans x=400m\",\n                          \"Anatrans x=50m\", \"Anatrans x=100m\", \"Anatrans x=200m\", \"Anatrans x=400m\"],\n                 linestyle=[\"-\", \"-\", \"-\", \"-\", \"--\", \"--\", \"--\", \"--\"])\nplt.xlabel(\"y-position [m]\")\nplt.show()\n</pre> ani = animate_1d(x_axis_parameter=mbt_object.y,                  y_axis_parameter=[mbt_object.cxyt[:,:,25], mbt_object.cxyt[:,:,50],                                    mbt_object.cxyt[:,:,100],mbt_object.cxyt[:,:,200],                                    ana_object.cxyt[:,:,25], ana_object.cxyt[:,:,50],                                    ana_object.cxyt[:,:,100], ana_object.cxyt[:,:,200]],                  time_parameter=mbt_object.t,                  y_colors=[\"darkgreen\", \"limegreen\", \"cornflowerblue\", \"blue\",                            \"green\", \"greenyellow\", \"darkturquoise\", \"dodgerblue\"],                  y_names=[\"Mibitrans x=50m\", \"Mibitrans x=100m\", \"Mibitrans x=200m\", \"Mibitrans x=400m\",                           \"Anatrans x=50m\", \"Anatrans x=100m\", \"Anatrans x=200m\", \"Anatrans x=400m\"],                  linestyle=[\"-\", \"-\", \"-\", \"-\", \"--\", \"--\", \"--\", \"--\"]) plt.xlabel(\"y-position [m]\") plt.show()  In\u00a0[6]: Copied! <pre>ani1 = animate_1d(x_axis_parameter=mbt_object.x,\n                  y_axis_parameter=[mbt_object.cxyt[:,75,:], mbt_object.cxyt[:,84,:],\n                                    mbt_object.cxyt[:,100,:], mbt_object.cxyt[:,125,:],\n                                   ana_object.cxyt[:,75,:], ana_object.cxyt[:,84,:],\n                                    ana_object.cxyt[:,100,:], ana_object.cxyt[:,125,:]],\n                  time_parameter=mbt_object.t,\n                  y_colors=[\"darkgreen\", \"limegreen\", \"cornflowerblue\", \"blue\",\n                            \"green\", \"greenyellow\", \"darkturquoise\", \"dodgerblue\"],\n                  y_names=[\"Mibitrans y=0m\", \"Mibitrans y=9m\", \"Mibitrans y=25m\", \"Mibitrans y=50m\",\n                           \"Anatrans y=0m\", \"Anatrans y=9m\", \"Anatrans y=25m\", \"Anatrans y=50m\"],\n                  linestyle=[\"-\", \"-\", \"-\", \"-\", \"--\", \"--\", \"--\", \"--\"])\nplt.xlabel(\"x-position [m]\")\nplt.show()\n</pre> ani1 = animate_1d(x_axis_parameter=mbt_object.x,                   y_axis_parameter=[mbt_object.cxyt[:,75,:], mbt_object.cxyt[:,84,:],                                     mbt_object.cxyt[:,100,:], mbt_object.cxyt[:,125,:],                                    ana_object.cxyt[:,75,:], ana_object.cxyt[:,84,:],                                     ana_object.cxyt[:,100,:], ana_object.cxyt[:,125,:]],                   time_parameter=mbt_object.t,                   y_colors=[\"darkgreen\", \"limegreen\", \"cornflowerblue\", \"blue\",                             \"green\", \"greenyellow\", \"darkturquoise\", \"dodgerblue\"],                   y_names=[\"Mibitrans y=0m\", \"Mibitrans y=9m\", \"Mibitrans y=25m\", \"Mibitrans y=50m\",                            \"Anatrans y=0m\", \"Anatrans y=9m\", \"Anatrans y=25m\", \"Anatrans y=50m\"],                   linestyle=[\"-\", \"-\", \"-\", \"-\", \"--\", \"--\", \"--\", \"--\"]) plt.xlabel(\"x-position [m]\") plt.show()  In\u00a0[7]: Copied! <pre>plt.figure()\nmbt_object.breakthrough(50, 0, color=\"darkgreen\", linestyle=\"-\", label=\"Mibitrans 50m\")\nmbt_object.breakthrough(100, 0, color=\"limegreen\", linestyle=\"-\", label=\"Mibitrans 100m\")\nmbt_object.breakthrough(200, 0, color=\"cornflowerblue\", linestyle=\"-\", label=\"Mibitrans 200m\")\nmbt_object.breakthrough(400, 0, color=\"blue\", linestyle=\"-\", label=\"Mibitrans 400m\")\nana_object.breakthrough(50, 0, color=\"green\", linestyle=\"--\", label=\"Anatrans 50m\")\nana_object.breakthrough(100, 0, color=\"greenyellow\", linestyle=\"--\", label=\"Anatrans 100m\")\nana_object.breakthrough(200, 0, color=\"darkturquoise\", linestyle=\"--\", label=\"Anatrans 200m\")\nana_object.breakthrough(400, 0, color=\"dodgerblue\", linestyle=\"--\", label=\"Anatrans 400m\")\nplt.title(\"Breakthrough plot of Mibitrans and Anatrans model, at various x locations.\")\nplt.legend()\nplt.show()\n</pre> plt.figure() mbt_object.breakthrough(50, 0, color=\"darkgreen\", linestyle=\"-\", label=\"Mibitrans 50m\") mbt_object.breakthrough(100, 0, color=\"limegreen\", linestyle=\"-\", label=\"Mibitrans 100m\") mbt_object.breakthrough(200, 0, color=\"cornflowerblue\", linestyle=\"-\", label=\"Mibitrans 200m\") mbt_object.breakthrough(400, 0, color=\"blue\", linestyle=\"-\", label=\"Mibitrans 400m\") ana_object.breakthrough(50, 0, color=\"green\", linestyle=\"--\", label=\"Anatrans 50m\") ana_object.breakthrough(100, 0, color=\"greenyellow\", linestyle=\"--\", label=\"Anatrans 100m\") ana_object.breakthrough(200, 0, color=\"darkturquoise\", linestyle=\"--\", label=\"Anatrans 200m\") ana_object.breakthrough(400, 0, color=\"dodgerblue\", linestyle=\"--\", label=\"Anatrans 400m\") plt.title(\"Breakthrough plot of Mibitrans and Anatrans model, at various x locations.\") plt.legend() plt.show() <pre>\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[7], line 2\n      1 plt.figure()\n----&gt; 2 mbt_object.breakthrough(50, 0, color=\"darkgreen\", linestyle=\"-\", label=\"Mibitrans 50m\")\n      3 mbt_object.breakthrough(100, 0, color=\"limegreen\", linestyle=\"-\", label=\"Mibitrans 100m\")\n      4 mbt_object.breakthrough(200, 0, color=\"cornflowerblue\", linestyle=\"-\", label=\"Mibitrans 200m\")\n\nAttributeError: 'Mibitrans' object has no attribute 'breakthrough'</pre> In\u00a0[8]: Copied! <pre>parameter_list = [0.1, 0.5, 1, 5, 10]\noutput_list_mbt = []\noutput_list_ana = []\nfor par in parameter_list:\n    print(f\"starting run with par = {par}\")\n    mbt_object = Mibitrans(hydro, att, source, model)\n    mbt_object.hydrological_parameters.alpha_x = par\n    mbt_object.hydrological_parameters.alpha_y = par / 10\n    mbt_object.hydrological_parameters.alpha_z = par / 100\n    mbt_object.run()\n    output_list_mbt.append(mbt_object.cxyt)\n\n    ana_object = Anatrans(hydro, att, source, model)\n    ana_object.hydrological_parameters.alpha_x = par\n    ana_object.hydrological_parameters.alpha_y = par / 10\n    ana_object.hydrological_parameters.alpha_z = par / 100\n    ana_object.run()\n    output_list_ana.append(ana_object.cxyt)\n</pre> parameter_list = [0.1, 0.5, 1, 5, 10] output_list_mbt = [] output_list_ana = [] for par in parameter_list:     print(f\"starting run with par = {par}\")     mbt_object = Mibitrans(hydro, att, source, model)     mbt_object.hydrological_parameters.alpha_x = par     mbt_object.hydrological_parameters.alpha_y = par / 10     mbt_object.hydrological_parameters.alpha_z = par / 100     mbt_object.run()     output_list_mbt.append(mbt_object.cxyt)      ana_object = Anatrans(hydro, att, source, model)     ana_object.hydrological_parameters.alpha_x = par     ana_object.hydrological_parameters.alpha_y = par / 10     ana_object.hydrological_parameters.alpha_z = par / 100     ana_object.run()     output_list_ana.append(ana_object.cxyt) <pre>starting run with par = 0.1\n</pre> <pre>starting run with par = 0.5\n</pre> <pre>starting run with par = 1\n</pre> <pre>starting run with par = 5\n</pre> <pre>starting run with par = 10\n</pre> In\u00a0[9]: Copied! <pre>colors_mbt = [\"darkgreen\", \"limegreen\", \"cornflowerblue\", \"blue\", \"indigo\"]\ncolors_ana = [\"green\", \"greenyellow\", \"darkturquoise\", \"dodgerblue\", \"darkviolet\"]\nplt.figure()\nfor i, conc in enumerate(output_list_mbt):\n    plt.plot(mbt_object.x, conc[-1,75,:], color=colors_mbt[i], label=f\"Mibitrans a={parameter_list[i]}m\")\nfor i, conc in enumerate(output_list_ana):\n    plt.plot(ana_object.x, conc[-1,75,:], color=colors_ana[i], linestyle=\"--\", label=f\"Anatrans a={parameter_list[i]}m\")\nplt.legend()\nplt.show()\n</pre> colors_mbt = [\"darkgreen\", \"limegreen\", \"cornflowerblue\", \"blue\", \"indigo\"] colors_ana = [\"green\", \"greenyellow\", \"darkturquoise\", \"dodgerblue\", \"darkviolet\"] plt.figure() for i, conc in enumerate(output_list_mbt):     plt.plot(mbt_object.x, conc[-1,75,:], color=colors_mbt[i], label=f\"Mibitrans a={parameter_list[i]}m\") for i, conc in enumerate(output_list_ana):     plt.plot(ana_object.x, conc[-1,75,:], color=colors_ana[i], linestyle=\"--\", label=f\"Anatrans a={parameter_list[i]}m\") plt.legend() plt.show() In\u00a0[10]: Copied! <pre>colors_mbt = [\"darkgreen\", \"limegreen\", \"cornflowerblue\", \"blue\", \"indigo\"]\ncolors_ana = [\"green\", \"greenyellow\", \"darkturquoise\", \"dodgerblue\", \"darkviolet\"]\nplt.figure()\nfor i, conc in enumerate(output_list_mbt):\n    plt.plot(mbt_object.y, conc[-1,:,175], color=colors_mbt[i],\n             label=f\"Mibitrans a={parameter_list[i]}m\")\nfor i, conc in enumerate(output_list_ana):\n    plt.plot(ana_object.y, conc[-1,:,175], color=colors_ana[i],\n             linestyle=\"--\", label=f\"Anatrans a={parameter_list[i]}m\")\nplt.legend()\nplt.show()\n</pre> colors_mbt = [\"darkgreen\", \"limegreen\", \"cornflowerblue\", \"blue\", \"indigo\"] colors_ana = [\"green\", \"greenyellow\", \"darkturquoise\", \"dodgerblue\", \"darkviolet\"] plt.figure() for i, conc in enumerate(output_list_mbt):     plt.plot(mbt_object.y, conc[-1,:,175], color=colors_mbt[i],              label=f\"Mibitrans a={parameter_list[i]}m\") for i, conc in enumerate(output_list_ana):     plt.plot(ana_object.y, conc[-1,:,175], color=colors_ana[i],              linestyle=\"--\", label=f\"Anatrans a={parameter_list[i]}m\") plt.legend() plt.show() In\u00a0[11]: Copied! <pre>parameter_list_v = [0.1, 0.1, 0.1, 0.1, 0.1]\nparameter_list_a = [10, 5, 2, 1, 0.5]\noutput_list_mbt_v = []\noutput_list_ana_v = []\nfor i in range(len(parameter_list_v)):\n    parv = parameter_list_v[i]\n    para = parameter_list_a[i]\n    print(f\"starting run with parv = {parv} and para = {para}\")\n    mbt_object = Mibitrans(hydro, att, source, model)\n    mbt_object.hydrological_parameters.velocity = parv\n    mbt_object.hydrological_parameters.alpha_x = para\n    mbt_object.hydrological_parameters.alpha_y = para / 10\n    mbt_object.hydrological_parameters.alpha_z = 0#para / 100\n    mbt_object.run()\n    output_list_mbt_v.append(mbt_object.cxyt)\n\n    ana_object = Anatrans(hydro, att, source, model)\n    ana_object.hydrological_parameters.velocity = parv\n    ana_object.hydrological_parameters.alpha_x = para\n    ana_object.hydrological_parameters.alpha_y = para / 10\n    ana_object.hydrological_parameters.alpha_z = 0#para / 100\n    ana_object.run()\n    output_list_ana_v.append(ana_object.cxyt)\n</pre> parameter_list_v = [0.1, 0.1, 0.1, 0.1, 0.1] parameter_list_a = [10, 5, 2, 1, 0.5] output_list_mbt_v = [] output_list_ana_v = [] for i in range(len(parameter_list_v)):     parv = parameter_list_v[i]     para = parameter_list_a[i]     print(f\"starting run with parv = {parv} and para = {para}\")     mbt_object = Mibitrans(hydro, att, source, model)     mbt_object.hydrological_parameters.velocity = parv     mbt_object.hydrological_parameters.alpha_x = para     mbt_object.hydrological_parameters.alpha_y = para / 10     mbt_object.hydrological_parameters.alpha_z = 0#para / 100     mbt_object.run()     output_list_mbt_v.append(mbt_object.cxyt)      ana_object = Anatrans(hydro, att, source, model)     ana_object.hydrological_parameters.velocity = parv     ana_object.hydrological_parameters.alpha_x = para     ana_object.hydrological_parameters.alpha_y = para / 10     ana_object.hydrological_parameters.alpha_z = 0#para / 100     ana_object.run()     output_list_ana_v.append(ana_object.cxyt) <pre>starting run with parv = 0.1 and para = 10\n</pre> <pre>starting run with parv = 0.1 and para = 5\n</pre> <pre>starting run with parv = 0.1 and para = 2\n</pre> <pre>starting run with parv = 0.1 and para = 1\n</pre> <pre>starting run with parv = 0.1 and para = 0.5\n</pre> In\u00a0[12]: Copied! <pre>colors_mbt = [\"darkgreen\", \"limegreen\", \"cornflowerblue\", \"blue\", \"indigo\"]\ncolors_ana = [\"green\", \"greenyellow\", \"darkturquoise\", \"dodgerblue\", \"darkviolet\"]\nplt.figure()\nfor i, conc in enumerate(output_list_mbt_v):\n    plt.plot(mbt_object.x, conc[-1,75,:], color=colors_mbt[i],\n             label=f\"Mbt v={parameter_list_v[i]}m/d, a={parameter_list_a[i]}m\")\nfor i, conc in enumerate(output_list_ana_v):\n    plt.plot(ana_object.x, conc[-1,75,:], color=colors_ana[i],\n             linestyle=\"--\", label=f\"Ana v={parameter_list_v[i]}m/d, a={parameter_list_a[i]}m\")\nplt.xlim((0,300))\nplt.legend()\nplt.show()\n</pre> colors_mbt = [\"darkgreen\", \"limegreen\", \"cornflowerblue\", \"blue\", \"indigo\"] colors_ana = [\"green\", \"greenyellow\", \"darkturquoise\", \"dodgerblue\", \"darkviolet\"] plt.figure() for i, conc in enumerate(output_list_mbt_v):     plt.plot(mbt_object.x, conc[-1,75,:], color=colors_mbt[i],              label=f\"Mbt v={parameter_list_v[i]}m/d, a={parameter_list_a[i]}m\") for i, conc in enumerate(output_list_ana_v):     plt.plot(ana_object.x, conc[-1,75,:], color=colors_ana[i],              linestyle=\"--\", label=f\"Ana v={parameter_list_v[i]}m/d, a={parameter_list_a[i]}m\") plt.xlim((0,300)) plt.legend() plt.show() In\u00a0[13]: Copied! <pre>colors_mbt = [\"darkgreen\", \"limegreen\", \"cornflowerblue\", \"blue\", \"indigo\"]\ncolors_ana = [\"green\", \"greenyellow\", \"darkturquoise\", \"dodgerblue\", \"darkviolet\"]\nplt.figure()\nfor i, conc in enumerate(output_list_mbt_v):\n    plt.plot(mbt_object.y, conc[-1, :, 75], color=colors_mbt[i], label=f\"Mibitrans a={parameter_list_v[i]}m\")\nfor i, conc in enumerate(output_list_ana_v):\n    plt.plot(ana_object.y, conc[-1, :, 75], color=colors_ana[i], linestyle=\"--\",\n             label=f\"Anatrans a={parameter_list[i]}m\")\nplt.legend()\nplt.show()\n</pre> colors_mbt = [\"darkgreen\", \"limegreen\", \"cornflowerblue\", \"blue\", \"indigo\"] colors_ana = [\"green\", \"greenyellow\", \"darkturquoise\", \"dodgerblue\", \"darkviolet\"] plt.figure() for i, conc in enumerate(output_list_mbt_v):     plt.plot(mbt_object.y, conc[-1, :, 75], color=colors_mbt[i], label=f\"Mibitrans a={parameter_list_v[i]}m\") for i, conc in enumerate(output_list_ana_v):     plt.plot(ana_object.y, conc[-1, :, 75], color=colors_ana[i], linestyle=\"--\",              label=f\"Anatrans a={parameter_list[i]}m\") plt.legend() plt.show() In\u00a0[14]: Copied! <pre>mbtv=output_list_mbt_v\nanav=output_list_ana_v\nani = animate_1d(x_axis_parameter=mbt_object.x,\n                 y_axis_parameter=[mbtv[0][:,75,:], mbtv[1][:,75,:],mbtv[2][:,75,:],\n                                   mbtv[3][:,75,:], mbtv[4][:,75,:],\n                                   anav[0][:,75,:], anav[1][:,75,:], anav[2][:,75,:],\n                                   anav[3][:,75,:], anav[4][:,75,:]],\n                 time_parameter=mbt_object.t,\n                 y_colors=[\"darkgreen\", \"limegreen\", \"cornflowerblue\", \"blue\", \"indigo\",\n                           \"green\", \"greenyellow\", \"darkturquoise\", \"dodgerblue\", \"violet\"],\n                 y_names=[\"Mibitrans a=0.1\", \"Mibitrans a=0.5\", \"Mibitrans a=1\", \"Mibitrans a=5\", \"Mibitrans a=10\",\n                          \"Anatrans a=0.1\", \"Anatrans a=0.5\", \"Anatrans a=1\", \"Anatrans a=5\", \"Anatrans a=10\"],\n                 linestyle=[\"-\", \"-\", \"-\", \"-\", \"-\", \"--\", \"--\", \"--\", \"--\", \"--\"])\nplt.xlabel(\"y-position [m]\")\nplt.xlim((0,350))\nplt.show()\n</pre> mbtv=output_list_mbt_v anav=output_list_ana_v ani = animate_1d(x_axis_parameter=mbt_object.x,                  y_axis_parameter=[mbtv[0][:,75,:], mbtv[1][:,75,:],mbtv[2][:,75,:],                                    mbtv[3][:,75,:], mbtv[4][:,75,:],                                    anav[0][:,75,:], anav[1][:,75,:], anav[2][:,75,:],                                    anav[3][:,75,:], anav[4][:,75,:]],                  time_parameter=mbt_object.t,                  y_colors=[\"darkgreen\", \"limegreen\", \"cornflowerblue\", \"blue\", \"indigo\",                            \"green\", \"greenyellow\", \"darkturquoise\", \"dodgerblue\", \"violet\"],                  y_names=[\"Mibitrans a=0.1\", \"Mibitrans a=0.5\", \"Mibitrans a=1\", \"Mibitrans a=5\", \"Mibitrans a=10\",                           \"Anatrans a=0.1\", \"Anatrans a=0.5\", \"Anatrans a=1\", \"Anatrans a=5\", \"Anatrans a=10\"],                  linestyle=[\"-\", \"-\", \"-\", \"-\", \"-\", \"--\", \"--\", \"--\", \"--\", \"--\"]) plt.xlabel(\"y-position [m]\") plt.xlim((0,350)) plt.show()  <pre>/opt/hostedtoolcache/Python/3.13.11/x64/lib/python3.13/site-packages/matplotlib/animation.py:908: UserWarning: Animation was deleted without rendering anything. This is most likely not intended. To prevent deletion, assign the Animation to a variable, e.g. `anim`, that exists until you output the Animation using `plt.show()` or `anim.save()`.\n  warnings.warn(\n</pre> In\u00a0[15]: Copied! <pre>mbtv=output_list_mbt_v\nanav=output_list_ana_v\nani = animate_1d(x_axis_parameter=mbt_object.y,\n                 y_axis_parameter=[mbtv[0][:,:,50], mbtv[1][:,:,50], mbtv[2][:,:,50],\n                                   mbtv[3][:,:,50], mbtv[4][:,:,50],\n                                   anav[0][:,:,50], anav[1][:,:,50], anav[2][:,:,50],\n                                   anav[3][:,:,50], anav[4][:,:,50]],\n                 time_parameter=mbt_object.t,\n                 y_colors=[\"darkgreen\", \"limegreen\", \"cornflowerblue\", \"blue\", \"indigo\",\n                           \"green\", \"greenyellow\", \"darkturquoise\", \"dodgerblue\", \"violet\"],\n                 y_names=[\"Mibitrans a=0.1\", \"Mibitrans a=0.5\", \"Mibitrans a=1\", \"Mibitrans a=5\", \"Mibitrans a=10\",\n                          \"Anatrans a=0.1\", \"Anatrans a=0.5\", \"Anatrans a=1\", \"Anatrans a=5\", \"Anatrans a=10\"],\n                 linestyle=[\"-\", \"-\", \"-\", \"-\", \"-\", \"--\", \"--\", \"--\", \"--\", \"--\"])\nplt.xlabel(\"y-position [m]\")\n\nplt.show()\n</pre> mbtv=output_list_mbt_v anav=output_list_ana_v ani = animate_1d(x_axis_parameter=mbt_object.y,                  y_axis_parameter=[mbtv[0][:,:,50], mbtv[1][:,:,50], mbtv[2][:,:,50],                                    mbtv[3][:,:,50], mbtv[4][:,:,50],                                    anav[0][:,:,50], anav[1][:,:,50], anav[2][:,:,50],                                    anav[3][:,:,50], anav[4][:,:,50]],                  time_parameter=mbt_object.t,                  y_colors=[\"darkgreen\", \"limegreen\", \"cornflowerblue\", \"blue\", \"indigo\",                            \"green\", \"greenyellow\", \"darkturquoise\", \"dodgerblue\", \"violet\"],                  y_names=[\"Mibitrans a=0.1\", \"Mibitrans a=0.5\", \"Mibitrans a=1\", \"Mibitrans a=5\", \"Mibitrans a=10\",                           \"Anatrans a=0.1\", \"Anatrans a=0.5\", \"Anatrans a=1\", \"Anatrans a=5\", \"Anatrans a=10\"],                  linestyle=[\"-\", \"-\", \"-\", \"-\", \"-\", \"--\", \"--\", \"--\", \"--\", \"--\"]) plt.xlabel(\"y-position [m]\")  plt.show()"},{"location":"examples/example_mibitrans_anatrans_comparison/#exact-solution-versus-untruncated-solution","title":"Exact solution versus untruncated solution\u00b6","text":"<p>\\begin{equation} C(x,y,z,t) = \\sum_{i=1}^{n}\\left(C^*_{0,i}\\frac{x}{8\\sqrt{\\pi D^{'}_{x}}}\\exp(-\\gamma t) \\cdot \\int_{0}^{t}\\left[\\frac{1}{\\tau^{\\frac{3}{2}}} \\exp\\left((\\gamma - \\lambda_{EFF})\\tau - \\frac{(x-v^{'}\\tau)^2}{4D^{'}_{x}\\tau}\\right) \\cdot \\left\\{ERFC\\left(\\frac{y-Y_i}{2 \\sqrt{D^{'}_{y}\\tau}}\\right)-ERFC\\left(\\frac{y+Y_i}{2 \\sqrt{D^{'}_{y}\\tau}}\\right) \\right\\} \\cdot \\left\\{ERFC\\left(\\frac{z-Z}{2 \\sqrt{D^{'}_{z}\\tau}}\\right)-ERFC\\left(\\frac{z+Z}{2 \\sqrt{D^{'}_{z}\\tau}}\\right) \\right\\}\\right] d\\tau \\right) \\end{equation}</p>"},{"location":"examples/example_mibitrans_anatrans_comparison/#comparing-model-differences-for-various-flow-velocities-and-dispersivities","title":"Comparing model differences for various flow velocities and dispersivities\u00b6","text":""},{"location":"examples/example_walkthrough/","title":"Walkthrough","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\nfrom mibitrans.data.parameter_information import ElectronAcceptors\nfrom mibitrans.data.parameter_information import UtilizationFactor\nfrom mibitrans.data.parameters import AttenuationParameters\nfrom mibitrans.data.parameters import HydrologicalParameters\nfrom mibitrans.data.parameters import ModelParameters\nfrom mibitrans.data.parameters import SourceParameters\nfrom mibitrans.transport.models import Anatrans\nfrom mibitrans.transport.models import Bioscreen\nfrom mibitrans.transport.models import Mibitrans\nfrom mibitrans.visualize.plot_line import breakthrough\nfrom mibitrans.visualize.plot_line import centerline\nfrom mibitrans.visualize.plot_line import transverse\nfrom mibitrans.visualize.plot_surface import plume_2d\nfrom mibitrans.visualize.plot_surface import plume_3d\n</pre> import matplotlib.pyplot as plt import numpy as np from mibitrans.data.parameter_information import ElectronAcceptors from mibitrans.data.parameter_information import UtilizationFactor from mibitrans.data.parameters import AttenuationParameters from mibitrans.data.parameters import HydrologicalParameters from mibitrans.data.parameters import ModelParameters from mibitrans.data.parameters import SourceParameters from mibitrans.transport.models import Anatrans from mibitrans.transport.models import Bioscreen from mibitrans.transport.models import Mibitrans from mibitrans.visualize.plot_line import breakthrough from mibitrans.visualize.plot_line import centerline from mibitrans.visualize.plot_line import transverse from mibitrans.visualize.plot_surface import plume_2d from mibitrans.visualize.plot_surface import plume_3d <p>The showcase of mibitrans below uses example data originating from BIOSCREEN, the Excel based modeling software this package took inspiration from. Describes field conditions on the Keesler Air Force Base in Mississippi, USA. Movement of mixed BTEX plume from 1989 to 1995. For more details, see Newell et al. (1997)</p> <p>As it was developed in the USA, length units are in ft. We'll use a conversion factor to express length in m instead.</p> <p>Newell, C. J., McLeod, R. K., &amp; Gonzales, J. R. (1997). BIOSCREEN natural attenuation decision support system version 1.4 revisions, Tech. rep., U.S. EPA.</p> In\u00a0[2]: Copied! <pre>ft = 3.281 # factor to convert ft to m\n</pre> ft = 3.281 # factor to convert ft to m In\u00a0[3]: Copied! <pre>hydro = HydrologicalParameters(\n    velocity=113.8/ft/365,   # Groundwater flow velocity, in [m/day]\n    porosity=0.25,           # Effective soil porosity [-]\n    alpha_x=13.3/ft,         # Longitudinal dispersivity, in [m]\n    alpha_y=1.3/ft,          # Transverse horizontal dispersivity, in [m]\n    alpha_z=0                # Transverse vertical dispersivity, in [m]\n)\n\n# Alternative by specifying hydraulic gradient and hydraulic conductivity\nhydro = HydrologicalParameters(\n    h_gradient=0.048,        # Hydraulic gradient [-]\n    h_conductivity=0.495,    # Hydraulic conductivity [m/day]\n    porosity=0.25,           # Effective soil porosity [-]\n    alpha_x=13.3/ft,         # Longitudinal dispersivity, in [m]\n    alpha_y=1.3/ft,          # Transverse horizontal dispersivity, in [m]\n    alpha_z=0                # Transverse vertical dispersivity, in [m]\n)\n\n# And then check the value:\nprint(\"The calculated groundwater flow velocity is: \", hydro.velocity, r\"m/d\")\n\n# Any other input parameters can be requested by specifying the argument;\nprint(f\"The dispersivity values are: {hydro.alpha_x}m, {hydro.alpha_y}m and {hydro.alpha_z}m,\"\n      \" for the x, y and z directions respectively.\")\n</pre> hydro = HydrologicalParameters(     velocity=113.8/ft/365,   # Groundwater flow velocity, in [m/day]     porosity=0.25,           # Effective soil porosity [-]     alpha_x=13.3/ft,         # Longitudinal dispersivity, in [m]     alpha_y=1.3/ft,          # Transverse horizontal dispersivity, in [m]     alpha_z=0                # Transverse vertical dispersivity, in [m] )  # Alternative by specifying hydraulic gradient and hydraulic conductivity hydro = HydrologicalParameters(     h_gradient=0.048,        # Hydraulic gradient [-]     h_conductivity=0.495,    # Hydraulic conductivity [m/day]     porosity=0.25,           # Effective soil porosity [-]     alpha_x=13.3/ft,         # Longitudinal dispersivity, in [m]     alpha_y=1.3/ft,          # Transverse horizontal dispersivity, in [m]     alpha_z=0                # Transverse vertical dispersivity, in [m] )  # And then check the value: print(\"The calculated groundwater flow velocity is: \", hydro.velocity, r\"m/d\")  # Any other input parameters can be requested by specifying the argument; print(f\"The dispersivity values are: {hydro.alpha_x}m, {hydro.alpha_y}m and {hydro.alpha_z}m,\"       \" for the x, y and z directions respectively.\")  <pre>The calculated groundwater flow velocity is:  0.09504 m/d\nThe dispersivity values are: 4.053642182261505m, 0.3962206644315757m and 0m, for the x, y and z directions respectively.\n</pre> In\u00a0[4]: Copied! <pre>att = AttenuationParameters(\n    # Retardation factor for transported contaminants\n    retardation=1\n)\n\n# Alternatively, calculate the retardation factor by supplying soil and contaminant properties\natt = AttenuationParameters(\n    # Soil bulk density in [g/m^3]\n    bulk_density=1.7,\n    # Partition coefficient of the transported contaminant to soil organic matter, in [m^3/g]\n    partition_coefficient=38,\n    # Fraction of organic material in the soil [-]\n    fraction_organic_carbon=5.7e-5\n)\n\n# Calculate the retardation factor beforehand to see its value by specifying the porosity\natt.calculate_retardation(porosity=hydro.porosity)\n\n# And then check the value:\nprint(\"The calculated retardation value is: \", att.retardation)\n\natt = AttenuationParameters(\n    # Retardation factor for transported contaminants\n    retardation=1,\n    # Molecular diffusion, in [m2/day]\n    diffusion=1e-5\n)\n</pre> att = AttenuationParameters(     # Retardation factor for transported contaminants     retardation=1 )  # Alternatively, calculate the retardation factor by supplying soil and contaminant properties att = AttenuationParameters(     # Soil bulk density in [g/m^3]     bulk_density=1.7,     # Partition coefficient of the transported contaminant to soil organic matter, in [m^3/g]     partition_coefficient=38,     # Fraction of organic material in the soil [-]     fraction_organic_carbon=5.7e-5 )  # Calculate the retardation factor beforehand to see its value by specifying the porosity att.calculate_retardation(porosity=hydro.porosity)  # And then check the value: print(\"The calculated retardation value is: \", att.retardation)  att = AttenuationParameters(     # Retardation factor for transported contaminants     retardation=1,     # Molecular diffusion, in [m2/day]     diffusion=1e-5 ) <pre>The calculated retardation value is:  1.0147288\n</pre> In\u00a0[5]: Copied! <pre>att = AttenuationParameters(\n    # Contaminant first order decay rate in [1/days]\n    decay_rate=0.0127\n)\n\n# Alternatively, specify the contaminant half life\natt = AttenuationParameters(\n    # Contaminant half life, in [days]\n    half_life=54.75,\n)\n</pre> att = AttenuationParameters(     # Contaminant first order decay rate in [1/days]     decay_rate=0.0127 )  # Alternatively, specify the contaminant half life att = AttenuationParameters(     # Contaminant half life, in [days]     half_life=54.75, )  <p>For the examples below, we'll set the attenuation parameters to the desired settings</p> In\u00a0[6]: Copied! <pre>att = AttenuationParameters(\n    # Soil bulk density in [g/m^3]\n    bulk_density=1.7,\n    # Partition coefficient of the transported contaminant to soil organic matter, in [m^3/g]\n    partition_coefficient=38,\n    # Fraction of organic material in the soil [-]\n    fraction_organic_carbon=5.7e-5,\n    # Molecular diffusion, in [m2/day]\n    diffusion=0,\n    # Contaminant half life, in [days]\n    half_life=365#54.75,\n)\n</pre> att = AttenuationParameters(     # Soil bulk density in [g/m^3]     bulk_density=1.7,     # Partition coefficient of the transported contaminant to soil organic matter, in [m^3/g]     partition_coefficient=38,     # Fraction of organic material in the soil [-]     fraction_organic_carbon=5.7e-5,     # Molecular diffusion, in [m2/day]     diffusion=0,     # Contaminant half life, in [days]     half_life=365#54.75, ) In\u00a0[7]: Copied! <pre># Input for a simple source zone with a width of 19.8m (65ft) and a continuous input (infinite source mass)\nsource = SourceParameters(\n    # Source zone boundaries, in [m] (simply using a float instead of a numpy array for\n    # single source zone input will work as well)\n    source_zone_boundary=np.array([65/ft]),\n    # Source zone concentrations, in [g/m^3]\n    source_zone_concentration=np.array([5]),\n    # Source depth extent, in [m]\n    depth=10/ft,\n    # Source mass, considered infinite\n    total_mass=\"inf\"\n)\n\n# Alternatively, specify a source mass to allow for source decay\nsource = SourceParameters(\n    source_zone_boundary=np.array([7/ft, 37/ft, 65/ft]),\n    source_zone_concentration=np.array([13.68, 2.508, 0.057]),\n    depth=10/ft,\n    total_mass=2000000\n)\n\n# Visualize what the source zone looks like to check your input:\nsource.visualize()\nplt.show()\n</pre> # Input for a simple source zone with a width of 19.8m (65ft) and a continuous input (infinite source mass) source = SourceParameters(     # Source zone boundaries, in [m] (simply using a float instead of a numpy array for     # single source zone input will work as well)     source_zone_boundary=np.array([65/ft]),     # Source zone concentrations, in [g/m^3]     source_zone_concentration=np.array([5]),     # Source depth extent, in [m]     depth=10/ft,     # Source mass, considered infinite     total_mass=\"inf\" )  # Alternatively, specify a source mass to allow for source decay source = SourceParameters(     source_zone_boundary=np.array([7/ft, 37/ft, 65/ft]),     source_zone_concentration=np.array([13.68, 2.508, 0.057]),     depth=10/ft,     total_mass=2000000 )  # Visualize what the source zone looks like to check your input: source.visualize() plt.show() In\u00a0[8]: Copied! <pre>model = ModelParameters(\n    # Model extent in the longitudinal (x) direction in [m].\n    model_length = 320/ft,\n    # Model extent in the transverse horizontal (y) direction in [m].\n    model_width = 100/ft,\n    # Model duration in [days].\n    model_time = 6 * 365,\n    # Model grid discretization step size in the longitudinal (x) direction, in [m].\n    dx = 1/ft,\n    # Model grid discretization step size in the transverse horizontal (y) direction, in [m].\n    dy = 1/ft,\n    # Model time discretization step size, in [days]\n    dt = 365 / 5\n)\n</pre> model = ModelParameters(     # Model extent in the longitudinal (x) direction in [m].     model_length = 320/ft,     # Model extent in the transverse horizontal (y) direction in [m].     model_width = 100/ft,     # Model duration in [days].     model_time = 6 * 365,     # Model grid discretization step size in the longitudinal (x) direction, in [m].     dx = 1/ft,     # Model grid discretization step size in the transverse horizontal (y) direction, in [m].     dy = 1/ft,     # Model time discretization step size, in [days]     dt = 365 / 5 ) In\u00a0[9]: Copied! <pre># If not all required parameters are specified, an error will be shown;\n# HydrologicalParameters needs the porosity, longitudinal dispersivity and transverse horizontal dispersivity as well.\nfake_hydro = HydrologicalParameters(velocity = 1)\n</pre> # If not all required parameters are specified, an error will be shown; # HydrologicalParameters needs the porosity, longitudinal dispersivity and transverse horizontal dispersivity as well. fake_hydro = HydrologicalParameters(velocity = 1) <pre>\n---------------------------------------------------------------------------\nMissingValueError                         Traceback (most recent call last)\nCell In[9], line 3\n      1 # If not all required parameters are specified, an error will be shown;\n      2 # HydrologicalParameters needs the porosity, longitudinal dispersivity and transverse horizontal dispersivity as well.\n----&gt; 3 fake_hydro = HydrologicalParameters(velocity = 1)\n\nFile &lt;string&gt;:11, in __init__(self, velocity, h_gradient, h_conductivity, porosity, alpha_x, alpha_y, alpha_z, verbose)\n\nFile /opt/hostedtoolcache/Python/3.13.11/x64/lib/python3.13/site-packages/mibitrans/data/parameters.py:51, in HydrologicalParameters.__post_init__(self)\n     49 def __post_init__(self):\n     50     \"\"\"Check argument presence, types and domain. Calculate velocity if not given.\"\"\"\n---&gt; 51     self._validate_input_presence()\n     53     # Velocity is calculated from hydraulic gradient and conductivity when both are given.\n     54     if self.h_gradient and self.h_conductivity:\n     55         # Giving h_gradient &amp; h_conductivity more specific than giving velocity. Input velocity will be overridden.\n\nFile /opt/hostedtoolcache/Python/3.13.11/x64/lib/python3.13/site-packages/mibitrans/data/parameters.py:75, in HydrologicalParameters._validate_input_presence(self)\n     72     missing_arguments.append(\"alpha_y\")\n     74 if len(missing_arguments) &gt; 0:\n---&gt; 75     raise MissingValueError(\n     76         f\"HydrologicalParameters missing {len(missing_arguments)} arguments: {missing_arguments}.\"\n     77     )\n     79 if self.velocity is None and (self.h_gradient is None or self.h_conductivity is None):\n     80     raise MissingValueError(\n     81         \"HydrologicalParameters missing required arguments: either velocity or both h_gradient and\"\n     82         \"h_conductivity.\"\n     83     )\n\nMissingValueError: HydrologicalParameters missing 3 arguments: ['porosity', 'alpha_x', 'alpha_y'].</pre> In\u00a0[10]: Copied! <pre># If the input datatype is not what is expected; source_zone_concentration expects a numpy array\n# of the same length as the array given in source_zone_boundary.\nfake_source = SourceParameters(\n    source_zone_boundary = np.array([1,2,3]),\n    source_zone_concentration = \"this is a string, not an array\",\n    depth = 10,\n    total_mass = \"inf\",\n)\n</pre> # If the input datatype is not what is expected; source_zone_concentration expects a numpy array # of the same length as the array given in source_zone_boundary. fake_source = SourceParameters(     source_zone_boundary = np.array([1,2,3]),     source_zone_concentration = \"this is a string, not an array\",     depth = 10,     total_mass = \"inf\", ) <pre>\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[10], line 3\n      1 # If the input datatype is not what is expected; source_zone_concentration expects a numpy array\n      2 # of the same length as the array given in source_zone_boundary.\n----&gt; 3 fake_source = SourceParameters(\n      4     source_zone_boundary = np.array([1,2,3]),\n      5     source_zone_concentration = \"this is a string, not an array\",\n      6     depth = 10,\n      7     total_mass = \"inf\",\n      8 )\n\nFile &lt;string&gt;:4, in __init__(self, source_zone_boundary, source_zone_concentration, depth, total_mass, verbose)\n\nFile /opt/hostedtoolcache/Python/3.13.11/x64/lib/python3.13/site-packages/mibitrans/data/parameters.py:217, in SourceParameters.__setattr__(self, parameter, value)\n    215 def __setattr__(self, parameter, value):\n    216     \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n--&gt; 217     validate_input_values(parameter, value)\n    218     if parameter == \"total_mass\" and (isinstance(value, str) or value == np.inf):\n    219         value = np.inf\n\nFile /opt/hostedtoolcache/Python/3.13.11/x64/lib/python3.13/site-packages/mibitrans/data/check_input.py:277, in validate_input_values(parameter, value)\n    274         error = _check_numeric_positive(parameter, value)\n    276 if error and (value is not None):\n--&gt; 277     raise error\n\nTypeError: source_zone_concentration must be a float, list or numpy array, but is &lt;class 'str'&gt; instead.</pre> In\u00a0[11]: Copied! <pre># Same goes for if the input parameter has a value outside its valid domain; retardation should have a value &gt;= 1\nfake_att = AttenuationParameters(\n    retardation = 0.1\n)\n</pre> # Same goes for if the input parameter has a value outside its valid domain; retardation should have a value &gt;= 1 fake_att = AttenuationParameters(     retardation = 0.1 ) <pre>\n---------------------------------------------------------------------------\nDomainValueError                          Traceback (most recent call last)\nCell In[11], line 2\n      1 # Same goes for if the input parameter has a value outside its valid domain; retardation should have a value &gt;= 1\n----&gt; 2 fake_att = AttenuationParameters(\n      3     retardation = 0.1\n      4 )\n\nFile &lt;string&gt;:3, in __init__(self, retardation, decay_rate, half_life, diffusion, bulk_density, partition_coefficient, fraction_organic_carbon, verbose)\n\nFile /opt/hostedtoolcache/Python/3.13.11/x64/lib/python3.13/site-packages/mibitrans/data/parameters.py:127, in AttenuationParameters.__setattr__(self, parameter, value)\n    125 def __setattr__(self, parameter, value):\n    126     \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n--&gt; 127     validate_input_values(parameter, value)\n    128     # Separate setattr for decay rate and half life because they should always be equivalent\n    129     if parameter == \"decay_rate\" or parameter == \"half_life\":\n\nFile /opt/hostedtoolcache/Python/3.13.11/x64/lib/python3.13/site-packages/mibitrans/data/check_input.py:277, in validate_input_values(parameter, value)\n    274         error = _check_numeric_positive(parameter, value)\n    276 if error and (value is not None):\n--&gt; 277     raise error\n\nDomainValueError: retardation must be 1 or larger.</pre> In\u00a0[12]: Copied! <pre># Initializing the model object\nmbt_object = Mibitrans(\n    hydrological_parameters=hydro,\n    attenuation_parameters=att,\n    source_parameters=source,\n    model_parameters=model\n)\n\n# Can use model object to request various attributes\nprint(\"x discretization: \", mbt_object.x)\nprint(\"Retarded flow velocity: \", mbt_object.rv)\nprint(\"x steps\", len(mbt_object.x), \"y steps\", len(mbt_object.y), \"t steps\", len(mbt_object.t))\n\n# Run the model once initialized and obtain the results\nmbt_results = mbt_object.run()\n</pre> # Initializing the model object mbt_object = Mibitrans(     hydrological_parameters=hydro,     attenuation_parameters=att,     source_parameters=source,     model_parameters=model )  # Can use model object to request various attributes print(\"x discretization: \", mbt_object.x) print(\"Retarded flow velocity: \", mbt_object.rv) print(\"x steps\", len(mbt_object.x), \"y steps\", len(mbt_object.y), \"t steps\", len(mbt_object.t))  # Run the model once initialized and obtain the results mbt_results = mbt_object.run()  <pre>/opt/hostedtoolcache/Python/3.13.11/x64/lib/python3.13/site-packages/mibitrans/transport/model_parent.py:237: UserWarning: Source zone boundary is larger than model width. Model width adjusted to fit entire source zone.\n  warnings.warn(\n</pre> <pre>x discretization:  [ 0.          0.30478513  0.60957025  0.91435538  1.21914051  1.52392563\n  1.82871076  2.13349589  2.43828101  2.74306614  3.04785126  3.35263639\n  3.65742152  3.96220664  4.26699177  4.5717769   4.87656202  5.18134715\n  5.48613228  5.7909174   6.09570253  6.40048766  6.70527278  7.01005791\n  7.31484304  7.61962816  7.92441329  8.22919842  8.53398354  8.83876867\n  9.14355379  9.44833892  9.75312405 10.05790917 10.3626943  10.66747943\n 10.97226455 11.27704968 11.58183481 11.88661993 12.19140506 12.49619019\n 12.80097531 13.10576044 13.41054557 13.71533069 14.02011582 14.32490094\n 14.62968607 14.9344712  15.23925632 15.54404145 15.84882658 16.1536117\n 16.45839683 16.76318196 17.06796708 17.37275221 17.67753734 17.98232246\n 18.28710759 18.59189272 18.89667784 19.20146297 19.5062481  19.81103322\n 20.11581835 20.42060347 20.7253886  21.03017373 21.33495885 21.63974398\n 21.94452911 22.24931423 22.55409936 22.85888449 23.16366961 23.46845474\n 23.77323987 24.07802499 24.38281012 24.68759525 24.99238037 25.2971655\n 25.60195062 25.90673575 26.21152088 26.516306   26.82109113 27.12587626\n 27.43066138 27.73544651 28.04023164 28.34501676 28.64980189 28.95458702\n 29.25937214 29.56415727 29.8689424  30.17372752 30.47851265 30.78329778\n 31.0880829  31.39286803 31.69765315 32.00243828 32.30722341 32.61200853\n 32.91679366 33.22157879 33.52636391 33.83114904 34.13593417 34.44071929\n 34.74550442 35.05028955 35.35507467 35.6598598  35.96464493 36.26943005\n 36.57421518 36.8790003  37.18378543 37.48857056 37.79335568 38.09814081\n 38.40292594 38.70771106 39.01249619 39.31728132 39.62206644 39.92685157\n 40.2316367  40.53642182 40.84120695 41.14599208 41.4507772  41.75556233\n 42.06034746 42.36513258 42.66991771 42.97470283 43.27948796 43.58427309\n 43.88905821 44.19384334 44.49862847 44.80341359 45.10819872 45.41298385\n 45.71776897 46.0225541  46.32733923 46.63212435 46.93690948 47.24169461\n 47.54647973 47.85126486 48.15604998 48.46083511 48.76562024 49.07040536\n 49.37519049 49.67997562 49.98476074 50.28954587 50.594331   50.89911612\n 51.20390125 51.50868638 51.8134715  52.11825663 52.42304176 52.72782688\n 53.03261201 53.33739714 53.64218226 53.94696739 54.25175251 54.55653764\n 54.86132277 55.16610789 55.47089302 55.77567815 56.08046327 56.3852484\n 56.69003353 56.99481865 57.29960378 57.60438891 57.90917403 58.21395916\n 58.51874429 58.82352941 59.12831454 59.43309966 59.73788479 60.04266992\n 60.34745504 60.65224017 60.9570253  61.26181042 61.56659555 61.87138068\n 62.1761658  62.48095093 62.78573606 63.09052118 63.39530631 63.70009144\n 64.00487656 64.30966169 64.61444681 64.91923194 65.22401707 65.52880219\n 65.83358732 66.13837245 66.44315757 66.7479427  67.05272783 67.35751295\n 67.66229808 67.96708321 68.27186833 68.57665346 68.88143859 69.18622371\n 69.49100884 69.79579397 70.10057909 70.40536422 70.71014934 71.01493447\n 71.3197196  71.62450472 71.92928985 72.23407498 72.5388601  72.84364523\n 73.14843036 73.45321548 73.75800061 74.06278574 74.36757086 74.67235599\n 74.97714112 75.28192624 75.58671137 75.89149649 76.19628162 76.50106675\n 76.80585187 77.110637   77.41542213 77.72020725 78.02499238 78.32977751\n 78.63456263 78.93934776 79.24413289 79.54891801 79.85370314 80.15848827\n 80.46327339 80.76805852 81.07284365 81.37762877 81.6824139  81.98719902\n 82.29198415 82.59676928 82.9015544  83.20633953 83.51112466 83.81590978\n 84.12069491 84.42548004 84.73026516 85.03505029 85.33983542 85.64462054\n 85.94940567 86.2541908  86.55897592 86.86376105 87.16854617 87.4733313\n 87.77811643 88.08290155 88.38768668 88.69247181 88.99725693 89.30204206\n 89.60682719 89.91161231 90.21639744 90.52118257 90.82596769 91.13075282\n 91.43553795 91.74032307 92.0451082  92.34989333 92.65467845 92.95946358\n 93.2642487  93.56903383 93.87381896 94.17860408 94.48338921 94.78817434\n 95.09295946 95.39774459 95.70252972 96.00731484 96.31209997 96.6168851\n 96.92167022 97.22645535 97.53124048 97.8360256 ]\nRetarded flow velocity:  0.09366049332590146\nx steps 322 y steps 132 t steps 30\n</pre> In\u00a0[13]: Copied! <pre>?Mibitrans\n</pre> ?Mibitrans In\u00a0[14]: Copied! <pre># Once the model has run, results are contained in the cxyt attribute\nmodel_cxyt = mbt_object.cxyt\n\n# cxyt is indexed as [time, y-position, x-position]\n# Thus to get the concentration at the last time step, in the center of the plume for all x:\nplume_center = model_cxyt[-1, 132//2, :]\n\n# mibitrans has build-in visualization methods (see visualization section for more details).\nmbt_results.centerline()\nplt.show()\n</pre> # Once the model has run, results are contained in the cxyt attribute model_cxyt = mbt_object.cxyt  # cxyt is indexed as [time, y-position, x-position] # Thus to get the concentration at the last time step, in the center of the plume for all x: plume_center = model_cxyt[-1, 132//2, :]  # mibitrans has build-in visualization methods (see visualization section for more details). mbt_results.centerline() plt.show() <p>To perform the model with biodegradation modelled as an instant reaction, use the instant_reaction class method. Input for the instant reaction model is somewhat more involved, needing electron donor and acceptor concentrations. For utilization factors (amount of electron donor/acceptor used/generated by biodegradation), the values for BTEX degradation are used by default, but custom values can be given. For more specifics about the underlying principles and assumptions, see the theory.</p> In\u00a0[15]: Copied! <pre># For streamlined input, use the ElectronAcceptor dataclass;\nea = ElectronAcceptors(\n    # Difference between background oxygen and current oxygen concentration in groundwater, in [g/m^3]\n    delta_oxygen=1.65,\n    # Difference between background nitrate and current nitrate concentration in groundwater, in [g/m^3]\n    delta_nitrate=0.7,\n    # Current ferrous iron concentration in groundwater, in [g/m^3]\n    ferrous_iron=16.6,\n    # Difference between background sulfate and current sulfate concentration in groundwater, in [g/m^3]\n    delta_sulfate=22.4,\n    # Current methane concentration in groundwater, in [g/m^3]\n    methane=6.6\n)\n\nmbt_object.instant_reaction(electron_acceptors=ea)\n\n# Can adapt utilization factors if needed\nuf = UtilizationFactor(\n    # utilization factor of oxygen, as mass of oxygen consumed per mass of biodegraded contaminant [g/g].\n    util_oxygen=2,\n    # utilization factor of nitrate, as mass of nitrate consumed per mass of biodegraded contaminant [g/g].\n    util_nitrate=1,\n    # utilization factor of ferrous iron, as mass of ferrous iron generated per mass of biodegraded contaminant [g/g].\n    util_ferrous_iron=4,\n    # utilization factor of sulfate, as mass of sulfate consumed per mass of biodegraded contaminant [g/g].\n    util_sulfate=3,\n    # utilization factor of methane, as mass of methane generated per mass of biodegraded contaminant [g/g].\n    util_methane=5,\n)\n\nmbt_object.instant_reaction(electron_acceptors=ea, utilization_factor=uf)\n\n# Alternatively, electron acceptors and/or utilization factors can be entered as a dictionary\nmbt_object.instant_reaction(\n    electron_acceptors={\n        # Difference between background oxygen and current oxygen concentration in groundwater, in [g/m^3]\n        \"delta_oxygen\":1.65,\n        # Difference between background nitrate and current nitrate concentration in groundwater, in [g/m^3]\n        \"delta_nitrate\":0.7,\n        # Current ferrous iron concentration in groundwater, in [g/m^3]\n        \"ferrous_iron\":16.6,\n        # Difference between background sulfate and current sulfate concentration in groundwater, in [g/m^3]\n        \"delta_sulfate\":22.4,\n        # Current methane concentration in groundwater, in [g/m^3]\n        \"methane\":6.6,\n    }\n)\nprint(mbt_object.biodegradation_capacity)\n# Note that using instant_reaction also resets the utilization factor to default.\nprint(\"electron acceptor concentrations: \", mbt_object.electron_acceptors)\nprint(\"electron acceptor utilization factors: \", mbt_object.utilization_factor)\n</pre> # For streamlined input, use the ElectronAcceptor dataclass; ea = ElectronAcceptors(     # Difference between background oxygen and current oxygen concentration in groundwater, in [g/m^3]     delta_oxygen=1.65,     # Difference between background nitrate and current nitrate concentration in groundwater, in [g/m^3]     delta_nitrate=0.7,     # Current ferrous iron concentration in groundwater, in [g/m^3]     ferrous_iron=16.6,     # Difference between background sulfate and current sulfate concentration in groundwater, in [g/m^3]     delta_sulfate=22.4,     # Current methane concentration in groundwater, in [g/m^3]     methane=6.6 )  mbt_object.instant_reaction(electron_acceptors=ea)  # Can adapt utilization factors if needed uf = UtilizationFactor(     # utilization factor of oxygen, as mass of oxygen consumed per mass of biodegraded contaminant [g/g].     util_oxygen=2,     # utilization factor of nitrate, as mass of nitrate consumed per mass of biodegraded contaminant [g/g].     util_nitrate=1,     # utilization factor of ferrous iron, as mass of ferrous iron generated per mass of biodegraded contaminant [g/g].     util_ferrous_iron=4,     # utilization factor of sulfate, as mass of sulfate consumed per mass of biodegraded contaminant [g/g].     util_sulfate=3,     # utilization factor of methane, as mass of methane generated per mass of biodegraded contaminant [g/g].     util_methane=5, )  mbt_object.instant_reaction(electron_acceptors=ea, utilization_factor=uf)  # Alternatively, electron acceptors and/or utilization factors can be entered as a dictionary mbt_object.instant_reaction(     electron_acceptors={         # Difference between background oxygen and current oxygen concentration in groundwater, in [g/m^3]         \"delta_oxygen\":1.65,         # Difference between background nitrate and current nitrate concentration in groundwater, in [g/m^3]         \"delta_nitrate\":0.7,         # Current ferrous iron concentration in groundwater, in [g/m^3]         \"ferrous_iron\":16.6,         # Difference between background sulfate and current sulfate concentration in groundwater, in [g/m^3]         \"delta_sulfate\":22.4,         # Current methane concentration in groundwater, in [g/m^3]         \"methane\":6.6,     } ) print(mbt_object.biodegradation_capacity) # Note that using instant_reaction also resets the utilization factor to default. print(\"electron acceptor concentrations: \", mbt_object.electron_acceptors) print(\"electron acceptor utilization factors: \", mbt_object.utilization_factor) <pre>14.657298648118742\nelectron acceptor concentrations:  {'delta_oxygen': 1.65, 'delta_nitrate': 0.7, 'ferrous_iron': 16.6, 'delta_sulfate': 22.4, 'methane': 6.6}\nelectron acceptor utilization factors:  {'util_oxygen': 3.14, 'util_nitrate': 4.9, 'util_ferrous_iron': 21.8, 'util_sulfate': 4.7, 'util_methane': 0.78}\n</pre> <p>Be aware that electron acceptor concentrations and utilization factors can only be changed using the instant_reaction method. Changing the properties directly will not work.</p> <p>Now that instant reaction parameters are provided, the model can be run:</p> In\u00a0[16]: Copied! <pre>mbt_instant_results = mbt_object.run()\n\nmbt_instant_results.centerline()\nplt.show()\n\n# Switch between instant reaction and linear model\nmbt_object.mode = \"linear\"\nprint(\"The current model mode is: \", mbt_object.mode)\n# Running now will show the results of the linear model\n# Switch back to instant reaction as follows:\nmbt_object.mode = \"instant_reaction\"\nprint(\"The current model mode is: \", mbt_object.mode)\n</pre> mbt_instant_results = mbt_object.run()  mbt_instant_results.centerline() plt.show()  # Switch between instant reaction and linear model mbt_object.mode = \"linear\" print(\"The current model mode is: \", mbt_object.mode) # Running now will show the results of the linear model # Switch back to instant reaction as follows: mbt_object.mode = \"instant_reaction\" print(\"The current model mode is: \", mbt_object.mode) <pre>The current model mode is:  linear\nThe current model mode is:  instant_reaction\n</pre> <p>Use the sample method to get the concentration at a specific location and time.</p> In\u00a0[17]: Copied! <pre># Instead, sample a specific location at any point along the plume and any point in time\nconcentration = mbt_object.sample(\n    x_position=100,\n    y_position=0,\n    time=10*365)\nprint(\"The concentration at 150m downstream from the source after 10 years is:\", concentration, r\"g/m^3\")\n</pre> # Instead, sample a specific location at any point along the plume and any point in time concentration = mbt_object.sample(     x_position=100,     y_position=0,     time=10*365) print(\"The concentration at 150m downstream from the source after 10 years is:\", concentration, r\"g/m^3\") <pre>The concentration at 150m downstream from the source after 10 years is: 4.261015138234987 g/m^3\n</pre> In\u00a0[18]: Copied! <pre># Using the verbose flag, integration steps are printed to console.\n# Usefull for longer runs to track progress\nmbt_object = Mibitrans(\n    hydrological_parameters=hydro,\n    attenuation_parameters=att,\n    source_parameters=source,\n    model_parameters=model,\n    verbose=True\n)\nmbt_results = mbt_object.run()\n</pre> # Using the verbose flag, integration steps are printed to console. # Usefull for longer runs to track progress mbt_object = Mibitrans(     hydrological_parameters=hydro,     attenuation_parameters=att,     source_parameters=source,     model_parameters=model,     verbose=True ) mbt_results = mbt_object.run() <pre>integrating for source zone  0  and t = 73.0 days\nintegrating for source zone  0  and t = 146.0 days\n</pre> <pre>integrating for source zone  0  and t = 219.0 days\n</pre> <pre>integrating for source zone  0  and t = 292.0 days\nintegrating for source zone  0  and t = 365.0 days\nintegrating for source zone  0  and t = 438.0 days\nintegrating for source zone  0  and t = 511.0 days\nintegrating for source zone  0  and t = 584.0 days\nintegrating for source zone  0  and t = 657.0 days\nintegrating for source zone  0  and t = 730.0 days\nintegrating for source zone  0  and t = 803.0 days\nintegrating for source zone  0  and t = 876.0 days\nintegrating for source zone  0  and t = 949.0 days\n</pre> <pre>integrating for source zone  0  and t = 1022.0 days\n</pre> <pre>integrating for source zone  0  and t = 1095.0 days\nintegrating for source zone  0  and t = 1168.0 days\nintegrating for source zone  0  and t = 1241.0 days\nintegrating for source zone  0  and t = 1314.0 days\nintegrating for source zone  0  and t = 1387.0 days\nintegrating for source zone  0  and t = 1460.0 days\nintegrating for source zone  0  and t = 1533.0 days\nintegrating for source zone  0  and t = 1606.0 days\nintegrating for source zone  0  and t = 1679.0 days\nintegrating for source zone  0  and t = 1752.0 days\n</pre> <pre>integrating for source zone  0  and t = 1825.0 days\n</pre> <pre>integrating for source zone  0  and t = 1898.0 days\nintegrating for source zone  0  and t = 1971.0 days\nintegrating for source zone  0  and t = 2044.0 days\nintegrating for source zone  0  and t = 2117.0 days\nintegrating for source zone  0  and t = 2190.0 days\nintegrating for source zone  1  and t = 73.0 days\n</pre> <pre>integrating for source zone  1  and t = 146.0 days\nintegrating for source zone  1  and t = 219.0 days\nintegrating for source zone  1  and t = 292.0 days\nintegrating for source zone  1  and t = 365.0 days\nintegrating for source zone  1  and t = 438.0 days\nintegrating for source zone  1  and t = 511.0 days\nintegrating for source zone  1  and t = 584.0 days\nintegrating for source zone  1  and t = 657.0 days\nintegrating for source zone  1  and t = 730.0 days\nintegrating for source zone  1  and t = 803.0 days\nintegrating for source zone  1  and t = 876.0 days\n</pre> <pre>integrating for source zone  1  and t = 949.0 days\nintegrating for source zone  1  and t = 1022.0 days\nintegrating for source zone  1  and t = 1095.0 days\nintegrating for source zone  1  and t = 1168.0 days\nintegrating for source zone  1  and t = 1241.0 days\nintegrating for source zone  1  and t = 1314.0 days\nintegrating for source zone  1  and t = 1387.0 days\nintegrating for source zone  1  and t = 1460.0 days\nintegrating for source zone  1  and t = 1533.0 days\nintegrating for source zone  1  and t = 1606.0 days\nintegrating for source zone  1  and t = 1679.0 days\n</pre> <pre>integrating for source zone  1  and t = 1752.0 days\nintegrating for source zone  1  and t = 1825.0 days\nintegrating for source zone  1  and t = 1898.0 days\nintegrating for source zone  1  and t = 1971.0 days\nintegrating for source zone  1  and t = 2044.0 days\nintegrating for source zone  1  and t = 2117.0 days\nintegrating for source zone  1  and t = 2190.0 days\nintegrating for source zone  2  and t = 73.0 days\n</pre> <pre>integrating for source zone  2  and t = 146.0 days\nintegrating for source zone  2  and t = 219.0 days\nintegrating for source zone  2  and t = 292.0 days\nintegrating for source zone  2  and t = 365.0 days\nintegrating for source zone  2  and t = 438.0 days\nintegrating for source zone  2  and t = 511.0 days\nintegrating for source zone  2  and t = 584.0 days\nintegrating for source zone  2  and t = 657.0 days\nintegrating for source zone  2  and t = 730.0 days\nintegrating for source zone  2  and t = 803.0 days\nintegrating for source zone  2  and t = 876.0 days\n</pre> <pre>integrating for source zone  2  and t = 949.0 days\nintegrating for source zone  2  and t = 1022.0 days\nintegrating for source zone  2  and t = 1095.0 days\nintegrating for source zone  2  and t = 1168.0 days\nintegrating for source zone  2  and t = 1241.0 days\nintegrating for source zone  2  and t = 1314.0 days\nintegrating for source zone  2  and t = 1387.0 days\nintegrating for source zone  2  and t = 1460.0 days\nintegrating for source zone  2  and t = 1533.0 days\nintegrating for source zone  2  and t = 1606.0 days\nintegrating for source zone  2  and t = 1679.0 days\n</pre> <pre>integrating for source zone  2  and t = 1752.0 days\nintegrating for source zone  2  and t = 1825.0 days\nintegrating for source zone  2  and t = 1898.0 days\nintegrating for source zone  2  and t = 1971.0 days\nintegrating for source zone  2  and t = 2044.0 days\nintegrating for source zone  2  and t = 2117.0 days\nintegrating for source zone  2  and t = 2190.0 days\n</pre> In\u00a0[19]: Copied! <pre>ana_object = Anatrans(\n    hydrological_parameters=hydro,\n    attenuation_parameters=att,\n    source_parameters=source,\n    model_parameters=model\n)\n\nana_results = ana_object.run()\nana_results.centerline()\nplt.show()\n</pre> ana_object = Anatrans(     hydrological_parameters=hydro,     attenuation_parameters=att,     source_parameters=source,     model_parameters=model )  ana_results = ana_object.run() ana_results.centerline() plt.show() In\u00a0[20]: Copied! <pre>bio_object = Bioscreen(\n    hydrological_parameters=hydro,\n    attenuation_parameters=att,\n    source_parameters=source,\n    model_parameters=model\n)\nbio_results = bio_object.run()\nbio_results.centerline()\nplt.show()\n</pre> bio_object = Bioscreen(     hydrological_parameters=hydro,     attenuation_parameters=att,     source_parameters=source,     model_parameters=model ) bio_results = bio_object.run() bio_results.centerline() plt.show() <p>The model class check if they receive all required and the correct input dataclasses, ensuring model calculations will be performed without error.</p> In\u00a0[21]: Copied! <pre># Will not work; hydrological_parameters should be a HydrologicalParameters class object.\nfake_mbt = Mibitrans(\n    hydrological_parameters=model,\n    attenuation_parameters=att,\n    source_parameters=source,\n    model_parameters=model\n)\n</pre> # Will not work; hydrological_parameters should be a HydrologicalParameters class object. fake_mbt = Mibitrans(     hydrological_parameters=model,     attenuation_parameters=att,     source_parameters=source,     model_parameters=model ) <pre>\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[21], line 2\n      1 # Will not work; hydrological_parameters should be a HydrologicalParameters class object.\n----&gt; 2 fake_mbt = Mibitrans(\n      3     hydrological_parameters=model,\n      4     attenuation_parameters=att,\n      5     source_parameters=source,\n      6     model_parameters=model\n      7 )\n\nFile /opt/hostedtoolcache/Python/3.13.11/x64/lib/python3.13/site-packages/mibitrans/transport/models.py:91, in Mibitrans.__init__(self, hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose)\n     34 def __init__(\n     35     self,\n     36     hydrological_parameters,\n   (...)     40     verbose=False,\n     41 ):\n     42     \"\"\"Initialize model object.\n     43 \n     44     Args:\n   (...)     89 \n     90     \"\"\"\n---&gt; 91     super().__init__(hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose)\n\nFile /opt/hostedtoolcache/Python/3.13.11/x64/lib/python3.13/site-packages/mibitrans/transport/model_parent.py:39, in Transport3D.__init__(self, hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose)\n     37 for key, value in locals().items():\n     38     if key not in [\"self\", \"verbose\"]:\n---&gt; 39         self._check_input_dataclasses(key, value)\n     41 self._hyd_pars = copy.copy(hydrological_parameters)\n     42 self._att_pars = copy.copy(attenuation_parameters)\n\nFile /opt/hostedtoolcache/Python/3.13.11/x64/lib/python3.13/site-packages/mibitrans/transport/model_parent.py:223, in Transport3D._check_input_dataclasses(self, key, value)\n    215 dataclass_dict = {\n    216     \"hydrological_parameters\": mibitrans.data.parameters.HydrologicalParameters,\n    217     \"attenuation_parameters\": mibitrans.data.parameters.AttenuationParameters,\n    218     \"source_parameters\": mibitrans.data.parameters.SourceParameters,\n    219     \"model_parameters\": mibitrans.data.parameters.ModelParameters,\n    220 }\n    222 if not isinstance(value, dataclass_dict[key]):\n--&gt; 223     raise TypeError(f\"Input argument {key} should be {dataclass_dict[key]}, but is {type(value)} instead.\")\n\nTypeError: Input argument hydrological_parameters should be &lt;class 'mibitrans.data.parameters.HydrologicalParameters'&gt;, but is &lt;class 'mibitrans.data.parameters.ModelParameters'&gt; instead.</pre> In\u00a0[22]: Copied! <pre># Lets make some different model objects to use in the plotting, takes a couple of seconds to run\n\n#Mibitrans model\nmbt_object = Mibitrans(hydro, att, source, model)\nmbt_lineardecay = mbt_object.run()\n\nmbt_object.attenuation_parameters.decay_rate = 0\nmbt_nodecay = mbt_object.run()\n\nmbt_object.instant_reaction(electron_acceptors=ea)\nmbt_instant = mbt_object.run()\n\n#Anatrans model\nana_object = Anatrans(hydro, att, source, model)\nana_lineardecay = ana_object.run()\n\nana_object.attenuation_parameters.decay_rate = 0\nana_nodecay = ana_object.run()\n\nana_object.instant_reaction(electron_acceptors=ea)\nana_instant =  ana_object.run()\n\n#Bioscreen model\nbio_object = Bioscreen(hydro, att, source, model)\nbio_lineardecay = bio_object.run()\n\nbio_object.attenuation_parameters.decay_rate = 0\nbio_nodecay = bio_object.run()\n\nbio_object.instant_reaction(electron_acceptors=ea)\nbio_instant = bio_object.run()\n</pre> # Lets make some different model objects to use in the plotting, takes a couple of seconds to run  #Mibitrans model mbt_object = Mibitrans(hydro, att, source, model) mbt_lineardecay = mbt_object.run()  mbt_object.attenuation_parameters.decay_rate = 0 mbt_nodecay = mbt_object.run()  mbt_object.instant_reaction(electron_acceptors=ea) mbt_instant = mbt_object.run()  #Anatrans model ana_object = Anatrans(hydro, att, source, model) ana_lineardecay = ana_object.run()  ana_object.attenuation_parameters.decay_rate = 0 ana_nodecay = ana_object.run()  ana_object.instant_reaction(electron_acceptors=ea) ana_instant =  ana_object.run()  #Bioscreen model bio_object = Bioscreen(hydro, att, source, model) bio_lineardecay = bio_object.run()  bio_object.attenuation_parameters.decay_rate = 0 bio_nodecay = bio_object.run()  bio_object.instant_reaction(electron_acceptors=ea) bio_instant = bio_object.run()   In\u00a0[23]: Copied! <pre># Pass model object to plotting function, by default, the last time step is used.\ncenterline(mbt_nodecay)\nplt.show()\n\n# If you want to plot somewhere and sometime specific, use the time and y_position arguments.\n# It gives the concentration profile at the step closest to what you specified.\ncenterline(mbt_nodecay, time=3*365, y_position=5)\n#plt.title(\"No degradation Domenico model 5m away from center, t=6years\")\nplt.show()\n\n# If you want you can change the plot settings to the ones you prefer\ncenterline(mbt_nodecay, time=6*365)\nplt.title(\"Better title than the one generated automatically\")\nplt.xlabel(\"I have changed!\")\nplt.ylabel(\"And so have I\")\nplt.show()\n\nlegend = [\"no degradation\", \"linear decay\", \"instant reaction\"]\n\n# Instead of a single model, all line visualization functions accept a list of models to be displayed\n# together in a single plot.\ncenterline([mbt_nodecay, mbt_lineardecay, mbt_instant], time=6*365, legend_names=legend)\nplt.title(\"Mibitrans model at plume center for different models, t=6years\")\nplt.show()\n\n# Keyword arguments for plt.plot can be passed on through the function\n# Calling function separately per model gives more control over plot layout\ncenterline(mbt_nodecay, time=6*365, linestyle=\"--\", color=\"green\", label=legend[0])\ncenterline(mbt_lineardecay, time=6*365, linestyle=\"-.\", color=\"red\", label=legend[1])\nplt.title(\"No and linear degradation Mibitrans model at plume center, t=6years\")\nplt.legend()\nplt.show()\n\n# Alternatively, use the inherent plotting modules of the model objects\nmbt_nodecay.centerline(time = 365, linestyle=\"--\", color=\"green\", label=\"Mibitrans\")\nana_nodecay.centerline(time = 365, linestyle=\"-.\", color=\"blue\", label=\"Anatrans\")\nbio_nodecay.centerline(time = 365, linestyle=\":\", color=\"red\", label=\"Bioscreen\")\nplt.title(\"Concentration distribution for different contaminant transport models after 1 year.\")\nplt.legend()\nplt.show()\n</pre> # Pass model object to plotting function, by default, the last time step is used. centerline(mbt_nodecay) plt.show()  # If you want to plot somewhere and sometime specific, use the time and y_position arguments. # It gives the concentration profile at the step closest to what you specified. centerline(mbt_nodecay, time=3*365, y_position=5) #plt.title(\"No degradation Domenico model 5m away from center, t=6years\") plt.show()  # If you want you can change the plot settings to the ones you prefer centerline(mbt_nodecay, time=6*365) plt.title(\"Better title than the one generated automatically\") plt.xlabel(\"I have changed!\") plt.ylabel(\"And so have I\") plt.show()  legend = [\"no degradation\", \"linear decay\", \"instant reaction\"]  # Instead of a single model, all line visualization functions accept a list of models to be displayed # together in a single plot. centerline([mbt_nodecay, mbt_lineardecay, mbt_instant], time=6*365, legend_names=legend) plt.title(\"Mibitrans model at plume center for different models, t=6years\") plt.show()  # Keyword arguments for plt.plot can be passed on through the function # Calling function separately per model gives more control over plot layout centerline(mbt_nodecay, time=6*365, linestyle=\"--\", color=\"green\", label=legend[0]) centerline(mbt_lineardecay, time=6*365, linestyle=\"-.\", color=\"red\", label=legend[1]) plt.title(\"No and linear degradation Mibitrans model at plume center, t=6years\") plt.legend() plt.show()  # Alternatively, use the inherent plotting modules of the model objects mbt_nodecay.centerline(time = 365, linestyle=\"--\", color=\"green\", label=\"Mibitrans\") ana_nodecay.centerline(time = 365, linestyle=\"-.\", color=\"blue\", label=\"Anatrans\") bio_nodecay.centerline(time = 365, linestyle=\":\", color=\"red\", label=\"Bioscreen\") plt.title(\"Concentration distribution for different contaminant transport models after 1 year.\") plt.legend() plt.show()  In\u00a0[24]: Copied! <pre># Concentration distribution can also be plotted in the transverse direction\ntransverse(ana_nodecay, x_position=80, time=6*365, linestyle=\"--\", color=\"green\", label=\"no degradation\")\ntransverse(ana_instant, x_position=80, time=6*365, linestyle=\"-.\", color=\"red\", label=\"instant reaction\")\n\nplt.title(\"No degradation and instant reaction Domenico model at x=80m, t=6years\")\nplt.legend()\nplt.show()\n\n# Or using the class methods\nana_lineardecay.transverse(x_position=80, time=6*365)\nplt.show()\n</pre> # Concentration distribution can also be plotted in the transverse direction transverse(ana_nodecay, x_position=80, time=6*365, linestyle=\"--\", color=\"green\", label=\"no degradation\") transverse(ana_instant, x_position=80, time=6*365, linestyle=\"-.\", color=\"red\", label=\"instant reaction\")  plt.title(\"No degradation and instant reaction Domenico model at x=80m, t=6years\") plt.legend() plt.show()  # Or using the class methods ana_lineardecay.transverse(x_position=80, time=6*365) plt.show() In\u00a0[25]: Copied! <pre># Concentration distribution can also be plotted in the transverse direction\nbreakthrough([bio_nodecay, bio_lineardecay, bio_instant], x_position=80,\n             legend_names=[\"no degradation\", \"linear decay\", \"instant reaction\"])\nplt.title(\"Breakthrough curve of Bioscreen model for different degradation settings, at x=80m, t=6years\")\nplt.show()\n</pre> # Concentration distribution can also be plotted in the transverse direction breakthrough([bio_nodecay, bio_lineardecay, bio_instant], x_position=80,              legend_names=[\"no degradation\", \"linear decay\", \"instant reaction\"]) plt.title(\"Breakthrough curve of Bioscreen model for different degradation settings, at x=80m, t=6years\") plt.show()  In\u00a0[26]: Copied! <pre># Plot the x and y concentration distribution for the Mibitrans model, uses plt.pcolormesh\nplume_2d(mbt_nodecay, time=6*365)\nplt.title(\"Contaminant plume with no degradation Mibitrans model, t = 6 years\")\nplt.show()\n\n# Function passes plt.colormesh keyword arguments\nplume_2d(mbt_lineardecay, time=6*365, cmap=\"magma\")\nplt.title(\"Contaminant plume with linear degradation Domenico model, t = 6 years\")\nplt.show()\n\n# Once again also can be accessed through the class method\nmbt_instant.plume_2d(time=4*365, cmap=\"plasma\")\nplt.show()\n</pre> # Plot the x and y concentration distribution for the Mibitrans model, uses plt.pcolormesh plume_2d(mbt_nodecay, time=6*365) plt.title(\"Contaminant plume with no degradation Mibitrans model, t = 6 years\") plt.show()  # Function passes plt.colormesh keyword arguments plume_2d(mbt_lineardecay, time=6*365, cmap=\"magma\") plt.title(\"Contaminant plume with linear degradation Domenico model, t = 6 years\") plt.show()  # Once again also can be accessed through the class method mbt_instant.plume_2d(time=4*365, cmap=\"plasma\") plt.show() In\u00a0[27]: Copied! <pre># Plot the x and y concentration distribution for no degradation decay model, uses plot_surface\nplume_3d(ana_nodecay, time=6*365)\nplt.title(\"Contaminant plume with no degradation Anatrans model, t = 6 years\")\nplt.show()\n\n# Function passes plot_surface keyword arguments\nplume_3d(ana_lineardecay, time=6*365, cmap=\"viridis\")\nplt.title(\"Contaminant plume with linear degradation Anatrans model, t = 6 years\")\nplt.show()\n\n# Function returns 'ax' object, use this to change view point of plot\n# And can be accessed through class methods\nax = ana_instant.plume_3d(time=6*365, cmap=\"viridis\")\nplt.title(\"Contaminant plume with linear degradation Anatrans model, t = 6 years\")\nax.view_init(elev=15, azim=340)\nplt.show()\n</pre> # Plot the x and y concentration distribution for no degradation decay model, uses plot_surface plume_3d(ana_nodecay, time=6*365) plt.title(\"Contaminant plume with no degradation Anatrans model, t = 6 years\") plt.show()  # Function passes plot_surface keyword arguments plume_3d(ana_lineardecay, time=6*365, cmap=\"viridis\") plt.title(\"Contaminant plume with linear degradation Anatrans model, t = 6 years\") plt.show()  # Function returns 'ax' object, use this to change view point of plot # And can be accessed through class methods ax = ana_instant.plume_3d(time=6*365, cmap=\"viridis\") plt.title(\"Contaminant plume with linear degradation Anatrans model, t = 6 years\") ax.view_init(elev=15, azim=340) plt.show() In\u00a0[28]: Copied! <pre># Needed to show animations in Jupyter Notebooks\n%matplotlib notebook\n</pre> # Needed to show animations in Jupyter Notebooks %matplotlib notebook In\u00a0[29]: Copied! <pre># Output needs to be assigned to variable for animation to work\nani = centerline([mbt_nodecay, mbt_lineardecay, mbt_instant], time=6*365, legend_names=legend, animate=True)\nplt.show()\n\n# Animation of breakthrough curve instead shows a timelapse of drawing of each curve\nani1 = breakthrough([bio_nodecay, bio_lineardecay, bio_instant], x_position=20, legend_names=legend, animate=True)\nplt.show()\n\n# For the 3d surface plot, an entirely new plot needs to be generated per time step\n# This can cause slightly longer execution times\nani2 = ana_instant.plume_3d(time=6*365, animate=True, cmap=\"viridis\")\nplt.show()\n</pre> # Output needs to be assigned to variable for animation to work ani = centerline([mbt_nodecay, mbt_lineardecay, mbt_instant], time=6*365, legend_names=legend, animate=True) plt.show()  # Animation of breakthrough curve instead shows a timelapse of drawing of each curve ani1 = breakthrough([bio_nodecay, bio_lineardecay, bio_instant], x_position=20, legend_names=legend, animate=True) plt.show()  # For the 3d surface plot, an entirely new plot needs to be generated per time step # This can cause slightly longer execution times ani2 = ana_instant.plume_3d(time=6*365, animate=True, cmap=\"viridis\") plt.show() In\u00a0[30]: Copied! <pre># Save animation as .gif (or other desired file format), this may take a while\n# Adjust animation speed with optional fps argument\nani2.save(\"plume_animation.gif\", fps=10)\n</pre> # Save animation as .gif (or other desired file format), this may take a while # Adjust animation speed with optional fps argument ani2.save(\"plume_animation.gif\", fps=10) <pre>MovieWriter ffmpeg unavailable; using Pillow instead.\n</pre> In\u00a0[31]: Copied! <pre># Set up a mass balance object of the Mibitrans instant reaction model.\nmb = mbt_instant.mass_balance()\n</pre> # Set up a mass balance object of the Mibitrans instant reaction model. mb = mbt_instant.mass_balance() <pre>/opt/hostedtoolcache/Python/3.13.11/x64/lib/python3.13/site-packages/mibitrans/analysis/mass_balance.py:195: UserWarning: Contaminant plume extents beyond the model length, with a maximum concentration at the boundary of 3.2g/m3. To ensure reliable mass balance, re-run the model with increased dimensions to include the entire plume length in the model extent.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.13.11/x64/lib/python3.13/site-packages/mibitrans/transport/model_parent.py:237: UserWarning: Source zone boundary is larger than model width. Model width adjusted to fit entire source zone.\n  warnings.warn(\n</pre> <p>As the warning shows, part of the plume extents beyond the model boundary, which makes the mass balance inaccurate. Increasing model length will remediate this.</p> In\u00a0[32]: Copied! <pre>mbt_object.model_parameters.model_length = 500 / ft\nresults = mbt_object.run()\nmb = results.mass_balance()\n</pre> mbt_object.model_parameters.model_length = 500 / ft results = mbt_object.run() mb = results.mass_balance() <pre>/opt/hostedtoolcache/Python/3.13.11/x64/lib/python3.13/site-packages/mibitrans/analysis/mass_balance.py:195: UserWarning: Contaminant plume extents beyond the model length, with a maximum concentration at the boundary of 0.9g/m3. To ensure reliable mass balance, re-run the model with increased dimensions to include the entire plume length in the model extent.\n  warnings.warn(\n</pre> <p>The entire plume is now inside the model extent.</p> In\u00a0[33]: Copied! <pre>results.centerline()\nplt.show()\nresults.transverse(20, label=\"x = 20m\")\nresults.transverse(60, label=\"x = 60m\")\nresults.transverse(100, label=\"x = 100m\")\nresults.transverse(140, label=\"x = 140m\")\nplt.legend()\nplt.title(\"Transverse plot of Mibitrans instant reaction model, at t=6 years\")\nplt.show()\n</pre> results.centerline() plt.show() results.transverse(20, label=\"x = 20m\") results.transverse(60, label=\"x = 60m\") results.transverse(100, label=\"x = 100m\") results.transverse(140, label=\"x = 140m\") plt.legend() plt.title(\"Transverse plot of Mibitrans instant reaction model, at t=6 years\") plt.show() In\u00a0[34]: Copied! <pre># By default, mass balance gives results for each model time step\nprint(mb.plume_mass)\n# And then can easily be plotted over time\nplt.plot(mb.t, mb.plume_mass)\nplt.xlabel(\"time (days)\")\nplt.ylabel(\"plume mass (g)\")\nplt.show()\nplt.plot(mb.t, mb.degraded_mass)\nplt.xlabel(\"time (days)\")\nplt.ylabel(\"degraded mass (g)\")\nplt.title(\"Degraded plume mass of instant reaction model, compared to no decay.\")\nplt.show()\n</pre> # By default, mass balance gives results for each model time step print(mb.plume_mass) # And then can easily be plotted over time plt.plot(mb.t, mb.plume_mass) plt.xlabel(\"time (days)\") plt.ylabel(\"plume mass (g)\") plt.show() plt.plot(mb.t, mb.degraded_mass) plt.xlabel(\"time (days)\") plt.ylabel(\"degraded mass (g)\") plt.title(\"Degraded plume mass of instant reaction model, compared to no decay.\") plt.show() <pre>[ 258.71706681  506.5402371   775.39543323 1059.75164631 1353.21675819\n 1650.34136546 1946.64679726 2238.64679421 2523.66824431 2799.71780708\n 3065.33749787 3319.4941715  3561.46457474 3790.78842334 4007.11320344\n 4210.28396205 4400.24769962 4577.06683319 4740.85515777 4891.722321\n 5029.87559771 5155.54929278 5269.02953986 5370.62769479 5460.58769644\n 5539.22893383 5606.90333533 5663.94841771 5705.4187715  5724.72596656]\n</pre>"},{"location":"examples/example_walkthrough/#input-by-dataclasses","title":"Input by dataclasses\u00b6","text":"<p>mibitrans use dataclasses located in mibitrans.data.read to handle data input. This can be There are five input dataclasses, each for a different category of parameters. To avoid any mistakes, units of input parameters should be the ones specified. When using different units, make sure that they are consistent throughout the entire modelling process.</p>"},{"location":"examples/example_walkthrough/#hydrological-parameters","title":"Hydrological parameters\u00b6","text":"<p>Contains parameters that are inherent to the aquifer properties; flow velocity, porosity and dispersivity. Flow velocity can alternatively be calculated from the hydraulic conductivity and hydraulic gradient.</p>"},{"location":"examples/example_walkthrough/#attenuation-parameters","title":"Attenuation parameters\u00b6","text":"<p>Handles all parameters related to adsorption, diffusion and degradation.</p>"},{"location":"examples/example_walkthrough/#attenuation-retardation-and-diffusion","title":"Attenuation: retardation and diffusion\u00b6","text":"<p>Retardation can be simply given as a value &gt;= 1. Alternatively, the adsorption is calculated from the soil bulk density, paratition coefficient and the fraction of organic carbon in the soil. Note that calculation of retardation factor requires porosity as well, which is already provided in HydrologicalParameters. The calculation of retardation will therefore be automatically performed in the analytical equation. It can be manually calculated using the calculate_retardation method as well.</p> <p>Here, molecular diffusion can be given as well. It is 0 by default.</p>"},{"location":"examples/example_walkthrough/#attenuation-degradation-parameters","title":"Attenuation: degradation parameters\u00b6","text":"<p>Linear decay models only need either the contaminant decay rate or half life. Input for the instant reaction model is somewhat more involved, and is therefore done with a class method of the model classes.</p>"},{"location":"examples/example_walkthrough/#source-parameters","title":"Source parameters\u00b6","text":"<p>Takes input of the dimensions of and concentrations at the contaminant source. The source is treated as a seperate phase, which dissolves into the groundwater over time. The source is assumed to be in symmetrical in its center, and concentrations decrease from the center to the fringes. Furthermore, the source is assumed to be constant over its depth. The transverse horizontal dimension (or width) of the source is divided into zones, which span a certain distance measured from the center of the source, each with an associated concentration. For example, a source can have a concentration of $10g/m^3$ $7m$ left and right from the source center, and a concentration of $5g/m^3$ up to $20m$ from the source center. This would then be entered as source_zone_boundary = $[7,20]$ and source_zone_concentration = $[10,5]$. The source can be a single zone with a single concentration as well.</p> <p>By giving a total mass of the contaminant source, the amount of solid-phase contaminant, and with that, the source zone concentrations, diminish over time. The rate at which this occurs depends on the flow velocity in the aquifer and the size of the source zone. The source zone can be set to be considered infinite as well, meaning that the concentrations will not diminish over time.</p>"},{"location":"examples/example_walkthrough/#model-parameters","title":"Model parameters\u00b6","text":"<p>Accepts input for the model dimensions and discretization. Model length is the extent in the (x) direction parallel to the groundwater flow direction. The model width is the extent of the model perpendicular (y) to the groundwater flow direction. Step size of the spatial dimensions is handled with dx and dy. Ensure that the source zone fits inside of the given model width. If step sizes are not given, a ratio of model_length (1/100), model_width (1/50) and model_time (1/10) is used by default.</p>"},{"location":"examples/example_walkthrough/#input-checking","title":"Input checking\u00b6","text":"<p>The dataclass inputs evaluates if the required input parameters are present, if they are of the correct data type and if they are in the expected domain.</p>"},{"location":"examples/example_walkthrough/#analytical-models","title":"Analytical models\u00b6","text":"<p>The various models located in mibitrans.transport.models. Currently, three models are implemented; 'Mibitrans', 'Anatrans' and 'Bioscreen'. Each with a distinct analytical solution, which are introduced below.</p> <p>Input to the model is provided through the dataclasses showcased above. Each input argument has the same name as the dataclass, but in snake_case instead of PascalCase (e.g. hydrological_paramaters takes in the data class HydrologicalParameters), to follow Python convention. The models are implemented as classes, which are first initialized through making the object. This will generate the model grid and do some prior parameter calculations. The model object can then be used to call attributes, or class methods. After initialization, no results have been calculated yet. For this, use the 'run' class method. This generates a results class object, which contains the concentration distribution as a 3D numpy array (indexed as $C[t,y,x]$) and the parameters used for this specific run.</p>"},{"location":"examples/example_walkthrough/#mibitrans-model","title":"Mibitrans model\u00b6","text":"<p>The Mibitrans model class uses the exact analytical solution implemented by Karanovic (2007) in the Excel based BIOSCREEN-AT, and added source depletion, akin to that implemented in its predecessor BIOSCREEN by Newell et al. (1997). This model is based on the Wexler (1992) solution. The Mibitrans model allows for the same method as used in BIOSCREEN-AT, but expands it by allowing multiple source zones (by means of superposition) and including the instant reaction model. These were present in the original BIOSCREEN, but not reimplemented in BIOSCREEN-AT. Using a single source zone in this model, and not using the instant reaction option will make the Mibitrans solution resolve to the equation described in Karanovic (2007). Which in turn resolves to the Wexler (1992) solution if source depletion is disabled.</p> <p>As the namesake model of this package, it is the recommended model to use. The other models introduce a margin of error by making some assumptions. However, since this model requires evaluation of an integral, computation time might be longer, depending on model discretization. The exact nature of these differences is too much to go into detail here, but is elaborated upon in the theoretical background.</p>"},{"location":"examples/example_walkthrough/#other-models","title":"Other models\u00b6","text":"<p>The two models other than the Mibitrans model share the same functionalities and properties as showcase above. The only difference is the implementation of calculation.</p>"},{"location":"examples/example_walkthrough/#anatrans-model","title":"Anatrans model\u00b6","text":"<p>The equation used for the Anatrans model has the assumption that C(x,y,z,t) = C(x,t) * C(y,t) * C(z,t). Then, the 3D ADE can be broken up in three separate differential equations which can be solved individually. For C(x,t) the solution is given in Bear (1979), C(y,t) and C(z,t) can be derived from Crank (1975). The Anatrans model is the combination of these solutions, with addition of source depletion, source superposition and instant reaction model, described in Newell et al. (1997). The solution of Newell et al. (1997) is based of the Domenico (1987) solution, a truncated version of the equation described above, which introduces an error with a size dependent on the ratio of flow velocity and longitudinal dispersivity. Anatrans instead uses the fully untruncated version.</p>"},{"location":"examples/example_walkthrough/#bioscreen-model","title":"Bioscreen model\u00b6","text":"<p>This model is an exact implementation of the transport equations implemented in the BIOSCREEN screening model of Newell et al. (1997), which is based on the Domenico (1987) analytical model. Using a truncated version of the equation used in the Anatrans model. This model is implemented as a method of comparison with the original BIOSCREEN software. And is included for legacy reasons, since it is the first model implemented in the mibitrans package, serving as a basis for the other models. However, caution should be taken when using this model, since a varying error is introduced by using the truncated analytical solution. The error is most prominent for shorter times and distances from the source, and depends on the ratio of flow velocity and longitudinal dispersivity. For modelling, the Anatrans (untruncated approximate solution) and Mibitrans (exact analytical solution) models are recommended instead.</p>"},{"location":"examples/example_walkthrough/#visualization","title":"Visualization\u00b6","text":"<p>Mibitrans has various ways to visualize the model results. Above the centerline plot was already showcased, which plots the concentration distribution over the center of the contaminant plume. Plotting can be performed either as class method (i.e. model_object.centerline), or by calling the centerline function specifically; (i.e. centerline(model_object). The 1D plotting functions are located in mibitrans.visualize.plot_line. Multidimensional plots are located in mibitrans.visualize.plot_surface.</p>"},{"location":"examples/example_walkthrough/#plotting-centerline","title":"Plotting centerline\u00b6","text":""},{"location":"examples/example_walkthrough/#plotting-transverse-distribution","title":"Plotting transverse distribution\u00b6","text":""},{"location":"examples/example_walkthrough/#plotting-breakthrough-curve","title":"Plotting breakthrough curve\u00b6","text":""},{"location":"examples/example_walkthrough/#plotting-in-2d","title":"Plotting in 2D\u00b6","text":""},{"location":"examples/example_walkthrough/#plotting-2d-in-3d","title":"Plotting 2D in 3D\u00b6","text":""},{"location":"examples/example_walkthrough/#animate-plots","title":"Animate plots\u00b6","text":"<p>All plots mentioned above in the visualization section have the option to be animated, which also can be saved as a file. Multiple models can be combined in a single animation. Make sure that parameters passed to the functions are inside the domain of all models. As each animation frame is a model time step, all models should have the exact same dt, otherwise, the animation will not show the correct temporal change in concentration.</p>"},{"location":"examples/example_walkthrough/#mass-balance","title":"Mass balance\u00b6","text":"<p>To gain numerical information about mass transport in the model area, use the mass balance method of the Results object. Each of the mass balance elements is a class property. Descriptions of each mass balance element can be found in analysis.mass_balance.MassBalance.</p>"},{"location":"introduction/introduction/","title":"Introduction","text":""},{"location":"introduction/introduction/#general","title":"General","text":"<p>Contaminated sites pose a risk to humans and the environment. Innovative cleaning technologies are needed to remediate these sites and remove contaminants such as petroleum hydrocarbons (PHC), cyanides and hexachlorocyclohexane (HCH).</p> <p>Conventional methods of contaminated site remediation are often costly and upkeep intensive. Bioremediation is an alternative of particular interest, as it degrades contaminants on-site. Assessment of ongoing biodegradation is an important step to check the feasibility for bioremediation. Similarly, modeling the fate of contaminants is key for understanding the processes involved and predicting bioremediation in the field. </p> <p>Estimating the extend of a contaminant plume through modelling is highly valuable for designing monitoring and site remediation strategies. Predicting the fate of contaminant in the subsurface requires combining simulations on groundwater flow, contaminant transport and chemical reactions. Simulations allows making predictions on amounts, locations and time scales of biodegradation as well as measures of bioremediation. Complex numerical models can provide a detailed picture by taking site geometry, complex flow pattern and contaminant source distrubution into account. But they require sufficient data and detailed knowledge of site conditions and come at high computational cost and expert knowledge for setup. Simple models, based on analytical and semi-analytical solutions of the subsurface transport equation do not necessarily provide a realistic distribution of the contaminant, but they allow a quick estimate of plume travel distances, plume extend and mass balance. They are thus a good first transport screening option.</p> <p>The purpose of the <code>mibitrans</code> package is to provide such as transport screening model based on hydrogeological field data for biodegredation and bioremediation. </p>"},{"location":"introduction/introduction/#mibirem","title":"MIBIREM","text":"<p>MIBIREM - Innovative technological toolbox for bioremediation is a EU funded consortium project by 12 international partners all over Europe working together to develop an Innovative technological toolbox for bioremediation. The project will develop molecular methods for the monitoring, isolation, cultivation and subsequent deposition of whole microbiomes. The toolbox will also include the methodology for the improvement of specific microbiome functions, including evolution and enrichment. The performance of selected microbiomes will be tested under real field conditions. The <code>mibitrans</code> package is part of this toolbox.</p>"},{"location":"introduction/introduction/#bioremediation","title":"Bioremediation","text":"<p>Bioremediation uses living organisms (including bacteria) to digest and neutralize environmental contaminants. Like the microbiome in the gut, which supports the body in digesting food, microbiomes at contaminated sites can degrade organic contaminant in soil and groundwater.</p> <p>Processes relevant for general biodegradation and bioremediation prediction are:</p> <ul> <li>hydrogeological flow and transport: this includes groundwater flow driven by hydraulic gradients, advective transport of contaminant, diffusion and dispersion</li> <li>transformation and phase transition processes: dissolution, volatilization, adsorption/retardation, decay</li> <li>biochemical processes: chemical reaction and microbial degradation</li> <li>microbiome evolution: spatial distribution and temporal development of bacteria actively degrading contaminants under various and/or changing environmental conditions.</li> </ul> <p>Modeling all these processes at the same time, requires a high level of model detail, spatially resolved parameter information and knowledge on initial and boundary conditions. This is typically not feasible in the field. Thus, we follow the approach to select and combine most relevant processes and have modeling sub-modules (repositories within the MiBiPreT organization) which can be used for data analysis and predictive modeling of individual or combined processes. At the same time, modules are designed to allow for coupling of processes and (modeling) sub-modules at a advanced stage of tool development.</p>"},{"location":"introduction/introduction/#functionality","title":"Functionality","text":"<p><code>mibitrans</code> is supposed to serve as hydrogeological transport screening model based on field data for biodegredation and bioremediation. In parts <code>mibitrans</code> reproduces - and extends- the functionality of the Excel-based screening tool <code>BIOSCREEN</code> [Newell et al., 1996]. Thus, transport is modelled based on the 3D advection dispersion equation considering linear equilibrium adsorption and various options for biodegradation. The option of no decay is also available. <code>mibitrans</code> is validated by comparing example field data with results from <code>BIOSCREEN</code>. </p>"},{"location":"introduction/introduction/#structure","title":"Structure","text":"<p>The core elements and folders for users of <code>mibitrans</code> are:</p> <ul> <li>The folder <code>mibitrans</code> contains the main functionality split up into folders for:<ul> <li><code>data</code></li> <li><code>transport</code></li> <li><code>analysis</code> </li> <li><code>visualization</code></li> </ul> </li> <li>The folder <code>examples</code> contains example workflows in the form of Jupyter-Notebooks outlining application of functionality on example data.</li> </ul>"},{"location":"introduction/introduction/#references","title":"References","text":"<p>Newell, C. J., R. K. Mcleod, J. R. Gonzales, and J. T. Wilson, BIOSCREEN natural attenuation decision support system user\u2019s manual version 1.3, Tech. rep., U.S. EPA, 1996.</p> <p>Newell, C. J., R. K. McLeod, and J. R. Gonzales, BIOSCREEN natural attenuation decision support system version 1.4 revisions, Tech. rep., U.S. EPA, 1997.</p>"},{"location":"reference/reference_analysis/","title":"<code>mibitrans.analysis</code> API reference","text":""},{"location":"reference/reference_analysis/#mibitrans.analysis.mass_balance","title":"<code>mass_balance</code>","text":"<p>Author: Jorrit Bakker.</p> <p>Module calculating the mass balance based on base parameters.</p>"},{"location":"reference/reference_analysis/#mibitrans.analysis.mass_balance.MassBalance","title":"<code>MassBalance</code>","text":"<p>Calculate mass balance characteristics of input model.</p> Source code in <code>mibitrans/analysis/mass_balance.py</code> <pre><code>class MassBalance:\n    \"\"\"Calculate mass balance characteristics of input model.\"\"\"\n\n    def __init__(self, results, time, verbose=False):\n        \"\"\"Mass balance object with source and plume characteristics at given time(s), of input model.\n\n        Args:\n            results: Input model for which mass balance is calculated, should be a child class of Transport3D.\n            time (float | str): Time at which to initially calculate the mass balance. Either as a value between 0 and\n                model end time. Or as 'all', which will calculate mass balance attributes for each time step as arrays.\n            verbose (bool, optional): Verbose mode. Defaults to False.\n\n        Call:\n            Calling the MassBalance object will recalculate the mass balance characteristics of input model for given\n                input time.\n\n        Properties:\n            plume_mass: Mass of the contaminant plume inside the model extent, at the given time(s), in [g].\n            source_mass: Mass of the contaminant source at the given time(s), in [g]. No values are given for models\n                with infinite source mass.\n            delta_source: Difference in mass between contaminant source at given time and source at t = 0, in [g].\n            degraded_mass: Mass of plume contaminant degradation at the given time(s), compared to a model without\n                degradation, in [g]. Has no value if model does not consider degradation.\n            model_without_degradation: Object of model without degradation. Has no value if model does not consider\n                degradation.\n            instant_reaction_degraded_mass(self): Difference in plume mass instant reaction with and without\n                biodegradation capacity subtracted, in [g].\n            electron_acceptor_change(self): Change in electron acceptor/byproduct masses at the given time(s), in [g].\n                Only for instant reaction.\n        \"\"\"\n        check_model_type(results, mibitrans.transport.model_parent.Results)\n        self.results = results\n        self.verbose = verbose\n        self.t = self._time_check(time)\n\n        self._plume_mass_t = None\n        self._source_mass_t = None\n        self._delta_source_t = None\n        self._degraded_mass_t = None\n        self._electron_acceptor_change_t = None\n        self._instant_reaction_degraded_mass_t = None\n        self._model_without_degradation = None\n\n        # Volume of single cell, as dx * dy * source thickness\n        self.cellsize = (\n            abs(results.x[0] - results.x[1]) * abs(results.y[0] - results.y[1]) * results.source_parameters.depth\n        )\n\n        # Mass balance output differs if the source is represented as an infinite mass.\n        if self.results.source_parameters.total_mass == np.inf:\n            self.source_mass_finite = False\n        else:\n            self.source_mass_finite = True\n\n        match self.results.mode:\n            # Instant reaction model\n            case \"instant_reaction\":\n                self.model_instant_reaction = True\n                self.model_degradation = True\n            # Linear decay model\n            case \"linear\" if self.results.attenuation_parameters.decay_rate &gt; 0:\n                self.model_degradation = True\n                self.model_instant_reaction = False\n            # No decay model\n            case _:\n                self.model_degradation = False\n                self.model_instant_reaction = False\n\n        if self.verbose:\n            print(\"Calculating mass balance...\")\n\n        self._calculation_routine()\n\n    def __call__(self, time=None, method=None):\n        \"\"\"Recalculate the mass balance characteristics of input model for given time and method.\"\"\"\n        if time:\n            self.t = self._time_check(time)\n\n        if self.verbose:\n            print(\"Recalculating mass balance...\")\n\n        self._calculation_routine()\n\n    @property\n    def plume_mass(self):\n        \"\"\"Mass of the contaminant plume in the model extent, at the given time(s), in [g].\"\"\"\n        return self._plume_mass_t\n\n    @property\n    def source_mass(self):\n        \"\"\"Mass of the contaminant source at the given time(s), in [g]. No values are given for infinite source mass.\"\"\"\n        return self._source_mass_t\n\n    @property\n    def delta_source(self):\n        \"\"\"Difference in mass between contaminant source at given time and source at t = 0, in [g].\"\"\"\n        return self._delta_source_t\n\n    @property\n    def degraded_mass(self):\n        \"\"\"Mass of plume contaminant degradation at the given time(s), compared to a no degradation model, in [g].\"\"\"\n        return self._degraded_mass_t\n\n    @property\n    def model_without_degradation(self):\n        \"\"\"Model with no degradation used to compare with given model.\"\"\"\n        return self._model_without_degradation\n\n    @property\n    def instant_reaction_degraded_mass(self):\n        \"\"\"Difference in plume mass instant reaction with and without biodegradation capacity subtracted, in [g].\n\n        For the instant reaction model, the underlying assumption reads that observed concentrations in the source zone\n        are post-degradation. Therefore, the source concentrations without any biodegradation would be higher, the\n        amount which is determined by the biodegradation capacity. Then, according to this method, the degraded mass\n        is the difference between plume mass before and after subtracting the biodegradation capacity.\n        \"\"\"\n        return self._instant_reaction_degraded_mass_t\n\n    @property\n    def electron_acceptor_change(self):\n        \"\"\"Change in electron acceptor/byproduct masses at the given time(s), in [g]. Only for instant reaction.\n\n        Electron acceptor/byproduct consumption or generation is based on the degraded plume mass (specifically\n        'instant_reaction_degraded_mass'), the utilization factor and relative abundance of the acceptors/byproducts.\n        Under the governing assumptions of the instant reaction model, a crude estimate of the total consumption of\n        electron acceptors and the generation of byproduct is calculated.\n        \"\"\"\n        return self._electron_acceptor_change_t\n\n    def source_threshold(self, threshold):\n        \"\"\"Calculate when source mass is below given threshold. No values are given for infinite source mass.\"\"\"\n        validate_input_values(\"threshold\", threshold)\n        if not self.source_mass_finite:\n            raise ValueError(\"Source mass is infinite and therefore cannot go below given threshold.\")\n        else:\n            time_to_threshold = (\n                -1 / self.results.k_source * np.log(threshold / self.results.source_parameters.total_mass)\n            )\n        return time_to_threshold\n\n    def _calculation_routine(self):\n        \"\"\"Perform mass_balance calculations.\"\"\"\n        self._check_model_extent()\n        self._plume_mass_t = self._calculate_plume_mass(self.results)\n        self._source_mass_t = self._calculate_source_mass()\n        self._delta_source_t = self._calculate_delta_source()\n        if self.model_degradation:\n            self._model_without_degradation = self._calculate_model_without_degradation()\n            self._degraded_mass_t = self._calculate_degraded_mass()\n        if self.model_instant_reaction:\n            self._instant_reaction_degraded_mass_t = self._calculate_instant_reaction_degraded_mass()\n            self._electron_acceptor_change_t = self._calculate_electron_acceptor_change()\n\n    def _check_model_extent(self):\n        \"\"\"Check if contaminant plume at given time is reasonably situated within the model extent.\"\"\"\n        # Relative concentration considered to be boundary of the plume extent.\n        extent_threshold_value = 0.01\n        if isinstance(self.t, np.ndarray):\n            cxyt_y_boundary = self.results.relative_cxyt[:, [0, -1], :]\n            cxyt_x_boundary = self.results.relative_cxyt[:, :, -1]\n        else:\n            cxyt_y_boundary = self.results.relative_cxyt[self._t_index, [0, -1], :]\n            cxyt_x_boundary = self.results.relative_cxyt[self._t_index, :, -1]\n\n        y_boundary_above_threshold = np.where(cxyt_y_boundary &gt; extent_threshold_value, cxyt_y_boundary, 0.0)\n        x_boundary_above_threshold = np.where(cxyt_x_boundary &gt; extent_threshold_value, cxyt_x_boundary, 0.0)\n        if np.sum(y_boundary_above_threshold) &gt; 0:\n            y_max = np.round(\n                np.max(y_boundary_above_threshold) * np.max(self.results.source_parameters.source_zone_concentration), 2\n            )\n            warnings.warn(\n                \"Contaminant plume extents beyond the model width, with a maximum concentration at the \"\n                f\"boundary of {y_max}g/m3. To ensure reliable mass balance, re-run the model with increased dimensions \"\n                \"to include the entire plume width in the model extent.\"\n            )\n        if np.sum(x_boundary_above_threshold) &gt; 0:\n            x_max = np.round(\n                np.max(x_boundary_above_threshold) * np.max(self.results.source_parameters.source_zone_concentration), 2\n            )\n            warnings.warn(\n                \"Contaminant plume extents beyond the model length, with a maximum concentration at the \"\n                f\"boundary of {x_max}g/m3. To ensure reliable mass balance, re-run the model with increased dimensions \"\n                \"to include the entire plume length in the model extent.\"\n            )\n\n    def _calculate_plume_mass(self, model):\n        \"\"\"Calculate plume mass of input model, for the given time(s).\"\"\"\n        # Plume mass of model; concentration is converted to mass by multiplying by cellsize and pore space.\n        if isinstance(self.t, np.ndarray):\n            plume_mass_t = np.sum(\n                model.cxyt[:, :, 1:] * self.cellsize * self.results.hydrological_parameters.porosity, axis=(1, 2)\n            )\n        else:\n            plume_mass_t = np.sum(\n                model.cxyt[self._t_index, :, 1:] * self.cellsize * self.results.hydrological_parameters.porosity\n            )\n\n        return plume_mass_t\n\n    def _calculate_source_mass(self):\n        \"\"\"Calculate source mass of input model, for the given time(s).\"\"\"\n        if self.source_mass_finite:\n            source_mass_t = self.results.source_parameters.total_mass * np.exp(-self.results.k_source * self.t)\n        else:\n            source_mass_t = np.inf\n\n        return source_mass_t\n\n    def _calculate_delta_source(self):\n        \"\"\"Calculate difference in source mass between t=0 and given time(s).\"\"\"\n        if self.source_mass_finite:\n            delta_source_t = self.results.source_parameters.total_mass - self._source_mass_t\n        else:\n            Q, c0_avg = calculate_discharge_and_average_source_zone_concentration(self.results)\n            delta_source_t = Q * c0_avg * self.t\n        return delta_source_t\n\n    def _calculate_model_without_degradation(self):\n        \"\"\"Make a no degradation model for comparison, pass the input parameters to a new class instance as kwargs.\"\"\"\n        model_without_degradation = self.results.model_type(**self.results.input_parameters)\n        model_without_degradation.attenuation_parameters.decay_rate = 0\n        model_without_degradation.run()\n        return model_without_degradation\n\n    def _calculate_degraded_mass(self):\n        \"\"\"Calculate difference between input model plume mass and no degradation model, for a given time(s).\"\"\"\n        no_degradation_plume_mass = self._calculate_plume_mass(self._model_without_degradation)\n        degraded_mass_t = no_degradation_plume_mass - self._plume_mass_t\n        return degraded_mass_t\n\n    def _calculate_instant_reaction_degraded_mass(self):\n        \"\"\"Calculate difference between input model plume mass and no degradation model for instant reaction model.\"\"\"\n        if isinstance(self.t, np.ndarray):\n            plume_mass_t_noBC = np.sum(\n                self.results.cxyt_noBC[:, :, 1:] * self.cellsize * self.results.hydrological_parameters.porosity,\n                axis=(1, 2),\n            )\n        else:\n            plume_mass_t_noBC = np.sum(\n                self.results.cxyt_noBC[self._t_index, :, 1:]\n                * self.cellsize\n                * self.results.hydrological_parameters.porosity\n            )\n\n        degraded_mass_instant_t = plume_mass_t_noBC - self._plume_mass_t\n        return degraded_mass_instant_t\n\n    def _calculate_electron_acceptor_change(self):\n        \"\"\"Calculate the change in electron acceptor mass for given time(s) for instant reaction model.\"\"\"\n        mass_fraction_degraded_acceptor = self.results.electron_acceptors.array / self.results.biodegradation_capacity\n        electron_acceptor_change = {}\n        electron_acceptors = [\"oxygen\", \"nitrate\", \"ferrous_iron\", \"sulfate\", \"methane\"]\n        for i, ea in enumerate(electron_acceptors):\n            electron_acceptor_change[ea] = self._instant_reaction_degraded_mass_t * mass_fraction_degraded_acceptor[i]\n\n        return electron_acceptor_change\n\n    def _time_check(self, time):\n        \"\"\"Check if time input is valid.\"\"\"\n        if time is None or time == \"all\":\n            t = self.results.t\n        elif isinstance(time, str):\n            warnings.warn(\"String not recognized, defaulting to 'all', for all time points.\")\n            t = self.results.t\n        else:\n            self._t_index = check_time_in_domain(self.results, time)\n            t = float(self.results.t[self._t_index])\n        return t\n</code></pre>"},{"location":"reference/reference_analysis/#mibitrans.analysis.mass_balance.MassBalance.degraded_mass","title":"<code>degraded_mass</code>  <code>property</code>","text":"<p>Mass of plume contaminant degradation at the given time(s), compared to a no degradation model, in [g].</p>"},{"location":"reference/reference_analysis/#mibitrans.analysis.mass_balance.MassBalance.delta_source","title":"<code>delta_source</code>  <code>property</code>","text":"<p>Difference in mass between contaminant source at given time and source at t = 0, in [g].</p>"},{"location":"reference/reference_analysis/#mibitrans.analysis.mass_balance.MassBalance.electron_acceptor_change","title":"<code>electron_acceptor_change</code>  <code>property</code>","text":"<p>Change in electron acceptor/byproduct masses at the given time(s), in [g]. Only for instant reaction.</p> <p>Electron acceptor/byproduct consumption or generation is based on the degraded plume mass (specifically \u2018instant_reaction_degraded_mass\u2019), the utilization factor and relative abundance of the acceptors/byproducts. Under the governing assumptions of the instant reaction model, a crude estimate of the total consumption of electron acceptors and the generation of byproduct is calculated.</p>"},{"location":"reference/reference_analysis/#mibitrans.analysis.mass_balance.MassBalance.instant_reaction_degraded_mass","title":"<code>instant_reaction_degraded_mass</code>  <code>property</code>","text":"<p>Difference in plume mass instant reaction with and without biodegradation capacity subtracted, in [g].</p> <p>For the instant reaction model, the underlying assumption reads that observed concentrations in the source zone are post-degradation. Therefore, the source concentrations without any biodegradation would be higher, the amount which is determined by the biodegradation capacity. Then, according to this method, the degraded mass is the difference between plume mass before and after subtracting the biodegradation capacity.</p>"},{"location":"reference/reference_analysis/#mibitrans.analysis.mass_balance.MassBalance.model_without_degradation","title":"<code>model_without_degradation</code>  <code>property</code>","text":"<p>Model with no degradation used to compare with given model.</p>"},{"location":"reference/reference_analysis/#mibitrans.analysis.mass_balance.MassBalance.plume_mass","title":"<code>plume_mass</code>  <code>property</code>","text":"<p>Mass of the contaminant plume in the model extent, at the given time(s), in [g].</p>"},{"location":"reference/reference_analysis/#mibitrans.analysis.mass_balance.MassBalance.source_mass","title":"<code>source_mass</code>  <code>property</code>","text":"<p>Mass of the contaminant source at the given time(s), in [g]. No values are given for infinite source mass.</p>"},{"location":"reference/reference_analysis/#mibitrans.analysis.mass_balance.MassBalance.__call__","title":"<code>__call__(time=None, method=None)</code>","text":"<p>Recalculate the mass balance characteristics of input model for given time and method.</p> Source code in <code>mibitrans/analysis/mass_balance.py</code> <pre><code>def __call__(self, time=None, method=None):\n    \"\"\"Recalculate the mass balance characteristics of input model for given time and method.\"\"\"\n    if time:\n        self.t = self._time_check(time)\n\n    if self.verbose:\n        print(\"Recalculating mass balance...\")\n\n    self._calculation_routine()\n</code></pre>"},{"location":"reference/reference_analysis/#mibitrans.analysis.mass_balance.MassBalance.__init__","title":"<code>__init__(results, time, verbose=False)</code>","text":"<p>Mass balance object with source and plume characteristics at given time(s), of input model.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <p>Input model for which mass balance is calculated, should be a child class of Transport3D.</p> required <code>time</code> <code>float | str</code> <p>Time at which to initially calculate the mass balance. Either as a value between 0 and model end time. Or as \u2018all\u2019, which will calculate mass balance attributes for each time step as arrays.</p> required <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> Call <p>Calling the MassBalance object will recalculate the mass balance characteristics of input model for given     input time.</p> Properties <p>plume_mass: Mass of the contaminant plume inside the model extent, at the given time(s), in [g]. source_mass: Mass of the contaminant source at the given time(s), in [g]. No values are given for models     with infinite source mass. delta_source: Difference in mass between contaminant source at given time and source at t = 0, in [g]. degraded_mass: Mass of plume contaminant degradation at the given time(s), compared to a model without     degradation, in [g]. Has no value if model does not consider degradation. model_without_degradation: Object of model without degradation. Has no value if model does not consider     degradation. instant_reaction_degraded_mass(self): Difference in plume mass instant reaction with and without     biodegradation capacity subtracted, in [g]. electron_acceptor_change(self): Change in electron acceptor/byproduct masses at the given time(s), in [g].     Only for instant reaction.</p> Source code in <code>mibitrans/analysis/mass_balance.py</code> <pre><code>def __init__(self, results, time, verbose=False):\n    \"\"\"Mass balance object with source and plume characteristics at given time(s), of input model.\n\n    Args:\n        results: Input model for which mass balance is calculated, should be a child class of Transport3D.\n        time (float | str): Time at which to initially calculate the mass balance. Either as a value between 0 and\n            model end time. Or as 'all', which will calculate mass balance attributes for each time step as arrays.\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Call:\n        Calling the MassBalance object will recalculate the mass balance characteristics of input model for given\n            input time.\n\n    Properties:\n        plume_mass: Mass of the contaminant plume inside the model extent, at the given time(s), in [g].\n        source_mass: Mass of the contaminant source at the given time(s), in [g]. No values are given for models\n            with infinite source mass.\n        delta_source: Difference in mass between contaminant source at given time and source at t = 0, in [g].\n        degraded_mass: Mass of plume contaminant degradation at the given time(s), compared to a model without\n            degradation, in [g]. Has no value if model does not consider degradation.\n        model_without_degradation: Object of model without degradation. Has no value if model does not consider\n            degradation.\n        instant_reaction_degraded_mass(self): Difference in plume mass instant reaction with and without\n            biodegradation capacity subtracted, in [g].\n        electron_acceptor_change(self): Change in electron acceptor/byproduct masses at the given time(s), in [g].\n            Only for instant reaction.\n    \"\"\"\n    check_model_type(results, mibitrans.transport.model_parent.Results)\n    self.results = results\n    self.verbose = verbose\n    self.t = self._time_check(time)\n\n    self._plume_mass_t = None\n    self._source_mass_t = None\n    self._delta_source_t = None\n    self._degraded_mass_t = None\n    self._electron_acceptor_change_t = None\n    self._instant_reaction_degraded_mass_t = None\n    self._model_without_degradation = None\n\n    # Volume of single cell, as dx * dy * source thickness\n    self.cellsize = (\n        abs(results.x[0] - results.x[1]) * abs(results.y[0] - results.y[1]) * results.source_parameters.depth\n    )\n\n    # Mass balance output differs if the source is represented as an infinite mass.\n    if self.results.source_parameters.total_mass == np.inf:\n        self.source_mass_finite = False\n    else:\n        self.source_mass_finite = True\n\n    match self.results.mode:\n        # Instant reaction model\n        case \"instant_reaction\":\n            self.model_instant_reaction = True\n            self.model_degradation = True\n        # Linear decay model\n        case \"linear\" if self.results.attenuation_parameters.decay_rate &gt; 0:\n            self.model_degradation = True\n            self.model_instant_reaction = False\n        # No decay model\n        case _:\n            self.model_degradation = False\n            self.model_instant_reaction = False\n\n    if self.verbose:\n        print(\"Calculating mass balance...\")\n\n    self._calculation_routine()\n</code></pre>"},{"location":"reference/reference_analysis/#mibitrans.analysis.mass_balance.MassBalance.source_threshold","title":"<code>source_threshold(threshold)</code>","text":"<p>Calculate when source mass is below given threshold. No values are given for infinite source mass.</p> Source code in <code>mibitrans/analysis/mass_balance.py</code> <pre><code>def source_threshold(self, threshold):\n    \"\"\"Calculate when source mass is below given threshold. No values are given for infinite source mass.\"\"\"\n    validate_input_values(\"threshold\", threshold)\n    if not self.source_mass_finite:\n        raise ValueError(\"Source mass is infinite and therefore cannot go below given threshold.\")\n    else:\n        time_to_threshold = (\n            -1 / self.results.k_source * np.log(threshold / self.results.source_parameters.total_mass)\n        )\n    return time_to_threshold\n</code></pre>"},{"location":"reference/reference_analysis/#mibitrans.analysis.parameter_calculations","title":"<code>parameter_calculations</code>","text":"<p>Author: Jorrit Bakker.</p> <p>Module containing various methods that takes a dictionary of parameters as input and calculates the proper values that can be used in transport equations.</p>"},{"location":"reference/reference_analysis/#mibitrans.analysis.parameter_calculations.calculate_discharge_and_average_source_zone_concentration","title":"<code>calculate_discharge_and_average_source_zone_concentration(model)</code>","text":"<p>Calculate discharge through source zone and average source zone concentration, returned in respective order.</p> Source code in <code>mibitrans/analysis/parameter_calculations.py</code> <pre><code>def calculate_discharge_and_average_source_zone_concentration(model):\n    \"\"\"Calculate discharge through source zone and average source zone concentration, returned in respective order.\"\"\"\n    if model.mode == \"instant_reaction\":\n        bc = model.biodegradation_capacity\n    else:\n        bc = 0\n    y_src = np.zeros(len(model.source_parameters.source_zone_boundary) + 1)\n    y_src[1:] = model.source_parameters.source_zone_boundary\n    c_src = model.source_parameters.source_zone_concentration\n    Q = (\n        model.hydrological_parameters.velocity\n        * model.hydrological_parameters.porosity\n        * model.source_parameters.depth\n        * np.max(y_src)\n        * 2\n    )\n\n    weighted_conc = np.zeros(len(model.source_parameters.source_zone_boundary))\n    for i in range(len(model.source_parameters.source_zone_boundary)):\n        weighted_conc[i] = (y_src[i + 1] - y_src[i]) * c_src[i]\n\n    c0_avg = bc + np.sum(weighted_conc) / np.max(y_src)\n\n    return Q, c0_avg\n</code></pre>"},{"location":"reference/reference_analysis/#mibitrans.analysis.parameter_calculations.calculate_utilization","title":"<code>calculate_utilization(model)</code>","text":"<p>Function that calculates relative use of electron acceptors in biodegradation of BTEX.</p> Source code in <code>mibitrans/analysis/parameter_calculations.py</code> <pre><code>def calculate_utilization(model):\n    \"\"\"Function that calculates relative use of electron acceptors in biodegradation of BTEX.\"\"\"\n    util_factor = model._utilization_factor.dictionary\n    biodeg_array = np.zeros(len(list(util_factor.keys())))\n    util_array = np.zeros(len(biodeg_array))\n\n    for i, (key, value) in enumerate(util_factor.items()):\n        biodeg_array[i] = getattr(model._electron_acceptors, util_to_conc_name[key]) / value\n        util_array[i] = value\n\n    biodegradation_capacity = np.sum(biodeg_array)\n    fraction_total = biodeg_array / biodegradation_capacity\n    mass_fraction = fraction_total * util_array\n\n    return mass_fraction\n</code></pre>"},{"location":"reference/reference_data/","title":"<code>mibitrans.data</code> API reference","text":""},{"location":"reference/reference_data/#mibitrans.data.check_input","title":"<code>check_input</code>","text":"<p>Author: Jorrit Bakker.</p> <p>Module evaluating if a dictionary contains all required (correct) parameters for analysis</p>"},{"location":"reference/reference_data/#mibitrans.data.check_input.DomainValueError","title":"<code>DomainValueError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised for values that are outside their possible domain.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>class DomainValueError(Exception):\n    \"\"\"Exception raised for values that are outside their possible domain.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message):\n        \"\"\"Initialize error class.\"\"\"\n        self.message = message\n        super().__init__(self.message)\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.check_input.DomainValueError.__init__","title":"<code>__init__(message)</code>","text":"<p>Initialize error class.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>def __init__(self, message):\n    \"\"\"Initialize error class.\"\"\"\n    self.message = message\n    super().__init__(self.message)\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.check_input.MissingValueError","title":"<code>MissingValueError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when one or more required parameters are missing.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>class MissingValueError(Exception):\n    \"\"\"Exception raised when one or more required parameters are missing.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message):\n        \"\"\"Initialize error class.\"\"\"\n        self.message = message\n        super().__init__(self.message)\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.check_input.MissingValueError.__init__","title":"<code>__init__(message)</code>","text":"<p>Initialize error class.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>def __init__(self, message):\n    \"\"\"Initialize error class.\"\"\"\n    self.message = message\n    super().__init__(self.message)\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.check_input.check_dictionary","title":"<code>check_dictionary(value)</code>","text":"<p>Check if variable is a dictionary, and raise an error if it is not.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>def check_dictionary(value):\n    \"\"\"Check if variable is a dictionary, and raise an error if it is not.\"\"\"\n    if not isinstance(value, dict):\n        raise TypeError(f\"Input must be a dict, but is {type(value)} instead.\")\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.check_input.check_model_type","title":"<code>check_model_type(parameter, allowed_model_types)</code>","text":"<p>Check if variable is of the given allowed model types, and raise an error if it is not.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>def check_model_type(parameter, allowed_model_types):\n    \"\"\"Check if variable is of the given allowed model types, and raise an error if it is not.\"\"\"\n    if not isinstance(parameter, allowed_model_types):\n        if isinstance(allowed_model_types, tuple):\n            raise TypeError(\n                f\"Input argument model should be subclass of {allowed_model_types}, but is {type(parameter)} instead.\"\n            )\n        else:\n            raise TypeError(\n                f\"Input argument model should be in {allowed_model_types.__subclasses__()}, \"\n                f\"but is {type(parameter)} instead.\"\n            )\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.check_input.check_time_in_domain","title":"<code>check_time_in_domain(model, time)</code>","text":"<p>Check if time input is valid, and returns the index of nearest time.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>def check_time_in_domain(model, time):\n    \"\"\"Check if time input is valid, and returns the index of nearest time.\"\"\"\n    if time is not None:\n        error = _check_numeric_positive(\"time\", time)\n        if error is not None:\n            raise error\n        elif time &gt; np.max(model.t):\n            warnings.warn(\n                f\"Desired time is larger than maximum time of model ({time} &gt; {np.max(model.t)}). Using maximum time \"\n                f\"of model instead.\"\n            )\n            time_pos = len(model.t) - 1\n        else:\n            time_pos = np.argmin(abs(model.t - time))\n    else:\n        time_pos = len(model.t) - 1\n    return time_pos\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.check_input.check_x_in_domain","title":"<code>check_x_in_domain(model, x_position)</code>","text":"<p>Check if x-position input is valid, and returns the index of nearest x position.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>def check_x_in_domain(model, x_position):\n    \"\"\"Check if x-position input is valid, and returns the index of nearest x position.\"\"\"\n    error = _check_numeric_positive(\"x_position\", x_position)\n    if error is not None:\n        raise error\n    if x_position &gt; np.max(model.x):\n        warnings.warn(\n            f\"Desired x position is outside of model domain ({x_position} &gt; {np.max(model.x)}). \"\n            f\"Using closest position inside model domain instead.\"\n        )\n\n    x_pos = np.argmin(abs(model.x - x_position))\n    return x_pos\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.check_input.check_y_in_domain","title":"<code>check_y_in_domain(model, y_position)</code>","text":"<p>Check if y-position input is valid, and returns the index of nearest y position.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>def check_y_in_domain(model, y_position):\n    \"\"\"Check if y-position input is valid, and returns the index of nearest y position.\"\"\"\n    error = _check_numeric(\"y_position\", y_position)\n    if error is not None:\n        raise error\n    if y_position &gt; np.max(model.y):\n        warnings.warn(\n            f\"Desired y position is outside of model domain (abs({y_position}) &gt; {np.max(model.y)}). \"\n            f\"Using closest position inside model domain instead.\"\n        )\n\n    y_pos = np.argmin(abs(model.y - y_position))\n    return y_pos\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.check_input.validate_input_values","title":"<code>validate_input_values(parameter, value)</code>","text":"<p>Validate if input parameter is of correct type and in correct domain.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>def validate_input_values(parameter, value):\n    \"\"\"Validate if input parameter is of correct type and in correct domain.\"\"\"\n    match parameter:\n        # Any input for verbose argument is fine; if set to anything other than False, 0 or None, verbose is on\n        case \"verbose\":\n            error = None\n        case \"_on_change\":\n            error = None\n        # Specific check for retardation, which has domain &gt;= 1\n        case \"retardation\":\n            error = _check_numeric_retardation(parameter, value)\n        # Specific check for total mass, which can be a positive float, or a specific string\n        case \"total_mass\":\n            error = _check_total_mass(parameter, value)\n        # Specific check for electron acceptor utilization factor, which should be UtilizationFactor dataclass\n        case \"utilization_factor\":\n            error = _check_dataclass(parameter, value, mibitrans.data.parameter_information.UtilizationFactor)\n        # Parameters which can be any float value\n        case \"y_position\":\n            error = _check_numeric(parameter, value)\n        # Parameters which have domain [0,1]\n        case \"porosity\" | \"fraction_organic_carbon\":\n            error = _check_numeric_fraction(parameter, value)\n        # Parameters which are input as single values, lists or numpy arrays\n        case \"source_zone_boundary\" | \"source_zone_concentration\":\n            error = _check_array_list_numeric_positive(parameter, value)\n        case \"electron_acceptors\":\n            error = _check_electron_acceptor(value)\n        # All other parameters are checked as floats on positive domain\n        case _:\n            error = _check_numeric_positive(parameter, value)\n\n    if error and (value is not None):\n        raise error\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.check_input.validate_source_zones","title":"<code>validate_source_zones(boundary, concentration)</code>","text":"<p>Validate and adapt input of source_zone_boundary and source_zone_concentration arrays.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>def validate_source_zones(boundary, concentration):\n    \"\"\"Validate and adapt input of source_zone_boundary and source_zone_concentration arrays.\"\"\"\n    # Ensure boundary and concentration are numpy arrays\n    if isinstance(boundary, (float, int, np.floating, np.integer)):\n        boundary = np.array([boundary])\n    else:\n        boundary = np.array(boundary)\n\n    if isinstance(concentration, (float, int, np.floating, np.integer)):\n        concentration = np.array([concentration], dtype=float)\n    else:\n        concentration = np.array(concentration, dtype=float)\n\n    # Each given source zone boundary should have a given concentration, and vice versa\n    if boundary.shape != concentration.shape:\n        raise ValueError(\n            f\"Length of source zone boundary ({len(boundary)}) and source zone concentration \"\n            f\"({len(concentration)}) do not match. Make sure they are of equal length.\"\n        )\n\n    # Reorder source zone locations if they are not given in order from close to far from source zone center\n    if len(boundary) &gt; 1:\n        if not all(boundary[:-1] &lt;= boundary[1:]):\n            sort_location = np.argsort(boundary)\n            boundary.sort()\n            concentration = concentration[sort_location]\n            warnings.warn(\n                \"Source zone boundary locations should be ordered by distance from source zone center. \"\n                \"Zone boundaries and concentrations have consequently been reordered as follows:\"\n                f\"Source zone boundaries: {boundary}\"\n                f\"Source zone concentrations: {concentration}\"\n            )\n        # Superposition method only works if the zone closer to the center has higher concentration than outer zones\n        if not all(concentration[:-1] &gt; concentration[1:]):\n            raise ValueError(\n                \"Source zone concentrations should be in descending order; no source zone can have a concentration \"\n                \"higher than the concentration of a zone closer to source center, due to the superposition method.\"\n            )\n    return boundary, concentration\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameter_information","title":"<code>parameter_information</code>","text":"<p>Author: Jorrit Bakker.</p> <p>File containing various dictionaries used for evaluation of names, value types and units of input data.</p>"},{"location":"reference/reference_data/#mibitrans.data.parameter_information.ElectronAcceptors","title":"<code>ElectronAcceptors</code>  <code>dataclass</code>","text":"<p>Make object with concentrations of electron acceptors.</p> <p>Dataclass which handles the entry of electron acceptor concentrations used for the instant reaction biodegradation method. As plume concentrations for reduced electron acceptor species and as difference between plume and background concentrations for the electron acceptors themselves.</p> <p>delta_oxygen (float) : Difference between background oxygen and plume oxygen concentrations, in [g/m^3].     Only required for instant reaction models. delta_nitrate (float) : Difference between background nitrate and contaminant plume nitrate concentrations,     in [g/m^3]. Only required for instant reaction models. ferrous_iron (float) : Ferrous iron concentration in contaminant plume, in [g/m^3]. Only required for     instant reaction models. delta_sulfate (float) : Difference between background sulfate and plume sulfate concentrations, in [g/m^3].     Only required for instant reaction models. methane (float) : Methane concentration in contaminant plume, in [g/m^3]. Only required for     instant reaction models.</p> Source code in <code>mibitrans/data/parameter_information.py</code> <pre><code>@dataclass\nclass ElectronAcceptors:\n    \"\"\"Make object with concentrations of electron acceptors.\n\n    Dataclass which handles the entry of electron acceptor concentrations used for the instant reaction biodegradation\n    method. As plume concentrations for reduced electron acceptor species and as difference between plume and background\n    concentrations for the electron acceptors themselves.\n\n    delta_oxygen (float) : Difference between background oxygen and plume oxygen concentrations, in [g/m^3].\n        Only required for instant reaction models.\n    delta_nitrate (float) : Difference between background nitrate and contaminant plume nitrate concentrations,\n        in [g/m^3]. Only required for instant reaction models.\n    ferrous_iron (float) : Ferrous iron concentration in contaminant plume, in [g/m^3]. Only required for\n        instant reaction models.\n    delta_sulfate (float) : Difference between background sulfate and plume sulfate concentrations, in [g/m^3].\n        Only required for instant reaction models.\n    methane (float) : Methane concentration in contaminant plume, in [g/m^3]. Only required for\n        instant reaction models.\n    \"\"\"\n\n    delta_oxygen: float\n    delta_nitrate: float\n    ferrous_iron: float\n    delta_sulfate: float\n    methane: float\n\n    def __setattr__(self, parameter, value):\n        \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n        validate_input_values(parameter, value)\n        super().__setattr__(parameter, value)\n\n    @property\n    def dictionary(self):\n        \"\"\"Returns electron acceptors in the form of a dictionary.\"\"\"\n        return dict(\n            delta_oxygen=self.delta_oxygen,\n            delta_nitrate=self.delta_nitrate,\n            ferrous_iron=self.ferrous_iron,\n            delta_sulfate=self.delta_sulfate,\n            methane=self.methane,\n        )\n\n    @property\n    def array(self):\n        \"\"\"Return electron acceptor concentrations in the form of an array, in order of [O2, NO3, Fe, SO4, CH4].\"\"\"\n        return np.array([self.delta_oxygen, self.delta_nitrate, self.ferrous_iron, self.delta_sulfate, self.methane])\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameter_information.ElectronAcceptors.array","title":"<code>array</code>  <code>property</code>","text":"<p>Return electron acceptor concentrations in the form of an array, in order of [O2, NO3, Fe, SO4, CH4].</p>"},{"location":"reference/reference_data/#mibitrans.data.parameter_information.ElectronAcceptors.dictionary","title":"<code>dictionary</code>  <code>property</code>","text":"<p>Returns electron acceptors in the form of a dictionary.</p>"},{"location":"reference/reference_data/#mibitrans.data.parameter_information.ElectronAcceptors.__setattr__","title":"<code>__setattr__(parameter, value)</code>","text":"<p>Override parent method to validate input when attribute is set.</p> Source code in <code>mibitrans/data/parameter_information.py</code> <pre><code>def __setattr__(self, parameter, value):\n    \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n    validate_input_values(parameter, value)\n    super().__setattr__(parameter, value)\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameter_information.UtilizationFactor","title":"<code>UtilizationFactor</code>  <code>dataclass</code>","text":"<p>Make object containing information about electron acceptor utilization factor.</p> <p>Parameters:</p> Name Type Description Default <code>util_oxygen (float) </code> <p>utilization factor of oxygen, as mass of oxygen consumed per mass of biodegraded contaminant [g/g].</p> required <code>util_nitrate (float) </code> <p>utilization factor of nitrate, as mass of nitrate consumed per mass of biodegraded contaminant [g/g].</p> required <code>util_ferrous_iron (float) </code> <p>utilization factor of ferrous iron, as mass of ferrous iron generated per mass of biodegraded contaminant [g/g].</p> required <code>util_sulfate (float) </code> <p>utilization factor of sulfate, as mass of sulfate consumed per mass of biodegraded contaminant [g/g].</p> required <code>util_methane (float) </code> <p>utilization factor of methane, as mass of methane generated per mass of biodegraded contaminant [g/g].</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If input parameters are incomplete or outside the valid domain.</p> <code>TypeError</code> <p>If input parameters of incorrect datatype.</p> Source code in <code>mibitrans/data/parameter_information.py</code> <pre><code>@dataclass\nclass UtilizationFactor:\n    \"\"\"Make object containing information about electron acceptor utilization factor.\n\n    Args:\n        util_oxygen (float) : utilization factor of oxygen, as mass of oxygen consumed\n            per mass of biodegraded contaminant [g/g].\n        util_nitrate (float) : utilization factor of nitrate, as mass of nitrate consumed\n            per mass of biodegraded contaminant [g/g].\n        util_ferrous_iron (float) : utilization factor of ferrous iron, as mass of ferrous iron generated\n            per mass of biodegraded contaminant [g/g].\n        util_sulfate (float) : utilization factor of sulfate, as mass of sulfate consumed\n            per mass of biodegraded contaminant [g/g].\n        util_methane (float) : utilization factor of methane, as mass of methane generated\n            per mass of biodegraded contaminant [g/g].\n\n    Raises:\n        ValueError : If input parameters are incomplete or outside the valid domain.\n        TypeError : If input parameters of incorrect datatype.\n\n    \"\"\"\n\n    util_oxygen: float\n    util_nitrate: float\n    util_ferrous_iron: float\n    util_sulfate: float\n    util_methane: float\n\n    def __setattr__(self, parameter, value):\n        \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n        if parameter != \"dictionary\":\n            validate_input_values(parameter, value)\n        super().__setattr__(parameter, value)\n\n    @property\n    def dictionary(self):\n        \"\"\"Returns utilization factors in the form of a dictionary.\"\"\"\n        return dict(\n            util_oxygen=self.util_oxygen,\n            util_nitrate=self.util_nitrate,\n            util_ferrous_iron=self.util_ferrous_iron,\n            util_sulfate=self.util_sulfate,\n            util_methane=self.util_methane,\n        )\n\n    @property\n    def array(self):\n        \"\"\"Return utilization factors in the form of an array, in order of [O2, NO3, Fe, SO4, CH4].\"\"\"\n        return np.array(\n            [self.util_oxygen, self.util_nitrate, self.util_ferrous_iron, self.util_sulfate, self.util_methane]\n        )\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameter_information.UtilizationFactor.array","title":"<code>array</code>  <code>property</code>","text":"<p>Return utilization factors in the form of an array, in order of [O2, NO3, Fe, SO4, CH4].</p>"},{"location":"reference/reference_data/#mibitrans.data.parameter_information.UtilizationFactor.dictionary","title":"<code>dictionary</code>  <code>property</code>","text":"<p>Returns utilization factors in the form of a dictionary.</p>"},{"location":"reference/reference_data/#mibitrans.data.parameter_information.UtilizationFactor.__setattr__","title":"<code>__setattr__(parameter, value)</code>","text":"<p>Override parent method to validate input when attribute is set.</p> Source code in <code>mibitrans/data/parameter_information.py</code> <pre><code>def __setattr__(self, parameter, value):\n    \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n    if parameter != \"dictionary\":\n        validate_input_values(parameter, value)\n    super().__setattr__(parameter, value)\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters","title":"<code>parameters</code>","text":"<p>Author: Jorrit Bakker.</p> <p>Module handling data input in the form of a dictionary.</p>"},{"location":"reference/reference_data/#mibitrans.data.parameters.AttenuationParameters","title":"<code>AttenuationParameters</code>  <code>dataclass</code>","text":"<p>Dataclass handling parameters related to adsorption, diffusion and degradation.</p> <p>Parameters:</p> Name Type Description Default <code>retardation (float) </code> <p>Retardation factor for transported contaminant [-]. Default is 1.</p> required <code>decay_rate (float) </code> <p>First order (linear) decay coefficient in [1/day]. Only required for linear decay models. Default is 0. Also sets corresponding half life.</p> required <code>half_life (float) </code> <p>Contaminant half life for 1st order (linear) decay, in [days]. Only required for linear decay models. Default is 0. Also sets corresponding decay_rate.</p> required <code>diffusion (float) </code> <p>Molecular diffusion [m2/day]. Default is 0.</p> required <code>bulk_density (float) </code> <p>Soil bulk density, in [g/m^3]. Optional if retardation is specified.</p> required <code>partition_coefficient (float) </code> <p>Partition coefficient of the transported contaminant to soil organic matter, in [m^3/g]. Optional if retardation is specified.</p> required <code>fraction_organic_carbon (float) </code> <p>Fraction of organic material in the soil [-]. Optional if retardation is specified.</p> required <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> <p>Methods:</p> Name Description <code>calculate_retardation </code> <p>Calculate retardation factor from bulk density, partition coefficient and fraction organic carbon when given porosity [-]</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input parameters are incomplete or outside the valid domain.</p> <code>TypeError</code> <p>If input parameters of incorrect datatype.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>@dataclass\nclass AttenuationParameters:\n    \"\"\"Dataclass handling parameters related to adsorption, diffusion and degradation.\n\n    Args:\n        retardation (float) : Retardation factor for transported contaminant [-]. Default is 1.\n        decay_rate (float) : First order (linear) decay coefficient in [1/day]. Only required for linear decay models.\n            Default is 0. Also sets corresponding half life.\n        half_life (float) : Contaminant half life for 1st order (linear) decay, in [days]. Only required for\n            linear decay models. Default is 0. Also sets corresponding decay_rate.\n        diffusion (float) : Molecular diffusion [m2/day]. Default is 0.\n        bulk_density (float) : Soil bulk density, in [g/m^3]. Optional if retardation is specified.\n        partition_coefficient (float) : Partition coefficient of the transported contaminant to soil organic matter,\n            in [m^3/g]. Optional if retardation is specified.\n        fraction_organic_carbon (float) : Fraction of organic material in the soil [-].\n            Optional if retardation is specified.\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Methods:\n        calculate_retardation : Calculate retardation factor from bulk density, partition coefficient and\n            fraction organic carbon when given porosity [-]\n\n    Raises:\n        ValueError : If input parameters are incomplete or outside the valid domain.\n        TypeError : If input parameters of incorrect datatype.\n    \"\"\"\n\n    retardation: float = 1\n    decay_rate: float = 0\n    half_life: float = 0\n    diffusion: float = 0\n    bulk_density: float = None\n    partition_coefficient: float = None\n    fraction_organic_carbon: float = None\n    verbose: bool = False\n\n    def __setattr__(self, parameter, value):\n        \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n        validate_input_values(parameter, value)\n        # Separate setattr for decay rate and half life because they should always be equivalent\n        if parameter == \"decay_rate\" or parameter == \"half_life\":\n            decay_rate, half_life = self._set_decay(parameter, value)\n            super().__setattr__(\"decay_rate\", decay_rate)\n            super().__setattr__(\"half_life\", half_life)\n        else:\n            super().__setattr__(parameter, value)\n\n    def __post_init__(self):\n        \"\"\"Check argument presence, types and domain.\"\"\"\n        self.initialized = True\n\n    def calculate_retardation(self, porosity: float):\n        \"\"\"Calculate retardation factor from soil adsorption parametrers and porosity.\"\"\"\n        self.retardation = (\n            1 + (self.bulk_density / porosity) * self.partition_coefficient * self.fraction_organic_carbon\n        )\n        if self.verbose:\n            print(f\"Retardation factor has been calculated to be {self.retardation}.\")\n\n    def _require_linear_decay(self):\n        if self.decay_rate is None and self.half_life is None:\n            raise MissingValueError(\"Linear reaction model requires decay rate or half life.\")\n\n    def _set_decay(self, parameter, value):\n        if parameter == \"decay_rate\" and (value != 0 or hasattr(self, \"initialized\")):\n            decay_rate = value\n            if value != 0:\n                half_life = np.log(2) / value\n            else:\n                half_life = 0\n        elif parameter == \"half_life\" and (value != 0 or hasattr(self, \"initialized\")):\n            half_life = value\n            if value != 0:\n                decay_rate = np.log(2) / value\n            else:\n                decay_rate = 0\n        elif parameter == \"decay_rate\":\n            decay_rate = value\n            half_life = 0\n        elif parameter == \"half_life\":\n            decay_rate = self.decay_rate\n            half_life = self.half_life\n        else:\n            decay_rate = 0\n            half_life = 0\n\n        if self.decay_rate != decay_rate and self.decay_rate != 0 and not hasattr(self, \"initialized\") and value != 0:\n            warnings.warn(\n                \"Both contaminant decay rate and half life were defined, but are not equal. \"\n                \"Value for decay rate will be used.\",\n                UserWarning,\n            )\n            half_life = np.log(2) / self.decay_rate\n            decay_rate = self.decay_rate\n\n        return decay_rate, half_life\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.AttenuationParameters.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Check argument presence, types and domain.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Check argument presence, types and domain.\"\"\"\n    self.initialized = True\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.AttenuationParameters.__setattr__","title":"<code>__setattr__(parameter, value)</code>","text":"<p>Override parent method to validate input when attribute is set.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>def __setattr__(self, parameter, value):\n    \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n    validate_input_values(parameter, value)\n    # Separate setattr for decay rate and half life because they should always be equivalent\n    if parameter == \"decay_rate\" or parameter == \"half_life\":\n        decay_rate, half_life = self._set_decay(parameter, value)\n        super().__setattr__(\"decay_rate\", decay_rate)\n        super().__setattr__(\"half_life\", half_life)\n    else:\n        super().__setattr__(parameter, value)\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.AttenuationParameters.calculate_retardation","title":"<code>calculate_retardation(porosity)</code>","text":"<p>Calculate retardation factor from soil adsorption parametrers and porosity.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>def calculate_retardation(self, porosity: float):\n    \"\"\"Calculate retardation factor from soil adsorption parametrers and porosity.\"\"\"\n    self.retardation = (\n        1 + (self.bulk_density / porosity) * self.partition_coefficient * self.fraction_organic_carbon\n    )\n    if self.verbose:\n        print(f\"Retardation factor has been calculated to be {self.retardation}.\")\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.HydrologicalParameters","title":"<code>HydrologicalParameters</code>  <code>dataclass</code>","text":"<p>Dataclass handling input of hydrological parameters.</p> <p>Parameters:</p> Name Type Description Default <code>velocity (float) </code> <p>Flow velocity in the direction of the groundwater gradient, in [m/d]. Optional if h_gradient and h_conductivity are specified.</p> required <code>h_gradient (float) </code> <p>Hydraulic gradient of the groundwater, in [m/m]. Optional if velocity is specified.</p> required <code>h_conductivity (float) </code> <p>Hydraulic conductivity of the aquifer, in [m/d]. Optional if velocity is specified.</p> required <code>porosity (float) </code> <p>Effective soil porosity [-]</p> required <code>alpha_x (float) </code> <p>The dispersivity in the x (longitudinal) direction in [m]</p> required <code>alpha_y (float) </code> <p>The dispersivity in the y (transverse-horizontal) direction in [m]</p> required <code>alpha_z (float, optional) </code> <p>The dispersivity in the z (transverse-vertical) direction in [m]. Defaults to 1e-10</p> required <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input parameters are incomplete or outside the valid domain.</p> <code>TypeError</code> <p>If input parameters of incorrect datatype.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>@dataclass\nclass HydrologicalParameters:\n    \"\"\"Dataclass handling input of hydrological parameters.\n\n    Args:\n        velocity (float) : Flow velocity in the direction of the groundwater gradient, in [m/d]. Optional if h_gradient\n            and h_conductivity are specified.\n        h_gradient (float) : Hydraulic gradient of the groundwater, in [m/m]. Optional if velocity is specified.\n        h_conductivity (float) : Hydraulic conductivity of the aquifer, in [m/d]. Optional if velocity is specified.\n        porosity (float) : Effective soil porosity [-]\n        alpha_x (float) : The dispersivity in the x (longitudinal) direction in [m]\n        alpha_y (float) : The dispersivity in the y (transverse-horizontal) direction in [m]\n        alpha_z (float, optional) : The dispersivity in the z (transverse-vertical) direction in [m]. Defaults to 1e-10\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Raises:\n        ValueError : If input parameters are incomplete or outside the valid domain.\n        TypeError : If input parameters of incorrect datatype.\n    \"\"\"\n\n    velocity: float = None\n    h_gradient: float = None\n    h_conductivity: float = None\n    porosity: float = None\n    alpha_x: float = None\n    alpha_y: float = None\n    alpha_z: float = 1e-10\n    verbose: bool = False\n\n    def __setattr__(self, parameter, value):\n        \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n        validate_input_values(parameter, value)\n        super().__setattr__(parameter, value)\n\n    def __post_init__(self):\n        \"\"\"Check argument presence, types and domain. Calculate velocity if not given.\"\"\"\n        self._validate_input_presence()\n\n        # Velocity is calculated from hydraulic gradient and conductivity when both are given.\n        if self.h_gradient and self.h_conductivity:\n            # Giving h_gradient &amp; h_conductivity more specific than giving velocity. Input velocity will be overridden.\n            if self.velocity is not None:\n                warnings.warn(\n                    \"Both velocity and h_gradient &amp; h_conductivity are defined. Value for velocity will be overridden.\",\n                    UserWarning,\n                )\n            self.velocity = self.h_gradient * self.h_conductivity / self.porosity\n            if self.verbose:\n                print(f\"Groundwater flow velocity has been calculated to be {self.velocity} m/d.\")\n\n    def _validate_input_presence(self):\n        missing_arguments = []\n        if self.porosity is None:\n            missing_arguments.append(\"porosity\")\n        if self.alpha_x is None:\n            missing_arguments.append(\"alpha_x\")\n        if self.alpha_y is None:\n            missing_arguments.append(\"alpha_y\")\n\n        if len(missing_arguments) &gt; 0:\n            raise MissingValueError(\n                f\"HydrologicalParameters missing {len(missing_arguments)} arguments: {missing_arguments}.\"\n            )\n\n        if self.velocity is None and (self.h_gradient is None or self.h_conductivity is None):\n            raise MissingValueError(\n                \"HydrologicalParameters missing required arguments: either velocity or both h_gradient and\"\n                \"h_conductivity.\"\n            )\n\n        if self.verbose:\n            print(\"All required hydrological input arguments are present.\")\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.HydrologicalParameters.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Check argument presence, types and domain. Calculate velocity if not given.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Check argument presence, types and domain. Calculate velocity if not given.\"\"\"\n    self._validate_input_presence()\n\n    # Velocity is calculated from hydraulic gradient and conductivity when both are given.\n    if self.h_gradient and self.h_conductivity:\n        # Giving h_gradient &amp; h_conductivity more specific than giving velocity. Input velocity will be overridden.\n        if self.velocity is not None:\n            warnings.warn(\n                \"Both velocity and h_gradient &amp; h_conductivity are defined. Value for velocity will be overridden.\",\n                UserWarning,\n            )\n        self.velocity = self.h_gradient * self.h_conductivity / self.porosity\n        if self.verbose:\n            print(f\"Groundwater flow velocity has been calculated to be {self.velocity} m/d.\")\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.HydrologicalParameters.__setattr__","title":"<code>__setattr__(parameter, value)</code>","text":"<p>Override parent method to validate input when attribute is set.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>def __setattr__(self, parameter, value):\n    \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n    validate_input_values(parameter, value)\n    super().__setattr__(parameter, value)\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.ModelParameters","title":"<code>ModelParameters</code>  <code>dataclass</code>","text":"<p>Dataclass handling model discretization parameters.</p> <p>Parameters:</p> Name Type Description Default <code>model_length (float) </code> <p>Model extent in the longitudinal (x) direction in [m].</p> required <code>model_width (float) </code> <p>Model extent in the transverse horizontal (y) direction in [m].</p> required <code>model_time (float) </code> <p>Model duration in [days].</p> required <code>dx (float, optional) </code> <p>Model grid discretization step size in the longitudinal (x) direction, in [m]. By default, dx = (model_length / 100).</p> required <code>dy (float, optional) </code> <p>Model grid discretization step size in the transverse horizontal (y) direction, in [m]. By default, dy = (model_width / 50).</p> required <code>dt (float, optional) </code> <p>Model time discretization step size, in [days]. By default, dt = (model_time / 10).</p> required <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input parameters are incomplete or outside the valid domain.</p> <code>ValueError</code> <p>If model dimensions are smaller than their given step size.</p> <code>TypeError</code> <p>If input parameters of incorrect datatype.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>@dataclass\nclass ModelParameters:\n    \"\"\"Dataclass handling model discretization parameters.\n\n    Args:\n        model_length (float) : Model extent in the longitudinal (x) direction in [m].\n        model_width (float) : Model extent in the transverse horizontal (y) direction in [m].\n        model_time (float) : Model duration in [days].\n        dx (float, optional) : Model grid discretization step size in the longitudinal (x) direction, in [m]. By\n            default, dx = (model_length / 100).\n        dy (float, optional) : Model grid discretization step size in the transverse horizontal (y) direction, in [m].\n            By default, dy = (model_width / 50).\n        dt (float, optional) : Model time discretization step size, in [days]. By default, dt = (model_time / 10).\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Raises:\n        ValueError : If input parameters are incomplete or outside the valid domain.\n        ValueError : If model dimensions are smaller than their given step size.\n        TypeError : If input parameters of incorrect datatype.\n\n    \"\"\"\n\n    model_length: float\n    model_width: float\n    model_time: float\n    dx: float = None\n    dy: float = None\n    dt: float = None\n    verbose: bool = False\n\n    def __setattr__(self, parameter, value):\n        \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n        validate_input_values(parameter, value)\n        super().__setattr__(parameter, value)\n        self._validate_stepsize(parameter)\n\n    def _validate_stepsize(self, parameter):\n        \"\"\"Validate if model step size is not larger than the corresponding model dimension.\"\"\"\n        match parameter:\n            case \"dx\" | \"model_length\":\n                if self.dx is not None and self.model_length is not None:\n                    if self.dx &gt; self.model_length:\n                        raise ValueError(\n                            f\"Model x-direction step size ({self.dx}) \"\n                            f\"is greater than the model length ({self.model_length}).\"\n                        )\n            case \"dy\" | \"model_width\":\n                if self.dy is not None and self.model_width is not None:\n                    if self.dy &gt; self.model_width:\n                        raise ValueError(\n                            f\"Model y-direction step size ({self.dy}) \"\n                            f\"is greater than the model width ({self.model_width}).\"\n                        )\n            case \"dt\" | \"model_time\":\n                if self.dt is not None and self.model_time is not None:\n                    if self.dt &gt; self.model_time:\n                        raise ValueError(\n                            f\"Model time step size ({self.dt}) \"\n                            f\"is greater than the total model time ({self.model_time}).\"\n                        )\n\n    def __post_init__(self):\n        \"\"\"Set model discretization parameters if not provided.\"\"\"\n        if not self.dx:\n            self.dx = self.model_length / 100\n        if not self.dy:\n            self.dy = self.model_width / 50\n        if not self.dt:\n            self.dt = self.model_time / 10\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.ModelParameters.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Set model discretization parameters if not provided.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Set model discretization parameters if not provided.\"\"\"\n    if not self.dx:\n        self.dx = self.model_length / 100\n    if not self.dy:\n        self.dy = self.model_width / 50\n    if not self.dt:\n        self.dt = self.model_time / 10\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.ModelParameters.__setattr__","title":"<code>__setattr__(parameter, value)</code>","text":"<p>Override parent method to validate input when attribute is set.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>def __setattr__(self, parameter, value):\n    \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n    validate_input_values(parameter, value)\n    super().__setattr__(parameter, value)\n    self._validate_stepsize(parameter)\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.SourceParameters","title":"<code>SourceParameters</code>  <code>dataclass</code>","text":"<p>Dataclass handling source parameters. Specifying concentrations and extent of source zone.</p> <p>Parameters:</p> Name Type Description Default <code>source_zone_boundary (np.ndarray) </code> <p>Outer boundary of each source zone, in transverse horizontal direction (y-coordiante) [m]. y=0 is at the middle of the contaminant source. Input as numpy array of length equal to the amount of source zone. Last value in the array is the limit of the source. For a source with a single source zone, only one value is required. Source is symmetrical in the x-axis.</p> required <code>source_zone_concentration (np.ndarray) </code> <p>Contaminant concentration in each source zone [g/m^3]. Input as numpy array in the same order and of the same length as specified in source_zone_boundary.</p> required <code>depth (float) </code> <p>Depth (transverse vertical or z-dimension) of the source zone in [m].</p> required <code>total_mass (float | str) </code> <p>Mass of contaminant present in source zone, either expressed in [g], or set to \u2018infinite\u2019. The latter meaning that the source mass and therefore, the source zone concentrations do not diminish over time.</p> required <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input parameters are incomplete or outside the valid domain.</p> <code>TypeError</code> <p>If input parameters of incorrect datatype.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>@dataclass\nclass SourceParameters:\n    \"\"\"Dataclass handling source parameters. Specifying concentrations and extent of source zone.\n\n    Args:\n        source_zone_boundary (np.ndarray) : Outer boundary of each source zone, in transverse horizontal direction\n            (y-coordiante) [m]. y=0 is at the middle of the contaminant source. Input as numpy array of length equal\n            to the amount of source zone. Last value in the array is the limit of the source. For a source with a single\n            source zone, only one value is required. Source is symmetrical in the x-axis.\n        source_zone_concentration (np.ndarray) : Contaminant concentration in each source zone [g/m^3]. Input as numpy\n            array in the same order and of the same length as specified in source_zone_boundary.\n        depth (float) : Depth (transverse vertical or z-dimension) of the source zone in [m].\n        total_mass (float | str) : Mass of contaminant present in source zone, either expressed in [g],\n            or set to 'infinite'. The latter meaning that the source mass and therefore, the source zone concentrations\n            do not diminish over time.\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Raises:\n        ValueError : If input parameters are incomplete or outside the valid domain.\n        TypeError : If input parameters of incorrect datatype.\n    \"\"\"\n\n    source_zone_boundary: np.ndarray = None\n    source_zone_concentration: np.ndarray = None\n    depth: float = None\n    total_mass: float | str = \"infinite\"\n    verbose: bool = False\n\n    def __setattr__(self, parameter, value):\n        \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n        validate_input_values(parameter, value)\n        if parameter == \"total_mass\" and (isinstance(value, str) or value == np.inf):\n            value = np.inf\n        super().__setattr__(parameter, value)\n        # When setting source zone boundary or concentration, and both present, check validity in respect to each other.\n        if parameter in [\"source_zone_boundary\", \"source_zone_concentration\"] and (\n            self.source_zone_boundary is not None and self.source_zone_concentration is not None\n        ):\n            boundary, concentration = validate_source_zones(self.source_zone_boundary, self.source_zone_concentration)\n            super().__setattr__(\"source_zone_boundary\", boundary)\n            super().__setattr__(\"source_zone_concentration\", concentration)\n\n    def __post_init__(self):\n        \"\"\"Check argument presence, types and domain.\"\"\"\n        self._validate_input_presence()\n\n        # Make sure naming for infinite source mass is consistent from this point onward\n        if isinstance(self.total_mass, str):\n            self.total_mass = \"infinite\"\n\n    def interpolate(self, n_zones, method):\n        \"\"\"Rediscretize source to n zones. Either through linear interpolation or using a normal distribution.\"\"\"\n        warnings.warn(\"This functionality is not implemented yet. Try again later.\")\n        return None\n\n    def visualize(self):\n        \"\"\"Plot the source zone concentration distribution.\"\"\"\n        source_zone(self)\n\n    def _validate_input_presence(self):\n        # Check if all required arguments are present\n        missing_arguments = []\n        if self.source_zone_boundary is None:\n            missing_arguments.append(\"source_zone_boundary\")\n        if self.source_zone_concentration is None:\n            missing_arguments.append(\"source_zone_concentration\")\n        if self.depth is None:\n            missing_arguments.append(\"depth\")\n\n        if len(missing_arguments) &gt; 0:\n            raise MissingValueError(\n                f\"SourceParameters missing {len(missing_arguments)} arguments: {missing_arguments}.\"\n            )\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.SourceParameters.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Check argument presence, types and domain.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Check argument presence, types and domain.\"\"\"\n    self._validate_input_presence()\n\n    # Make sure naming for infinite source mass is consistent from this point onward\n    if isinstance(self.total_mass, str):\n        self.total_mass = \"infinite\"\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.SourceParameters.__setattr__","title":"<code>__setattr__(parameter, value)</code>","text":"<p>Override parent method to validate input when attribute is set.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>def __setattr__(self, parameter, value):\n    \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n    validate_input_values(parameter, value)\n    if parameter == \"total_mass\" and (isinstance(value, str) or value == np.inf):\n        value = np.inf\n    super().__setattr__(parameter, value)\n    # When setting source zone boundary or concentration, and both present, check validity in respect to each other.\n    if parameter in [\"source_zone_boundary\", \"source_zone_concentration\"] and (\n        self.source_zone_boundary is not None and self.source_zone_concentration is not None\n    ):\n        boundary, concentration = validate_source_zones(self.source_zone_boundary, self.source_zone_concentration)\n        super().__setattr__(\"source_zone_boundary\", boundary)\n        super().__setattr__(\"source_zone_concentration\", concentration)\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.SourceParameters.interpolate","title":"<code>interpolate(n_zones, method)</code>","text":"<p>Rediscretize source to n zones. Either through linear interpolation or using a normal distribution.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>def interpolate(self, n_zones, method):\n    \"\"\"Rediscretize source to n zones. Either through linear interpolation or using a normal distribution.\"\"\"\n    warnings.warn(\"This functionality is not implemented yet. Try again later.\")\n    return None\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.SourceParameters.visualize","title":"<code>visualize()</code>","text":"<p>Plot the source zone concentration distribution.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>def visualize(self):\n    \"\"\"Plot the source zone concentration distribution.\"\"\"\n    source_zone(self)\n</code></pre>"},{"location":"reference/reference_transport/","title":"<code>mibitrans.transport</code> API reference","text":""},{"location":"reference/reference_transport/#mibitrans.transport.model_parent","title":"<code>model_parent</code>","text":""},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results","title":"<code>Results</code>","text":"<p>Object that holds model results and input parameters for individual runs.</p> Source code in <code>mibitrans/transport/model_parent.py</code> <pre><code>class Results:\n    \"\"\"Object that holds model results and input parameters for individual runs.\"\"\"\n\n    def __init__(self, model):\n        \"\"\"Records input parameters and resulting output of given model run.\n\n        Args:\n            model (Transport3D): Model object from which to initialize results. Should be child class of Transport3D.\n\n        Properties:\n            model_type (Transport3D) : Class instance of model used to generate results.\n            short_description (str) : Short description of model.\n            x (np.ndarray) : Numpy array with model x (longitudinal direction) discretization, corresponding to\n                model_parameters, with distance in [m].\n            y (np.ndarray) : Numpy array with model y (transverse horizontal direction) discretization, corresponding to\n                model_parameters, with distance in [m].\n            t (np.ndarray) : Numpy array with model t (time) discretization, corresponding to\n                model_parameters, with time in [days].\n            hydrological_parameters (HydrologicalParameters) : Dataclass holding the hydrological parameters used to\n                run the model.\n            attenuation_parameters (AttenuationParameters) : Dataclass holding the attenuation parameters used to run\n                the model.\n            source_parameters (SourceParameters) : Dataclass holding the source parameters used to run the model.\n            model_parameters (ModelParameters): Dataclass holding the model parameters used to run the model.\n            electron_acceptors (ElectronAcceptors): Dataclass holding the electron acceptor concentrations used to run\n                the model. Only for instant reaction, None for other models.\n            utilization_factor (UtilizationFactor): Dataclass holding the electron acceptor utilization factors used to\n                run the model. Only for instant reaction, None for other models.\n            mode (str) : Model mode of the used model. Either 'linear' or 'instant_reaction'\n            rv (float) : Retarded flow velocity, as v / R [m/day].\n            k_source (float) : Source depletion rate [1/days]. For infinite source mass, k_source = 0, and therefore, no\n                source depletion takes place.\n            c_source (np.ndarray) : Initial nett source zone concentrations. For multiple source zones, nett\n                concentration in nth source zone is original concentration minus concentration in source zone n - 1. For\n                instant reaction model, the biodegradation capacity is added to the outermost source zone.\n            biodegradation_capacity (float) : Maximum capacity of biodegradation taking place, based on electron\n                acceptor concentrations and utilization factor.\n            cxyt (np.ndarray) : Three-dimensional numpy array with concentrations for all x, y and t positions. Indexed\n             as cxyt[t,y,x]. In [g/m3].\n            relative_cxyt (np.ndarray) : Three-dimensional numpy array with relative concentrations for all x, y and t\n                positions. Compared to maximum source zone concentrations.\n            cxyt_noBC (np.ndarray) : Three-dimensional numpy array with concentrations for all x, y and t of instant\n                reaction models, without subtracting the biodegradation capacity, in [g/m3].\n            input_parameters (dict) : Dictionary of input parameter dataclasses for the model. Does not include instant\n                reaction parameters.\n\n        Methods:\n            centerline : Plot center of contaminant plume, at a specified time and y position.\n            transverse : Plot concentration distribution as a line horizontal transverse to the plume extent.\n            breakthrough : Plot contaminant breakthrough curve at given x and y position in model domain.\n            plume_2d : Plot contaminant plume as a 2D colormesh, at a specified time.\n            plume_3d : Plot contaminant plume as a 3D surface, at a specified time.\n            mass_balance : Return a mass balance object with source and plume characteristics at given time(s).\n        \"\"\"\n        self._model_type = model.__class__\n        self._short_description = model.short_description\n        self._x = model.x\n        self._y = model.y\n        self._t = model.t\n\n        # All properties of Transport3D that are objects should be copied; if not copied, changing them in the class\n        # object where they originated will also change them here, which is not the intended behaviour.\n        self._hydrological_parameters = copy.copy(model.hydrological_parameters)\n        self._attenuation_parameters = copy.copy(model.attenuation_parameters)\n        self._source_parameters = copy.copy(model.source_parameters)\n        self._model_parameters = copy.copy(model.model_parameters)\n        self._electron_acceptors = copy.copy(model._electron_acceptors)\n        self._utilization_factor = copy.copy(model._utilization_factor)\n\n        self._mode = model.mode\n        self._rv = model.rv\n        self._k_source = model.k_source\n        self._c_source = model.c_source\n        self._biodegradation_capacity = model.biodegradation_capacity\n\n        self._cxyt = model.cxyt\n        self._relative_cxyt = model.relative_cxyt\n        self._cxyt_noBC = model.cxyt_noBC\n\n    @property\n    def model_type(self):\n        \"\"\"Class object of the model that generated the results.\"\"\"\n        return self._model_type\n\n    @property\n    def short_description(self):\n        \"\"\"Short description of the model that generated the results.\"\"\"\n        return self._short_description\n\n    @property\n    def x(self):\n        \"\"\"Model x discretization array.\"\"\"\n        return self._x\n\n    @property\n    def y(self):\n        \"\"\"Model y discretization array.\"\"\"\n        return self._y\n\n    @property\n    def t(self):\n        \"\"\"Model t discretization array.\"\"\"\n        return self._t\n\n    @property\n    def hydrological_parameters(self):\n        \"\"\"Hydrological parameters of the model used for the results.\"\"\"\n        return self._hydrological_parameters\n\n    @property\n    def attenuation_parameters(self):\n        \"\"\"Attenuation parameters of the model used for the results.\"\"\"\n        return self._attenuation_parameters\n\n    @property\n    def source_parameters(self):\n        \"\"\"Source parameters of the model used for the results.\"\"\"\n        return self._source_parameters\n\n    @property\n    def model_parameters(self):\n        \"\"\"Space-time discretization parameters of the model used for the results.\"\"\"\n        return self._model_parameters\n\n    @property\n    def electron_acceptors(self):\n        \"\"\"Electron acceptor/byproduct concentrations of the model used for the results.\"\"\"\n        return self._electron_acceptors\n\n    @property\n    def utilization_factor(self):\n        \"\"\"Utilization factor of the model used for the results.\"\"\"\n        return self._utilization_factor\n\n    @property\n    def mode(self):\n        \"\"\"Model mode used for running the model.\"\"\"\n        return self._mode\n\n    @property\n    def rv(self):\n        \"\"\"Retarded flow velocity used in the model.\"\"\"\n        return self._rv\n\n    @property\n    def k_source(self):\n        \"\"\"Source depletion rate used in the model.\"\"\"\n        return self._k_source\n\n    @property\n    def c_source(self):\n        \"\"\"Nett source zone concentration used in the model.\"\"\"\n        return self._c_source\n\n    @property\n    def biodegradation_capacity(self):\n        \"\"\"Biodegradation capacity of the model used for the results. Only for instant reaction models.\"\"\"\n        return self._biodegradation_capacity\n\n    @property\n    def cxyt(self):\n        \"\"\"Modelled concentration for all x, y and t, using the input parameters present in this object.\"\"\"\n        return self._cxyt\n\n    @property\n    def relative_cxyt(self):\n        \"\"\"Modelled concentration for all x, y and t, divided by the maximum source zone concentration.\"\"\"\n        return self._relative_cxyt\n\n    @property\n    def cxyt_noBC(self):\n        \"\"\"Concentration in domain without subtracting biodegradation capacity, in the instant reaction model.\"\"\"\n        return self._cxyt_noBC\n\n    @property\n    def input_parameters(self):\n        \"\"\"Return the input arguments for the model in the form of a dictionary, based on current values.\"\"\"\n        return dict(\n            hydrological_parameters=self.hydrological_parameters,\n            attenuation_parameters=self.attenuation_parameters,\n            source_parameters=self.source_parameters,\n            model_parameters=self.model_parameters,\n        )\n\n    def centerline(self, y_position=0, time=None, relative_concentration=False, animate=False, **kwargs):\n        \"\"\"Plot center of contaminant plume of this model, at a specified time and y position.\n\n        Args:\n            y_position (float, optional): y-position across the plume (transverse horizontal direction) for the plot.\n                By default, the center of the plume at y=0 is plotted.\n            time (float, optional): Point of time for the plot. Will show the closest time step to given value.\n                By default, last point in time is plotted.\n            relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum\n                source zone concentrations at t=0. By default, absolute concentrations are shown.\n            animate (bool, optional): If True, animation of contaminant plume until given time is shown. Default is\n                False.\n            **kwargs : Arguments to be passed to plt.plot().\n\n        \"\"\"\n        if animate:\n            anim = pline.centerline(\n                self,\n                y_position=y_position,\n                time=time,\n                relative_concentration=relative_concentration,\n                animate=animate,\n                **kwargs,\n            )\n            return anim\n        else:\n            pline.centerline(\n                self,\n                y_position=y_position,\n                time=time,\n                relative_concentration=relative_concentration,\n                animate=animate,\n                **kwargs,\n            )\n            return None\n\n    def transverse(self, x_position, time=None, relative_concentration=False, animate=False, **kwargs):\n        \"\"\"Plot concentration distribution as a line horizontal transverse to the plume extent.\n\n        Args:\n            x_position : x-position along the plume (longitudinal direction) for the plot.\n            time (float): Point of time for the plot. Will show the closest time step to given value.\n                By default, last point in time is plotted.\n            relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum\n                source zone concentrations at t=0. By default, absolute concentrations are shown.\n            animate (bool, optional): If True, animation of contaminant plume until given time is shown. Default is\n                False.\n            **kwargs : Arguments to be passed to plt.plot().\n        \"\"\"\n        if animate:\n            anim = pline.transverse(\n                self,\n                x_position=x_position,\n                time=time,\n                relative_concentration=relative_concentration,\n                animate=animate,\n                **kwargs,\n            )\n            return anim\n        else:\n            pline.transverse(\n                self,\n                x_position=x_position,\n                time=time,\n                relative_concentration=relative_concentration,\n                animate=animate,\n                **kwargs,\n            )\n            return None\n\n    def breakthrough(self, x_position, y_position=0, relative_concentration=False, animate=False, **kwargs):\n        \"\"\"Plot contaminant breakthrough curve at given x and y position in model domain.\n\n        Args:\n            x_position : x-position along the plume (longitudinal direction).\n            y_position : y-position across the plume (transverse horizontal direction).\n                By default, at the center of the plume (at y=0).\n            relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum\n                source zone concentrations at t=0. By default, absolute concentrations are shown.\n            animate (bool, optional): If True, animation of contaminant plume until given time is shown. Default is\n                False.\n            **kwargs : Arguments to be passed to plt.plot().\n        \"\"\"\n        if animate:\n            anim = pline.breakthrough(\n                self,\n                x_position=x_position,\n                y_position=y_position,\n                relative_concentration=relative_concentration,\n                animate=animate,\n                **kwargs,\n            )\n            return anim\n        else:\n            pline.breakthrough(\n                self,\n                x_position=x_position,\n                y_position=y_position,\n                relative_concentration=relative_concentration,\n                animate=animate,\n                **kwargs,\n            )\n            return None\n\n    def plume_2d(self, time=None, relative_concentration=False, animate=False, **kwargs):\n        \"\"\"Plot contaminant plume as a 2D colormesh, at a specified time.\n\n        Args:\n            time (float): Point of time for the plot. Will show the closest time step to given value.\n                By default, last point in time is plotted.\n            relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum\n                source zone concentrations at t=0. By default, absolute concentrations are shown.\n            animate (bool, optional): If True, animation of contaminant plume until given time is shown. Default is\n                False.\n            **kwargs : Arguments to be passed to plt.pcolormesh().\n\n        Returns a matrix plot of the input plume as object.\n        \"\"\"\n        anim = psurf.plume_2d(self, time=time, relative_concentration=relative_concentration, animate=animate, **kwargs)\n        return anim\n\n    def plume_3d(self, time=None, relative_concentration=False, animate=False, **kwargs):\n        \"\"\"Plot contaminant plume as a 3D surface, at a specified time.\n\n        Args:\n            time (float): Point of time for the plot. Will show the closest time step to given value.\n                By default, last point in time is plotted.\n            relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum\n                source zone concentrations at t=0. By default, absolute concentrations are shown.\n            animate (bool, optional): If True, animation of contaminant plume until given time is shown. Default is\n                False.\n            **kwargs : Arguments to be passed to plt.plot_surface().\n\n        Returns:\n            ax (matplotlib.axes._axes.Axes) : Matplotlib Axes object of plume plot.\n                or if animate == True\n            anim (matplotib.animation.FuncAnimation) : Matplotlib FuncAnimation object of plume plot.\n        \"\"\"\n        ax_or_anim = psurf.plume_3d(\n            self, time=time, relative_concentration=relative_concentration, animate=animate, **kwargs\n        )\n        return ax_or_anim\n\n    def mass_balance(self, time=\"all\", verbose=False):\n        \"\"\"Return a mass balance object with source and plume characteristics at given time(s).\n\n        Args:\n            time (float | str): Time at which to initially calculate the mass balance. Either as a value between 0 and\n                model end time. Or as 'all', which will calculate mass balance attributes for each time step as arrays.\n            verbose (bool, optional): Verbose mode. Defaults to False.\n\n        Returns:\n            mass_balance_object: Object of the MassBalance class. Output is accessed through object properties. Can be\n                called to change the time of the mass balance.\n\n        The mass balance object has the following properties:\n            plume_mass: Mass of the contaminant plume inside the model extent, at the given time(s), in [g].\n            source_mass: Mass of the contaminant source at the given time(s), in [g]. No values are given for models\n                with infinite source mass.\n            delta_source: Difference in mass between contaminant source at given time and source at t = 0, in [g].\n            degraded_mass: Mass of plume contaminant degradation at the given time(s), compared to a model without\n                degradation, in [g]. Has no value if model does not consider degradation.\n            model_without_degradation: Object of model without degradation. Has no value if model does not consider\n                degradation.\n            instant_reaction_degraded_mass(self): Difference in plume mass instant reaction with and without\n                biodegradation capacity subtracted, in [g].\n            electron_acceptor_change(self): Change in electron acceptor/byproduct masses at the given time(s), in [g].\n                Only for instant reaction.\n        \"\"\"\n        return MassBalance(self, time, verbose)\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.attenuation_parameters","title":"<code>attenuation_parameters</code>  <code>property</code>","text":"<p>Attenuation parameters of the model used for the results.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.biodegradation_capacity","title":"<code>biodegradation_capacity</code>  <code>property</code>","text":"<p>Biodegradation capacity of the model used for the results. Only for instant reaction models.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.c_source","title":"<code>c_source</code>  <code>property</code>","text":"<p>Nett source zone concentration used in the model.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.cxyt","title":"<code>cxyt</code>  <code>property</code>","text":"<p>Modelled concentration for all x, y and t, using the input parameters present in this object.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.cxyt_noBC","title":"<code>cxyt_noBC</code>  <code>property</code>","text":"<p>Concentration in domain without subtracting biodegradation capacity, in the instant reaction model.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.electron_acceptors","title":"<code>electron_acceptors</code>  <code>property</code>","text":"<p>Electron acceptor/byproduct concentrations of the model used for the results.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.hydrological_parameters","title":"<code>hydrological_parameters</code>  <code>property</code>","text":"<p>Hydrological parameters of the model used for the results.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.input_parameters","title":"<code>input_parameters</code>  <code>property</code>","text":"<p>Return the input arguments for the model in the form of a dictionary, based on current values.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.k_source","title":"<code>k_source</code>  <code>property</code>","text":"<p>Source depletion rate used in the model.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.mode","title":"<code>mode</code>  <code>property</code>","text":"<p>Model mode used for running the model.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.model_parameters","title":"<code>model_parameters</code>  <code>property</code>","text":"<p>Space-time discretization parameters of the model used for the results.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.model_type","title":"<code>model_type</code>  <code>property</code>","text":"<p>Class object of the model that generated the results.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.relative_cxyt","title":"<code>relative_cxyt</code>  <code>property</code>","text":"<p>Modelled concentration for all x, y and t, divided by the maximum source zone concentration.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.rv","title":"<code>rv</code>  <code>property</code>","text":"<p>Retarded flow velocity used in the model.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.short_description","title":"<code>short_description</code>  <code>property</code>","text":"<p>Short description of the model that generated the results.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.source_parameters","title":"<code>source_parameters</code>  <code>property</code>","text":"<p>Source parameters of the model used for the results.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.t","title":"<code>t</code>  <code>property</code>","text":"<p>Model t discretization array.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.utilization_factor","title":"<code>utilization_factor</code>  <code>property</code>","text":"<p>Utilization factor of the model used for the results.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.x","title":"<code>x</code>  <code>property</code>","text":"<p>Model x discretization array.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.y","title":"<code>y</code>  <code>property</code>","text":"<p>Model y discretization array.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.__init__","title":"<code>__init__(model)</code>","text":"<p>Records input parameters and resulting output of given model run.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Transport3D</code> <p>Model object from which to initialize results. Should be child class of Transport3D.</p> required Properties <p>model_type (Transport3D) : Class instance of model used to generate results. short_description (str) : Short description of model. x (np.ndarray) : Numpy array with model x (longitudinal direction) discretization, corresponding to     model_parameters, with distance in [m]. y (np.ndarray) : Numpy array with model y (transverse horizontal direction) discretization, corresponding to     model_parameters, with distance in [m]. t (np.ndarray) : Numpy array with model t (time) discretization, corresponding to     model_parameters, with time in [days]. hydrological_parameters (HydrologicalParameters) : Dataclass holding the hydrological parameters used to     run the model. attenuation_parameters (AttenuationParameters) : Dataclass holding the attenuation parameters used to run     the model. source_parameters (SourceParameters) : Dataclass holding the source parameters used to run the model. model_parameters (ModelParameters): Dataclass holding the model parameters used to run the model. electron_acceptors (ElectronAcceptors): Dataclass holding the electron acceptor concentrations used to run     the model. Only for instant reaction, None for other models. utilization_factor (UtilizationFactor): Dataclass holding the electron acceptor utilization factors used to     run the model. Only for instant reaction, None for other models. mode (str) : Model mode of the used model. Either \u2018linear\u2019 or \u2018instant_reaction\u2019 rv (float) : Retarded flow velocity, as v / R [m/day]. k_source (float) : Source depletion rate [1/days]. For infinite source mass, k_source = 0, and therefore, no     source depletion takes place. c_source (np.ndarray) : Initial nett source zone concentrations. For multiple source zones, nett     concentration in nth source zone is original concentration minus concentration in source zone n - 1. For     instant reaction model, the biodegradation capacity is added to the outermost source zone. biodegradation_capacity (float) : Maximum capacity of biodegradation taking place, based on electron     acceptor concentrations and utilization factor. cxyt (np.ndarray) : Three-dimensional numpy array with concentrations for all x, y and t positions. Indexed  as cxyt[t,y,x]. In [g/m3]. relative_cxyt (np.ndarray) : Three-dimensional numpy array with relative concentrations for all x, y and t     positions. Compared to maximum source zone concentrations. cxyt_noBC (np.ndarray) : Three-dimensional numpy array with concentrations for all x, y and t of instant     reaction models, without subtracting the biodegradation capacity, in [g/m3]. input_parameters (dict) : Dictionary of input parameter dataclasses for the model. Does not include instant     reaction parameters.</p> <p>Functions:</p> Name Description <code>centerline </code> <p>Plot center of contaminant plume, at a specified time and y position.</p> <code>transverse </code> <p>Plot concentration distribution as a line horizontal transverse to the plume extent.</p> <code>breakthrough </code> <p>Plot contaminant breakthrough curve at given x and y position in model domain.</p> <code>plume_2d </code> <p>Plot contaminant plume as a 2D colormesh, at a specified time.</p> <code>plume_3d </code> <p>Plot contaminant plume as a 3D surface, at a specified time.</p> <code>mass_balance </code> <p>Return a mass balance object with source and plume characteristics at given time(s).</p> Source code in <code>mibitrans/transport/model_parent.py</code> <pre><code>def __init__(self, model):\n    \"\"\"Records input parameters and resulting output of given model run.\n\n    Args:\n        model (Transport3D): Model object from which to initialize results. Should be child class of Transport3D.\n\n    Properties:\n        model_type (Transport3D) : Class instance of model used to generate results.\n        short_description (str) : Short description of model.\n        x (np.ndarray) : Numpy array with model x (longitudinal direction) discretization, corresponding to\n            model_parameters, with distance in [m].\n        y (np.ndarray) : Numpy array with model y (transverse horizontal direction) discretization, corresponding to\n            model_parameters, with distance in [m].\n        t (np.ndarray) : Numpy array with model t (time) discretization, corresponding to\n            model_parameters, with time in [days].\n        hydrological_parameters (HydrologicalParameters) : Dataclass holding the hydrological parameters used to\n            run the model.\n        attenuation_parameters (AttenuationParameters) : Dataclass holding the attenuation parameters used to run\n            the model.\n        source_parameters (SourceParameters) : Dataclass holding the source parameters used to run the model.\n        model_parameters (ModelParameters): Dataclass holding the model parameters used to run the model.\n        electron_acceptors (ElectronAcceptors): Dataclass holding the electron acceptor concentrations used to run\n            the model. Only for instant reaction, None for other models.\n        utilization_factor (UtilizationFactor): Dataclass holding the electron acceptor utilization factors used to\n            run the model. Only for instant reaction, None for other models.\n        mode (str) : Model mode of the used model. Either 'linear' or 'instant_reaction'\n        rv (float) : Retarded flow velocity, as v / R [m/day].\n        k_source (float) : Source depletion rate [1/days]. For infinite source mass, k_source = 0, and therefore, no\n            source depletion takes place.\n        c_source (np.ndarray) : Initial nett source zone concentrations. For multiple source zones, nett\n            concentration in nth source zone is original concentration minus concentration in source zone n - 1. For\n            instant reaction model, the biodegradation capacity is added to the outermost source zone.\n        biodegradation_capacity (float) : Maximum capacity of biodegradation taking place, based on electron\n            acceptor concentrations and utilization factor.\n        cxyt (np.ndarray) : Three-dimensional numpy array with concentrations for all x, y and t positions. Indexed\n         as cxyt[t,y,x]. In [g/m3].\n        relative_cxyt (np.ndarray) : Three-dimensional numpy array with relative concentrations for all x, y and t\n            positions. Compared to maximum source zone concentrations.\n        cxyt_noBC (np.ndarray) : Three-dimensional numpy array with concentrations for all x, y and t of instant\n            reaction models, without subtracting the biodegradation capacity, in [g/m3].\n        input_parameters (dict) : Dictionary of input parameter dataclasses for the model. Does not include instant\n            reaction parameters.\n\n    Methods:\n        centerline : Plot center of contaminant plume, at a specified time and y position.\n        transverse : Plot concentration distribution as a line horizontal transverse to the plume extent.\n        breakthrough : Plot contaminant breakthrough curve at given x and y position in model domain.\n        plume_2d : Plot contaminant plume as a 2D colormesh, at a specified time.\n        plume_3d : Plot contaminant plume as a 3D surface, at a specified time.\n        mass_balance : Return a mass balance object with source and plume characteristics at given time(s).\n    \"\"\"\n    self._model_type = model.__class__\n    self._short_description = model.short_description\n    self._x = model.x\n    self._y = model.y\n    self._t = model.t\n\n    # All properties of Transport3D that are objects should be copied; if not copied, changing them in the class\n    # object where they originated will also change them here, which is not the intended behaviour.\n    self._hydrological_parameters = copy.copy(model.hydrological_parameters)\n    self._attenuation_parameters = copy.copy(model.attenuation_parameters)\n    self._source_parameters = copy.copy(model.source_parameters)\n    self._model_parameters = copy.copy(model.model_parameters)\n    self._electron_acceptors = copy.copy(model._electron_acceptors)\n    self._utilization_factor = copy.copy(model._utilization_factor)\n\n    self._mode = model.mode\n    self._rv = model.rv\n    self._k_source = model.k_source\n    self._c_source = model.c_source\n    self._biodegradation_capacity = model.biodegradation_capacity\n\n    self._cxyt = model.cxyt\n    self._relative_cxyt = model.relative_cxyt\n    self._cxyt_noBC = model.cxyt_noBC\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.breakthrough","title":"<code>breakthrough(x_position, y_position=0, relative_concentration=False, animate=False, **kwargs)</code>","text":"<p>Plot contaminant breakthrough curve at given x and y position in model domain.</p> <p>Parameters:</p> Name Type Description Default <code>x_position </code> <p>x-position along the plume (longitudinal direction).</p> required <code>y_position </code> <p>y-position across the plume (transverse horizontal direction). By default, at the center of the plume (at y=0).</p> required <code>relative_concentration (bool, optional) </code> <p>If set to True, will plot concentrations relative to maximum source zone concentrations at t=0. By default, absolute concentrations are shown.</p> required <code>animate</code> <code>bool</code> <p>If True, animation of contaminant plume until given time is shown. Default is False.</p> <code>False</code> <code>**kwargs </code> <p>Arguments to be passed to plt.plot().</p> required Source code in <code>mibitrans/transport/model_parent.py</code> <pre><code>def breakthrough(self, x_position, y_position=0, relative_concentration=False, animate=False, **kwargs):\n    \"\"\"Plot contaminant breakthrough curve at given x and y position in model domain.\n\n    Args:\n        x_position : x-position along the plume (longitudinal direction).\n        y_position : y-position across the plume (transverse horizontal direction).\n            By default, at the center of the plume (at y=0).\n        relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum\n            source zone concentrations at t=0. By default, absolute concentrations are shown.\n        animate (bool, optional): If True, animation of contaminant plume until given time is shown. Default is\n            False.\n        **kwargs : Arguments to be passed to plt.plot().\n    \"\"\"\n    if animate:\n        anim = pline.breakthrough(\n            self,\n            x_position=x_position,\n            y_position=y_position,\n            relative_concentration=relative_concentration,\n            animate=animate,\n            **kwargs,\n        )\n        return anim\n    else:\n        pline.breakthrough(\n            self,\n            x_position=x_position,\n            y_position=y_position,\n            relative_concentration=relative_concentration,\n            animate=animate,\n            **kwargs,\n        )\n        return None\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.centerline","title":"<code>centerline(y_position=0, time=None, relative_concentration=False, animate=False, **kwargs)</code>","text":"<p>Plot center of contaminant plume of this model, at a specified time and y position.</p> <p>Parameters:</p> Name Type Description Default <code>y_position</code> <code>float</code> <p>y-position across the plume (transverse horizontal direction) for the plot. By default, the center of the plume at y=0 is plotted.</p> <code>0</code> <code>time</code> <code>float</code> <p>Point of time for the plot. Will show the closest time step to given value. By default, last point in time is plotted.</p> <code>None</code> <code>relative_concentration (bool, optional) </code> <p>If set to True, will plot concentrations relative to maximum source zone concentrations at t=0. By default, absolute concentrations are shown.</p> required <code>animate</code> <code>bool</code> <p>If True, animation of contaminant plume until given time is shown. Default is False.</p> <code>False</code> <code>**kwargs </code> <p>Arguments to be passed to plt.plot().</p> required Source code in <code>mibitrans/transport/model_parent.py</code> <pre><code>def centerline(self, y_position=0, time=None, relative_concentration=False, animate=False, **kwargs):\n    \"\"\"Plot center of contaminant plume of this model, at a specified time and y position.\n\n    Args:\n        y_position (float, optional): y-position across the plume (transverse horizontal direction) for the plot.\n            By default, the center of the plume at y=0 is plotted.\n        time (float, optional): Point of time for the plot. Will show the closest time step to given value.\n            By default, last point in time is plotted.\n        relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum\n            source zone concentrations at t=0. By default, absolute concentrations are shown.\n        animate (bool, optional): If True, animation of contaminant plume until given time is shown. Default is\n            False.\n        **kwargs : Arguments to be passed to plt.plot().\n\n    \"\"\"\n    if animate:\n        anim = pline.centerline(\n            self,\n            y_position=y_position,\n            time=time,\n            relative_concentration=relative_concentration,\n            animate=animate,\n            **kwargs,\n        )\n        return anim\n    else:\n        pline.centerline(\n            self,\n            y_position=y_position,\n            time=time,\n            relative_concentration=relative_concentration,\n            animate=animate,\n            **kwargs,\n        )\n        return None\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.mass_balance","title":"<code>mass_balance(time='all', verbose=False)</code>","text":"<p>Return a mass balance object with source and plume characteristics at given time(s).</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float | str</code> <p>Time at which to initially calculate the mass balance. Either as a value between 0 and model end time. Or as \u2018all\u2019, which will calculate mass balance attributes for each time step as arrays.</p> <code>'all'</code> <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>mass_balance_object</code> <p>Object of the MassBalance class. Output is accessed through object properties. Can be called to change the time of the mass balance.</p> The mass balance object has the following properties <p>plume_mass: Mass of the contaminant plume inside the model extent, at the given time(s), in [g]. source_mass: Mass of the contaminant source at the given time(s), in [g]. No values are given for models     with infinite source mass. delta_source: Difference in mass between contaminant source at given time and source at t = 0, in [g]. degraded_mass: Mass of plume contaminant degradation at the given time(s), compared to a model without     degradation, in [g]. Has no value if model does not consider degradation. model_without_degradation: Object of model without degradation. Has no value if model does not consider     degradation. instant_reaction_degraded_mass(self): Difference in plume mass instant reaction with and without     biodegradation capacity subtracted, in [g]. electron_acceptor_change(self): Change in electron acceptor/byproduct masses at the given time(s), in [g].     Only for instant reaction.</p> Source code in <code>mibitrans/transport/model_parent.py</code> <pre><code>def mass_balance(self, time=\"all\", verbose=False):\n    \"\"\"Return a mass balance object with source and plume characteristics at given time(s).\n\n    Args:\n        time (float | str): Time at which to initially calculate the mass balance. Either as a value between 0 and\n            model end time. Or as 'all', which will calculate mass balance attributes for each time step as arrays.\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Returns:\n        mass_balance_object: Object of the MassBalance class. Output is accessed through object properties. Can be\n            called to change the time of the mass balance.\n\n    The mass balance object has the following properties:\n        plume_mass: Mass of the contaminant plume inside the model extent, at the given time(s), in [g].\n        source_mass: Mass of the contaminant source at the given time(s), in [g]. No values are given for models\n            with infinite source mass.\n        delta_source: Difference in mass between contaminant source at given time and source at t = 0, in [g].\n        degraded_mass: Mass of plume contaminant degradation at the given time(s), compared to a model without\n            degradation, in [g]. Has no value if model does not consider degradation.\n        model_without_degradation: Object of model without degradation. Has no value if model does not consider\n            degradation.\n        instant_reaction_degraded_mass(self): Difference in plume mass instant reaction with and without\n            biodegradation capacity subtracted, in [g].\n        electron_acceptor_change(self): Change in electron acceptor/byproduct masses at the given time(s), in [g].\n            Only for instant reaction.\n    \"\"\"\n    return MassBalance(self, time, verbose)\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.plume_2d","title":"<code>plume_2d(time=None, relative_concentration=False, animate=False, **kwargs)</code>","text":"<p>Plot contaminant plume as a 2D colormesh, at a specified time.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>Point of time for the plot. Will show the closest time step to given value. By default, last point in time is plotted.</p> <code>None</code> <code>relative_concentration (bool, optional) </code> <p>If set to True, will plot concentrations relative to maximum source zone concentrations at t=0. By default, absolute concentrations are shown.</p> required <code>animate</code> <code>bool</code> <p>If True, animation of contaminant plume until given time is shown. Default is False.</p> <code>False</code> <code>**kwargs </code> <p>Arguments to be passed to plt.pcolormesh().</p> required <p>Returns a matrix plot of the input plume as object.</p> Source code in <code>mibitrans/transport/model_parent.py</code> <pre><code>def plume_2d(self, time=None, relative_concentration=False, animate=False, **kwargs):\n    \"\"\"Plot contaminant plume as a 2D colormesh, at a specified time.\n\n    Args:\n        time (float): Point of time for the plot. Will show the closest time step to given value.\n            By default, last point in time is plotted.\n        relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum\n            source zone concentrations at t=0. By default, absolute concentrations are shown.\n        animate (bool, optional): If True, animation of contaminant plume until given time is shown. Default is\n            False.\n        **kwargs : Arguments to be passed to plt.pcolormesh().\n\n    Returns a matrix plot of the input plume as object.\n    \"\"\"\n    anim = psurf.plume_2d(self, time=time, relative_concentration=relative_concentration, animate=animate, **kwargs)\n    return anim\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.plume_3d","title":"<code>plume_3d(time=None, relative_concentration=False, animate=False, **kwargs)</code>","text":"<p>Plot contaminant plume as a 3D surface, at a specified time.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>Point of time for the plot. Will show the closest time step to given value. By default, last point in time is plotted.</p> <code>None</code> <code>relative_concentration (bool, optional) </code> <p>If set to True, will plot concentrations relative to maximum source zone concentrations at t=0. By default, absolute concentrations are shown.</p> required <code>animate</code> <code>bool</code> <p>If True, animation of contaminant plume until given time is shown. Default is False.</p> <code>False</code> <code>**kwargs </code> <p>Arguments to be passed to plt.plot_surface().</p> required <p>Returns:</p> Type Description <p>ax (matplotlib.axes._axes.Axes) : Matplotlib Axes object of plume plot. or if animate == True</p> <p>anim (matplotib.animation.FuncAnimation) : Matplotlib FuncAnimation object of plume plot.</p> Source code in <code>mibitrans/transport/model_parent.py</code> <pre><code>def plume_3d(self, time=None, relative_concentration=False, animate=False, **kwargs):\n    \"\"\"Plot contaminant plume as a 3D surface, at a specified time.\n\n    Args:\n        time (float): Point of time for the plot. Will show the closest time step to given value.\n            By default, last point in time is plotted.\n        relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum\n            source zone concentrations at t=0. By default, absolute concentrations are shown.\n        animate (bool, optional): If True, animation of contaminant plume until given time is shown. Default is\n            False.\n        **kwargs : Arguments to be passed to plt.plot_surface().\n\n    Returns:\n        ax (matplotlib.axes._axes.Axes) : Matplotlib Axes object of plume plot.\n            or if animate == True\n        anim (matplotib.animation.FuncAnimation) : Matplotlib FuncAnimation object of plume plot.\n    \"\"\"\n    ax_or_anim = psurf.plume_3d(\n        self, time=time, relative_concentration=relative_concentration, animate=animate, **kwargs\n    )\n    return ax_or_anim\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.transverse","title":"<code>transverse(x_position, time=None, relative_concentration=False, animate=False, **kwargs)</code>","text":"<p>Plot concentration distribution as a line horizontal transverse to the plume extent.</p> <p>Parameters:</p> Name Type Description Default <code>x_position </code> <p>x-position along the plume (longitudinal direction) for the plot.</p> required <code>time</code> <code>float</code> <p>Point of time for the plot. Will show the closest time step to given value. By default, last point in time is plotted.</p> <code>None</code> <code>relative_concentration (bool, optional) </code> <p>If set to True, will plot concentrations relative to maximum source zone concentrations at t=0. By default, absolute concentrations are shown.</p> required <code>animate</code> <code>bool</code> <p>If True, animation of contaminant plume until given time is shown. Default is False.</p> <code>False</code> <code>**kwargs </code> <p>Arguments to be passed to plt.plot().</p> required Source code in <code>mibitrans/transport/model_parent.py</code> <pre><code>def transverse(self, x_position, time=None, relative_concentration=False, animate=False, **kwargs):\n    \"\"\"Plot concentration distribution as a line horizontal transverse to the plume extent.\n\n    Args:\n        x_position : x-position along the plume (longitudinal direction) for the plot.\n        time (float): Point of time for the plot. Will show the closest time step to given value.\n            By default, last point in time is plotted.\n        relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum\n            source zone concentrations at t=0. By default, absolute concentrations are shown.\n        animate (bool, optional): If True, animation of contaminant plume until given time is shown. Default is\n            False.\n        **kwargs : Arguments to be passed to plt.plot().\n    \"\"\"\n    if animate:\n        anim = pline.transverse(\n            self,\n            x_position=x_position,\n            time=time,\n            relative_concentration=relative_concentration,\n            animate=animate,\n            **kwargs,\n        )\n        return anim\n    else:\n        pline.transverse(\n            self,\n            x_position=x_position,\n            time=time,\n            relative_concentration=relative_concentration,\n            animate=animate,\n            **kwargs,\n        )\n        return None\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D","title":"<code>Transport3D</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Parent class for all 3-dimensional analytical transport solutions.</p> Source code in <code>mibitrans/transport/model_parent.py</code> <pre><code>class Transport3D(ABC):\n    \"\"\"Parent class for all 3-dimensional analytical transport solutions.\"\"\"\n\n    def __init__(\n        self, hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose=False\n    ):\n        \"\"\"Initialize parent class object.\n\n        Args:\n            hydrological_parameters (mibitrans.data.parameters.HydrologicalParameters) : Dataclass object containing\n                hydrological parameters from HydrologicalParameters.\n            attenuation_parameters (mibitrans.data.read.AttenuationParameters) : Dataclass object containing adsorption,\n                degradation and diffusion parameters from AttenuationParameters.\n            source_parameters (mibitrans.data.read.SourceParameters) : Dataclass object containing source parameters\n                from SourceParameters.\n            model_parameters (mibitrans.data.read.ModelParameters) : Dataclass object containing model parameters from\n                ModelParameters.\n            verbose (bool, optional): Verbose mode. Defaults to False.\n        \"\"\"\n        # Check if input arguments are of the correct dataclass\n        for key, value in locals().items():\n            if key not in [\"self\", \"verbose\"]:\n                self._check_input_dataclasses(key, value)\n\n        self._hyd_pars = copy.copy(hydrological_parameters)\n        self._att_pars = copy.copy(attenuation_parameters)\n        self._src_pars = copy.copy(source_parameters)\n        self._mod_pars = copy.copy(model_parameters)\n        self._decay_rate = self._att_pars.decay_rate\n\n        self.verbose = verbose\n        self._mode = \"linear\"\n        self._electron_acceptors = None\n        self._utilization_factor = None\n        self.biodegradation_capacity = None\n        self.cxyt_noBC = None\n        self._pre_run_initialization_parameters()\n\n    @property\n    def input_parameters(self):\n        \"\"\"Return the input arguments for the model in the form of a dictionary, based on current values.\"\"\"\n        return dict(\n            hydrological_parameters=self.hydrological_parameters,\n            attenuation_parameters=self.attenuation_parameters,\n            source_parameters=self.source_parameters,\n            model_parameters=self.model_parameters,\n            verbose=self.verbose,\n        )\n\n    @property\n    def hydrological_parameters(self):\n        \"\"\"Rename to shorthand form of hydrological_parameters inside class for ease of use.\"\"\"\n        return self._hyd_pars\n\n    @hydrological_parameters.setter\n    def hydrological_parameters(self, value):\n        self._check_input_dataclasses(\"hydrological_parameters\", value)\n        self._hyd_pars = copy.copy(value)\n\n    @property\n    def attenuation_parameters(self):\n        \"\"\"Rename to shorthand form of attenuation_parameters inside class for ease of use.\"\"\"\n        return self._att_pars\n\n    @attenuation_parameters.setter\n    def attenuation_parameters(self, value):\n        self._check_input_dataclasses(\"attenuation_parameters\", value)\n        self._att_pars = copy.copy(value)\n\n    @property\n    def source_parameters(self):\n        \"\"\"Rename to shorthand form of source_parameters inside class for ease of use.\"\"\"\n        return self._src_pars\n\n    @source_parameters.setter\n    def source_parameters(self, value):\n        self._check_input_dataclasses(\"source_parameters\", value)\n        self._src_pars = copy.copy(value)\n\n    @property\n    def model_parameters(self):\n        \"\"\"Rename to shorthand form of model_parameters inside class for ease of use.\"\"\"\n        return self._mod_pars\n\n    @model_parameters.setter\n    def model_parameters(self, value):\n        self._check_input_dataclasses(\"model_parameters\", value)\n        self._mod_pars = copy.copy(value)\n\n    @property\n    def mode(self):\n        \"\"\"Model mode property. Either 'linear' or 'instant_reaction'.\"\"\"\n        return self._mode\n\n    @mode.setter\n    def mode(self, value):\n        match value:\n            case \"linear\" | \"linear decay\" | \"linear_decay\" | 0:\n                self._mode = \"linear\"\n            case \"instant\" | \"instant_reaction\" | \"instant reaction\" | 1:\n                if self._electron_acceptors is None or self._utilization_factor is None:\n                    raise ValueError(\n                        \"Model mode was set to 'instant reaction', but electron acceptor parameters are \"\n                        \"missing. Use the instant_reaction method to supply the electron acceptor \"\n                        \"concentrations.\"\n                    )\n                self._mode = \"instant_reaction\"\n            case _:\n                warnings.warn(f\"Mode '{value}' not recognized. Defaulting to 'linear' instead.\", UserWarning)\n                self._mode = \"linear\"\n\n    @property\n    def electron_acceptors(self):\n        \"\"\"Return dictionary of electron acceptor parameters.\"\"\"\n        return self._electron_acceptors.dictionary\n\n    @property\n    def utilization_factor(self):\n        \"\"\"Return dictionary of utilization factor property.\"\"\"\n        return self._utilization_factor.dictionary\n\n    @property\n    def relative_cxyt(self):\n        \"\"\"Compute relative concentration c(x,y,t)/c0, where c0 is the maximum source zone concentration at t=0.\"\"\"\n        maximum_concentration = np.max(self.source_parameters.source_zone_concentration)\n        relative_cxyt = self.cxyt / maximum_concentration\n        return relative_cxyt\n\n    @property\n    @abstractmethod\n    def short_description(self):\n        \"\"\"Short string describing model type.\"\"\"\n        pass\n\n    @abstractmethod\n    def run(self):\n        \"\"\"Method that runs the model and ensures that initialisation is performed.\"\"\"\n        pass\n\n    @abstractmethod\n    def sample(self, x_position, y_position, t_position):\n        \"\"\"Method that calculates concentration at single, specified location in model domain.\"\"\"\n        pass\n\n    @abstractmethod\n    def _calculate_concentration_for_all_xyt(self) -&gt; np.ndarray:\n        \"\"\"Method that calculates and return concentration array for all model x, y and t.\"\"\"\n        pass\n\n    def _pre_run_initialization_parameters(self):\n        \"\"\"Parameter initialization for model.\"\"\"\n        # One-dimensional model domain arrays\n        self.x = np.arange(0, self._mod_pars.model_length + self._mod_pars.dx, self._mod_pars.dx)\n        self.y = self._calculate_y_discretization()\n        self.t = np.arange(self._mod_pars.dt, self._mod_pars.model_time + self._mod_pars.dt, self._mod_pars.dt)\n\n        # Three-dimensional model domain arrays\n        self.xxx = self.x[None, None, :]\n        self.yyy = self.y[None, :, None]\n        self.ttt = self.t[:, None, None]\n\n        if (\n            self._att_pars.bulk_density is not None\n            and self._att_pars.partition_coefficient is not None\n            and self._att_pars.fraction_organic_carbon is not None\n        ):\n            self._att_pars.calculate_retardation(self._hyd_pars.porosity)\n\n        self.rv = self._hyd_pars.velocity / self._att_pars.retardation\n\n        # cxyt is concentration output array\n        self.cxyt = np.zeros((len(self.t), len(self.y), len(self.x)))\n\n        # Calculate retardation if not already specified in adsorption_parameters\n        self.k_source = self._calculate_source_decay()\n        self.y_source = self._src_pars.source_zone_boundary\n        # Subtract outer source zones from inner source zones\n        self.c_source = self._src_pars.source_zone_concentration.copy()\n        self.c_source[:-1] = self.c_source[:-1] - self.c_source[1:]\n        if self._mode == \"instant_reaction\":\n            self.c_source[-1] += self.biodegradation_capacity\n            self._decay_rate = 0\n        else:\n            self._decay_rate = self._att_pars.decay_rate\n\n    def _calculate_source_decay(self):\n        \"\"\"Calculate source decay/depletion.\"\"\"\n        if self._src_pars.total_mass != np.inf:\n            Q, c0_avg = calculate_discharge_and_average_source_zone_concentration(self)\n            k_source = Q * c0_avg / self._src_pars.total_mass\n        # If source mass is not a float, it is an infinite source, therefore, no source decay takes place.\n        else:\n            k_source = 0\n\n        return k_source\n\n    def _check_input_dataclasses(self, key, value):\n        \"\"\"Check if input parameters are the correct dataclasses. Raise an error if not.\"\"\"\n        dataclass_dict = {\n            \"hydrological_parameters\": mibitrans.data.parameters.HydrologicalParameters,\n            \"attenuation_parameters\": mibitrans.data.parameters.AttenuationParameters,\n            \"source_parameters\": mibitrans.data.parameters.SourceParameters,\n            \"model_parameters\": mibitrans.data.parameters.ModelParameters,\n        }\n\n        if not isinstance(value, dataclass_dict[key]):\n            raise TypeError(f\"Input argument {key} should be {dataclass_dict[key]}, but is {type(value)} instead.\")\n\n    def _calculate_y_discretization(self):\n        \"\"\"Calculate y-direction discretization.\"\"\"\n        if self._mod_pars.model_width &gt;= 2 * self._src_pars.source_zone_boundary[-1]:\n            y = np.arange(\n                -self._mod_pars.model_width / 2, self._mod_pars.model_width / 2 + self._mod_pars.dy, self._mod_pars.dy\n            )\n        else:\n            y = np.arange(\n                -self._src_pars.source_zone_boundary[-1],\n                self._src_pars.source_zone_boundary[-1] + self._mod_pars.dy,\n                self._mod_pars.dy,\n            )\n            warnings.warn(\n                \"Source zone boundary is larger than model width. Model width adjusted to fit entire source zone.\"\n            )\n        return y\n\n    def _calculate_biodegradation_capacity(self):\n        \"\"\"Determine biodegradation capacity based on electron acceptor concentrations and utilization factor.\"\"\"\n        biodegradation_capacity = 0\n        for key, item in self._utilization_factor.dictionary.items():\n            biodegradation_capacity += getattr(self._electron_acceptors, util_to_conc_name[key]) / item\n\n        return biodegradation_capacity\n\n    def instant_reaction(\n        self,\n        electron_acceptors: list | np.ndarray | dict | ElectronAcceptors,\n        utilization_factor: list | np.ndarray | dict | UtilizationFactor = UtilizationFactor(\n            util_oxygen=3.14, util_nitrate=4.9, util_ferrous_iron=21.8, util_sulfate=4.7, util_methane=0.78\n        ),\n    ):\n        \"\"\"Enable and set up parameters for instant reaction model.\n\n        Instant reaction model assumes that biodegradation is an instantaneous process compared to the groundwater flow\n        velocity. The biodegradation is assumed to be governed by the availability of electron acceptors, and quantified\n        using  stoichiometric relations from the degradation reactions. Considered are concentrations of acceptors\n        Oxygen, Nitrate and Sulfate, and reduced species Ferrous Iron and Methane.\n\n        Args:\n            electron_acceptors (ElectronAcceptors): ElectronAcceptor dataclass containing electron acceptor\n                concentrations. Alternatively provided as list, numpy array or dictionary corresponding with\n                delta_oxygen, delta_nitrate, ferrous_iron, delta_sulfate and methane. For more information, see\n                documentation for ElectronAcceptors.\n            utilization_factor (UtilizationFactor, optional): UtilizationFactor dataclass containing electron acceptor\n                utilization factors. Alternatively provided as list, numpy array or dictionary corresponding with\n                information, see documentation of UtilizationFactor. By default, electron acceptor utilization factors\n                for a BTEX mixture are used, based on values by Wiedemeier et al. (1995).\n        \"\"\"\n        self._electron_acceptors, self._utilization_factor = _check_instant_reaction_acceptor_input(\n            electron_acceptors, utilization_factor\n        )\n        self._mode = \"instant_reaction\"\n        self.biodegradation_capacity = self._calculate_biodegradation_capacity()\n        self.cxyt_noBC = 0\n        self._pre_run_initialization_parameters()\n\n    def _check_model_mode_before_run(self):\n        self._pre_run_initialization_parameters()\n        if self._mode == \"linear\":\n            if self.biodegradation_capacity is not None:\n                warnings.warn(\n                    \"Instant reaction parameters are present while model mode is linear. \"\n                    \"Make sure that this is indeed the desired model.\"\n                )\n        if self._mode == \"instant_reaction\":\n            if self.biodegradation_capacity is None:\n                raise ValueError(\n                    \"Instant reaction parameters are not present. \"\n                    \"Please provide them with the 'instant_reaction' class method.\"\n                )\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.attenuation_parameters","title":"<code>attenuation_parameters</code>  <code>property</code> <code>writable</code>","text":"<p>Rename to shorthand form of attenuation_parameters inside class for ease of use.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.electron_acceptors","title":"<code>electron_acceptors</code>  <code>property</code>","text":"<p>Return dictionary of electron acceptor parameters.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.hydrological_parameters","title":"<code>hydrological_parameters</code>  <code>property</code> <code>writable</code>","text":"<p>Rename to shorthand form of hydrological_parameters inside class for ease of use.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.input_parameters","title":"<code>input_parameters</code>  <code>property</code>","text":"<p>Return the input arguments for the model in the form of a dictionary, based on current values.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.mode","title":"<code>mode</code>  <code>property</code> <code>writable</code>","text":"<p>Model mode property. Either \u2018linear\u2019 or \u2018instant_reaction\u2019.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.model_parameters","title":"<code>model_parameters</code>  <code>property</code> <code>writable</code>","text":"<p>Rename to shorthand form of model_parameters inside class for ease of use.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.relative_cxyt","title":"<code>relative_cxyt</code>  <code>property</code>","text":"<p>Compute relative concentration c(x,y,t)/c0, where c0 is the maximum source zone concentration at t=0.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.short_description","title":"<code>short_description</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Short string describing model type.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.source_parameters","title":"<code>source_parameters</code>  <code>property</code> <code>writable</code>","text":"<p>Rename to shorthand form of source_parameters inside class for ease of use.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.utilization_factor","title":"<code>utilization_factor</code>  <code>property</code>","text":"<p>Return dictionary of utilization factor property.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.__init__","title":"<code>__init__(hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose=False)</code>","text":"<p>Initialize parent class object.</p> <p>Parameters:</p> Name Type Description Default <code>hydrological_parameters (mibitrans.data.parameters.HydrologicalParameters) </code> <p>Dataclass object containing hydrological parameters from HydrologicalParameters.</p> required <code>attenuation_parameters (mibitrans.data.read.AttenuationParameters) </code> <p>Dataclass object containing adsorption, degradation and diffusion parameters from AttenuationParameters.</p> required <code>source_parameters (mibitrans.data.read.SourceParameters) </code> <p>Dataclass object containing source parameters from SourceParameters.</p> required <code>model_parameters (mibitrans.data.read.ModelParameters) </code> <p>Dataclass object containing model parameters from ModelParameters.</p> required <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> Source code in <code>mibitrans/transport/model_parent.py</code> <pre><code>def __init__(\n    self, hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose=False\n):\n    \"\"\"Initialize parent class object.\n\n    Args:\n        hydrological_parameters (mibitrans.data.parameters.HydrologicalParameters) : Dataclass object containing\n            hydrological parameters from HydrologicalParameters.\n        attenuation_parameters (mibitrans.data.read.AttenuationParameters) : Dataclass object containing adsorption,\n            degradation and diffusion parameters from AttenuationParameters.\n        source_parameters (mibitrans.data.read.SourceParameters) : Dataclass object containing source parameters\n            from SourceParameters.\n        model_parameters (mibitrans.data.read.ModelParameters) : Dataclass object containing model parameters from\n            ModelParameters.\n        verbose (bool, optional): Verbose mode. Defaults to False.\n    \"\"\"\n    # Check if input arguments are of the correct dataclass\n    for key, value in locals().items():\n        if key not in [\"self\", \"verbose\"]:\n            self._check_input_dataclasses(key, value)\n\n    self._hyd_pars = copy.copy(hydrological_parameters)\n    self._att_pars = copy.copy(attenuation_parameters)\n    self._src_pars = copy.copy(source_parameters)\n    self._mod_pars = copy.copy(model_parameters)\n    self._decay_rate = self._att_pars.decay_rate\n\n    self.verbose = verbose\n    self._mode = \"linear\"\n    self._electron_acceptors = None\n    self._utilization_factor = None\n    self.biodegradation_capacity = None\n    self.cxyt_noBC = None\n    self._pre_run_initialization_parameters()\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.instant_reaction","title":"<code>instant_reaction(electron_acceptors, utilization_factor=UtilizationFactor(util_oxygen=3.14, util_nitrate=4.9, util_ferrous_iron=21.8, util_sulfate=4.7, util_methane=0.78))</code>","text":"<p>Enable and set up parameters for instant reaction model.</p> <p>Instant reaction model assumes that biodegradation is an instantaneous process compared to the groundwater flow velocity. The biodegradation is assumed to be governed by the availability of electron acceptors, and quantified using  stoichiometric relations from the degradation reactions. Considered are concentrations of acceptors Oxygen, Nitrate and Sulfate, and reduced species Ferrous Iron and Methane.</p> <p>Parameters:</p> Name Type Description Default <code>electron_acceptors</code> <code>ElectronAcceptors</code> <p>ElectronAcceptor dataclass containing electron acceptor concentrations. Alternatively provided as list, numpy array or dictionary corresponding with delta_oxygen, delta_nitrate, ferrous_iron, delta_sulfate and methane. For more information, see documentation for ElectronAcceptors.</p> required <code>utilization_factor</code> <code>UtilizationFactor</code> <p>UtilizationFactor dataclass containing electron acceptor utilization factors. Alternatively provided as list, numpy array or dictionary corresponding with information, see documentation of UtilizationFactor. By default, electron acceptor utilization factors for a BTEX mixture are used, based on values by Wiedemeier et al. (1995).</p> <code>UtilizationFactor(util_oxygen=3.14, util_nitrate=4.9, util_ferrous_iron=21.8, util_sulfate=4.7, util_methane=0.78)</code> Source code in <code>mibitrans/transport/model_parent.py</code> <pre><code>def instant_reaction(\n    self,\n    electron_acceptors: list | np.ndarray | dict | ElectronAcceptors,\n    utilization_factor: list | np.ndarray | dict | UtilizationFactor = UtilizationFactor(\n        util_oxygen=3.14, util_nitrate=4.9, util_ferrous_iron=21.8, util_sulfate=4.7, util_methane=0.78\n    ),\n):\n    \"\"\"Enable and set up parameters for instant reaction model.\n\n    Instant reaction model assumes that biodegradation is an instantaneous process compared to the groundwater flow\n    velocity. The biodegradation is assumed to be governed by the availability of electron acceptors, and quantified\n    using  stoichiometric relations from the degradation reactions. Considered are concentrations of acceptors\n    Oxygen, Nitrate and Sulfate, and reduced species Ferrous Iron and Methane.\n\n    Args:\n        electron_acceptors (ElectronAcceptors): ElectronAcceptor dataclass containing electron acceptor\n            concentrations. Alternatively provided as list, numpy array or dictionary corresponding with\n            delta_oxygen, delta_nitrate, ferrous_iron, delta_sulfate and methane. For more information, see\n            documentation for ElectronAcceptors.\n        utilization_factor (UtilizationFactor, optional): UtilizationFactor dataclass containing electron acceptor\n            utilization factors. Alternatively provided as list, numpy array or dictionary corresponding with\n            information, see documentation of UtilizationFactor. By default, electron acceptor utilization factors\n            for a BTEX mixture are used, based on values by Wiedemeier et al. (1995).\n    \"\"\"\n    self._electron_acceptors, self._utilization_factor = _check_instant_reaction_acceptor_input(\n        electron_acceptors, utilization_factor\n    )\n    self._mode = \"instant_reaction\"\n    self.biodegradation_capacity = self._calculate_biodegradation_capacity()\n    self.cxyt_noBC = 0\n    self._pre_run_initialization_parameters()\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.run","title":"<code>run()</code>  <code>abstractmethod</code>","text":"<p>Method that runs the model and ensures that initialisation is performed.</p> Source code in <code>mibitrans/transport/model_parent.py</code> <pre><code>@abstractmethod\ndef run(self):\n    \"\"\"Method that runs the model and ensures that initialisation is performed.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.sample","title":"<code>sample(x_position, y_position, t_position)</code>  <code>abstractmethod</code>","text":"<p>Method that calculates concentration at single, specified location in model domain.</p> Source code in <code>mibitrans/transport/model_parent.py</code> <pre><code>@abstractmethod\ndef sample(self, x_position, y_position, t_position):\n    \"\"\"Method that calculates concentration at single, specified location in model domain.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.models","title":"<code>models</code>","text":""},{"location":"reference/reference_transport/#mibitrans.transport.models.Anatrans","title":"<code>Anatrans</code>","text":"<p>               Bases: <code>Transport3D</code></p> <p>Model class using an analytical solution based on Bear (1979), Domenico (1987) &amp; Newell et al. (1997).</p> <p>Under the assumption that C(x,y,z,t) = C(x,t) * C(y,t) * C(z,t), the 3D ADE can be broken up in three separate differential equations which can be solved individually. For C(x,t) the solution is given in Bear (1979), C(y,t) and C(z,t) can be derived from Crank (1975). The equation used for Anatrans is the combination of these solutions, with addition of source depletion, source superposition and instant reaction model, described in Newell et al. (1997) and implemented in the BIOSCREEN screening model. The solution of Newell et al. (1997) is based of the Domenico (1987) solution, a truncated version of the equation described above, which introduces an error with a size dependent on the ratio of flow velocity and longitudinal dispersivity. Anatrans instead uses the fully untruncated version.</p> <p>Bear, J. 1979. Hydraulics of Ground Water. New York: McGraw-Hill.</p> <p>Crank, J. 1975. The mathematics of Diffusion. New York: Oxford University Press.</p> <p>Domenico, P. A. (1987). An analytical model for multidimensional transport of a decaying contaminant species. Journal of Hydrology, 91(1-2), 49-58.</p> <p>Newell, C. J., McLeod, R. K., &amp; Gonzales, J. R. (1997). BIOSCREEN natural attenuation decision support system version 1.4 revisions, Tech. rep., U.S. EPA.</p> Source code in <code>mibitrans/transport/models.py</code> <pre><code>class Anatrans(Transport3D):\n    \"\"\"Model class using an analytical solution based on Bear (1979), Domenico (1987) &amp; Newell et al. (1997).\n\n    Under the assumption that C(x,y,z,t) = C(x,t) * C(y,t) * C(z,t), the 3D ADE can be broken up in three separate\n    differential equations which can be solved individually. For C(x,t) the solution is given in Bear (1979), C(y,t) and\n    C(z,t) can be derived from Crank (1975). The equation used for Anatrans is the combination of these solutions, with\n    addition of source depletion, source superposition and instant reaction model, described in Newell et al. (1997) and\n    implemented in the BIOSCREEN screening model. The solution of Newell et al. (1997) is based of the Domenico (1987)\n    solution, a truncated version of the equation described above, which introduces an error with a size dependent on\n    the ratio of flow velocity and longitudinal dispersivity. Anatrans instead uses the fully untruncated version.\n\n    Bear, J. 1979. Hydraulics of Ground Water. New York: McGraw-Hill.\n\n    Crank, J. 1975. The mathematics of Diffusion. New York: Oxford University Press.\n\n    Domenico, P. A. (1987). An analytical model for multidimensional transport of a decaying contaminant species.\n    Journal of Hydrology, 91(1-2), 49-58.\n\n    Newell, C. J., McLeod, R. K., &amp; Gonzales, J. R. (1997). BIOSCREEN natural attenuation decision support\n    system version 1.4 revisions, Tech. rep., U.S. EPA.\n    \"\"\"\n\n    def __init__(\n        self,\n        hydrological_parameters,\n        attenuation_parameters,\n        source_parameters,\n        model_parameters,\n        verbose=False,\n    ):\n        \"\"\"Initialize model object.\n\n        Args:\n            hydrological_parameters (mibitrans.data.parameters.HydrologicalParameters) : Dataclass object containing\n                hydrological parameters from HydrologicalParameters.\n            attenuation_parameters (mibitrans.data.read.AttenuationParameters) : Dataclass object containing adsorption,\n                degradation and diffusion parameters from AttenuationParameters.\n            source_parameters (mibitrans.data.read.SourceParameters) : Dataclass object containing source parameters\n                from SourceParameters.\n            model_parameters (mibitrans.data.read.ModelParameters) : Dataclass object containing model parameters from\n                ModelParameters.\n            verbose (bool, optional): Verbose mode. Defaults to False.\n\n        Attributes:\n            mode (str) : Current model mode. Is 'linear' by default. Once instant reaction parameters are provided. Use\n                this attribute to switch between 'linear' and 'instant_reaction' models.\n            cxyt (np.ndarray) : Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]\n            relative_cxyt (np.ndarray) : Output array with concentrations in model domain, divided by the maximum source\n                zone concentration at t=0. Indexed as [t,y,x].\n            x (np.ndarray) : Discretized model x-dimension, in [m].\n            y (np.ndarray) : Discretized model y-dimension, in [y].\n            t (np.ndarray) : Discretized model t-dimension, in [days].\n            c_source (np.ndarray) : Nett source zone concentrations, accounting for source superposition, in [g/m^3].\n            vr (float) : Retarded groundwater flow velocity, in [m/d].\n            k_source (float) : Source zone decay rate, in [1/days].\n            biodegradation_capacity (float) : Maximum capacity of biodegradation given provided electron acceptor\n            concentrations, in [g/m^3].\n\n        Methods:\n            run : Run model with current parameters, returns Results object.\n            sample : Calculate concentration at any given position and point in time.\n            instant_reaction : Activate the instant reaction model by providing electron acceptor concentrations. And\n                optionally electron acceptor utilization factors. Switch between model modes by using the mode\n                attribute.\n            centerline : Plot center of contaminant plume of this model, at a specified time and y position.\n            transverse : Plot concentration distribution as a line horizontal transverse to the plume extent.\n            breakthrough : Plot contaminant breakthrough curve at given x and y position in model domain.\n            plume_2d : Plot contaminant plume as a 2D colormesh, at a specified time.\n            plume_3d : Plot contaminant plume as a 3D surface, at a specified time.\n\n        Raises:\n            TypeError : If input is not of the correct Dataclass.\n\n        \"\"\"\n        super().__init__(hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose)\n        if self._att_pars.diffusion != 0:\n            warnings.warn(\"Domenico model does not consider molecular diffusion.\", UserWarning)\n\n    @property\n    def short_description(self):\n        \"\"\"Short description of model type.\"\"\"\n        return \"Anatrans model\"\n\n    def run(self):\n        \"\"\"Calculate the concentration for all discretized x, y and t using the analytical transport model.\"\"\"\n        self._check_model_mode_before_run()\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            self.cxyt = self._calculate_concentration_for_all_xyt(self.xxx, self.yyy, self.ttt)\n        return Results(self)\n\n    def sample(self, x_position, y_position, time):\n        \"\"\"Give concentration at any given position and point in time.\n\n        Args:\n            x_position (float): x position in domain extent [m].\n            y_position (float): y position in domain extent [m].\n            time (float): time for which concentration is sampled [days].\n\n        Returns:\n            concentration (float): concentration at given position and point in time [g/m^3].\n\n        \"\"\"\n        for par, value in locals().items():\n            if par != \"self\":\n                validate_input_values(par, value)\n\n        self._pre_run_initialization_parameters()\n\n        if self.mode == \"instant_reaction\":\n            save_c_noBC = self.cxyt_noBC.copy()\n        x = np.array([x_position])\n        y = np.array([y_position])\n        t = np.array([time])\n        concentration = self._calculate_concentration_for_all_xyt(x, y, t)[0]\n        if self.mode == \"instant_reaction\":\n            self.cxyt_noBC = save_c_noBC\n        return concentration\n\n    def _equation_term_x(self, xxx, ttt, decay_sqrt):\n        return np.exp(xxx * (1 - decay_sqrt) / (self._hyd_pars.alpha_x * 2)) * erfc(\n            (xxx - self.rv * ttt * decay_sqrt) / (2 * np.sqrt(self._hyd_pars.alpha_x * self.rv * ttt))\n        )\n\n    def _equation_term_additional_x(self, xxx, ttt, decay_sqrt):\n        erfc_inner = (xxx + decay_sqrt * self.rv * ttt) / (2 * np.sqrt(self._hyd_pars.alpha_x * self.rv * ttt))\n        # Additional term is prone to overflow of exp and underflow of erfc under certain parameter combinations.\n        # To decrease cases, used erfcx. Where erfcx(a) = exp(a**2)*erfc(a) -&gt; exp(b)*erfc(a) = exp(b - a**2) * erfcx(a)\n        term = np.exp(xxx * (1 + decay_sqrt) * (1 / 2) / self._hyd_pars.alpha_x - erfc_inner**2) * erfcx(erfc_inner)\n        return term\n\n    def _equation_term_z(self, xxx):\n        inner_term = self._src_pars.depth / (2 * np.sqrt(self._hyd_pars.alpha_z * xxx))\n        return erf(inner_term) - erf(-inner_term)\n\n    def _equation_term_source_depletion(self, xxx, ttt):\n        return np.exp(-self.k_source * ttt)\n\n    def _equation_term_y(self, i, xxx, yyy):\n        div_term = 2 * np.sqrt(self._hyd_pars.alpha_y * xxx)\n        term = erf((yyy + self.y_source[i]) / div_term) - erf((yyy - self.y_source[i]) / div_term)\n        term[np.isnan(term)] = 0\n        return term\n\n    def _equation_decay_sqrt(self):\n        return np.sqrt(1 + 4 * (self._decay_rate - self.k_source) * self._hyd_pars.alpha_x / self.rv)\n\n    def _calculate_concentration_for_all_xyt(self, xxx, yyy, ttt):\n        cxyt = 0\n        decay_sqrt = self._equation_decay_sqrt()\n        x_term = self._equation_term_x(xxx, ttt, decay_sqrt)\n        additional_x = self._equation_term_additional_x(xxx, ttt, decay_sqrt)\n        z_term = self._equation_term_z(xxx)\n        source_depletion = self._equation_term_source_depletion(xxx, ttt)\n        for i in range(len(self.c_source)):\n            y_term = self._equation_term_y(i, xxx, yyy)\n            cxyt_step = 1 / 8 * self.c_source[i] * source_depletion * (x_term + additional_x) * y_term * z_term\n            cxyt += cxyt_step\n        if self._mode == \"instant_reaction\":\n            self.cxyt_noBC = cxyt.copy()\n            cxyt -= self.biodegradation_capacity\n            cxyt = np.where(cxyt &lt; 0, 0, cxyt)\n        self.has_run = True\n        return cxyt\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.models.Anatrans.short_description","title":"<code>short_description</code>  <code>property</code>","text":"<p>Short description of model type.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.models.Anatrans.__init__","title":"<code>__init__(hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose=False)</code>","text":"<p>Initialize model object.</p> <p>Parameters:</p> Name Type Description Default <code>hydrological_parameters (mibitrans.data.parameters.HydrologicalParameters) </code> <p>Dataclass object containing hydrological parameters from HydrologicalParameters.</p> required <code>attenuation_parameters (mibitrans.data.read.AttenuationParameters) </code> <p>Dataclass object containing adsorption, degradation and diffusion parameters from AttenuationParameters.</p> required <code>source_parameters (mibitrans.data.read.SourceParameters) </code> <p>Dataclass object containing source parameters from SourceParameters.</p> required <code>model_parameters (mibitrans.data.read.ModelParameters) </code> <p>Dataclass object containing model parameters from ModelParameters.</p> required <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>mode</code> <code>str) </code> <p>Current model mode. Is \u2018linear\u2019 by default. Once instant reaction parameters are provided. Use this attribute to switch between \u2018linear\u2019 and \u2018instant_reaction\u2019 models.</p> <code>cxyt</code> <code>np.ndarray) </code> <p>Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]</p> <code>relative_cxyt</code> <code>np.ndarray) </code> <p>Output array with concentrations in model domain, divided by the maximum source zone concentration at t=0. Indexed as [t,y,x].</p> <code>x</code> <code>np.ndarray) </code> <p>Discretized model x-dimension, in [m].</p> <code>y</code> <code>np.ndarray) </code> <p>Discretized model y-dimension, in [y].</p> <code>t</code> <code>np.ndarray) </code> <p>Discretized model t-dimension, in [days].</p> <code>c_source</code> <code>np.ndarray) </code> <p>Nett source zone concentrations, accounting for source superposition, in [g/m^3].</p> <code>vr</code> <code>float) </code> <p>Retarded groundwater flow velocity, in [m/d].</p> <code>k_source</code> <code>float) </code> <p>Source zone decay rate, in [1/days].</p> <code>biodegradation_capacity</code> <code>float) </code> <p>Maximum capacity of biodegradation given provided electron acceptor</p> <p>Functions:</p> Name Description <code>run </code> <p>Run model with current parameters, returns Results object.</p> <code>sample </code> <p>Calculate concentration at any given position and point in time.</p> <code>instant_reaction </code> <p>Activate the instant reaction model by providing electron acceptor concentrations. And optionally electron acceptor utilization factors. Switch between model modes by using the mode attribute.</p> <code>centerline </code> <p>Plot center of contaminant plume of this model, at a specified time and y position.</p> <code>transverse </code> <p>Plot concentration distribution as a line horizontal transverse to the plume extent.</p> <code>breakthrough </code> <p>Plot contaminant breakthrough curve at given x and y position in model domain.</p> <code>plume_2d </code> <p>Plot contaminant plume as a 2D colormesh, at a specified time.</p> <code>plume_3d </code> <p>Plot contaminant plume as a 3D surface, at a specified time.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input is not of the correct Dataclass.</p> Source code in <code>mibitrans/transport/models.py</code> <pre><code>def __init__(\n    self,\n    hydrological_parameters,\n    attenuation_parameters,\n    source_parameters,\n    model_parameters,\n    verbose=False,\n):\n    \"\"\"Initialize model object.\n\n    Args:\n        hydrological_parameters (mibitrans.data.parameters.HydrologicalParameters) : Dataclass object containing\n            hydrological parameters from HydrologicalParameters.\n        attenuation_parameters (mibitrans.data.read.AttenuationParameters) : Dataclass object containing adsorption,\n            degradation and diffusion parameters from AttenuationParameters.\n        source_parameters (mibitrans.data.read.SourceParameters) : Dataclass object containing source parameters\n            from SourceParameters.\n        model_parameters (mibitrans.data.read.ModelParameters) : Dataclass object containing model parameters from\n            ModelParameters.\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Attributes:\n        mode (str) : Current model mode. Is 'linear' by default. Once instant reaction parameters are provided. Use\n            this attribute to switch between 'linear' and 'instant_reaction' models.\n        cxyt (np.ndarray) : Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]\n        relative_cxyt (np.ndarray) : Output array with concentrations in model domain, divided by the maximum source\n            zone concentration at t=0. Indexed as [t,y,x].\n        x (np.ndarray) : Discretized model x-dimension, in [m].\n        y (np.ndarray) : Discretized model y-dimension, in [y].\n        t (np.ndarray) : Discretized model t-dimension, in [days].\n        c_source (np.ndarray) : Nett source zone concentrations, accounting for source superposition, in [g/m^3].\n        vr (float) : Retarded groundwater flow velocity, in [m/d].\n        k_source (float) : Source zone decay rate, in [1/days].\n        biodegradation_capacity (float) : Maximum capacity of biodegradation given provided electron acceptor\n        concentrations, in [g/m^3].\n\n    Methods:\n        run : Run model with current parameters, returns Results object.\n        sample : Calculate concentration at any given position and point in time.\n        instant_reaction : Activate the instant reaction model by providing electron acceptor concentrations. And\n            optionally electron acceptor utilization factors. Switch between model modes by using the mode\n            attribute.\n        centerline : Plot center of contaminant plume of this model, at a specified time and y position.\n        transverse : Plot concentration distribution as a line horizontal transverse to the plume extent.\n        breakthrough : Plot contaminant breakthrough curve at given x and y position in model domain.\n        plume_2d : Plot contaminant plume as a 2D colormesh, at a specified time.\n        plume_3d : Plot contaminant plume as a 3D surface, at a specified time.\n\n    Raises:\n        TypeError : If input is not of the correct Dataclass.\n\n    \"\"\"\n    super().__init__(hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose)\n    if self._att_pars.diffusion != 0:\n        warnings.warn(\"Domenico model does not consider molecular diffusion.\", UserWarning)\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.models.Anatrans.run","title":"<code>run()</code>","text":"<p>Calculate the concentration for all discretized x, y and t using the analytical transport model.</p> Source code in <code>mibitrans/transport/models.py</code> <pre><code>def run(self):\n    \"\"\"Calculate the concentration for all discretized x, y and t using the analytical transport model.\"\"\"\n    self._check_model_mode_before_run()\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        self.cxyt = self._calculate_concentration_for_all_xyt(self.xxx, self.yyy, self.ttt)\n    return Results(self)\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.models.Anatrans.sample","title":"<code>sample(x_position, y_position, time)</code>","text":"<p>Give concentration at any given position and point in time.</p> <p>Parameters:</p> Name Type Description Default <code>x_position</code> <code>float</code> <p>x position in domain extent [m].</p> required <code>y_position</code> <code>float</code> <p>y position in domain extent [m].</p> required <code>time</code> <code>float</code> <p>time for which concentration is sampled [days].</p> required <p>Returns:</p> Name Type Description <code>concentration</code> <code>float</code> <p>concentration at given position and point in time [g/m^3].</p> Source code in <code>mibitrans/transport/models.py</code> <pre><code>def sample(self, x_position, y_position, time):\n    \"\"\"Give concentration at any given position and point in time.\n\n    Args:\n        x_position (float): x position in domain extent [m].\n        y_position (float): y position in domain extent [m].\n        time (float): time for which concentration is sampled [days].\n\n    Returns:\n        concentration (float): concentration at given position and point in time [g/m^3].\n\n    \"\"\"\n    for par, value in locals().items():\n        if par != \"self\":\n            validate_input_values(par, value)\n\n    self._pre_run_initialization_parameters()\n\n    if self.mode == \"instant_reaction\":\n        save_c_noBC = self.cxyt_noBC.copy()\n    x = np.array([x_position])\n    y = np.array([y_position])\n    t = np.array([time])\n    concentration = self._calculate_concentration_for_all_xyt(x, y, t)[0]\n    if self.mode == \"instant_reaction\":\n        self.cxyt_noBC = save_c_noBC\n    return concentration\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.models.Bioscreen","title":"<code>Bioscreen</code>","text":"<p>               Bases: <code>Anatrans</code></p> <p>Model class using the analytical solution implemented in the BIOSCREEN screening model, Newell et al. (1997).</p> <p>This model is an exact implementation of the transport equations implemented in the BIOSCREEN screening model of Newell et al. (1997), which is based on the Domenico (1987) analytical model. Using a truncated version of the equation used in the Anatrans model. This model is implemented as a method of comparison with the original BIOSCREEN software. And is included for legacy reasons, since it is the first model implemented in the mibitrans package, serving as a basis for the other models. However, caution should be taken when using this model, since a varying error is introduced by using the truncated analytical solution. The error is most prominent for shorter times and distances from the source, and depends on the ratio of flow velocity and longitudinal dispersivity. For modelling, the Anatrans (untruncated approximate solution) and Mibitrans (exact analytical solution) models are recommended instead.</p> <p>Domenico, P. A. (1987). An analytical model for multidimensional transport of a decaying contaminant species. Journal of Hydrology, 91(1-2), 49-58.</p> <p>Newell, C. J., McLeod, R. K., &amp; Gonzales, J. R. (1997). BIOSCREEN natural attenuation decision support system version 1.4 revisions, Tech. rep., U.S. EPA.</p> Source code in <code>mibitrans/transport/models.py</code> <pre><code>class Bioscreen(Anatrans):\n    \"\"\"Model class using the analytical solution implemented in the BIOSCREEN screening model, Newell et al. (1997).\n\n    This model is an exact implementation of the transport equations implemented in the BIOSCREEN screening model of\n    Newell et al. (1997), which is based on the Domenico (1987) analytical model. Using a truncated version of the\n    equation used in the Anatrans model. This model is implemented as a method of comparison with the original BIOSCREEN\n    software. And is included for legacy reasons, since it is the first model implemented in the mibitrans package,\n    serving as a basis for the other models. However, caution should be taken when using this model, since a varying\n    error is introduced by using the truncated analytical solution. The error is most prominent for shorter times and\n    distances from the source, and depends on the ratio of flow velocity and longitudinal dispersivity. For modelling,\n    the Anatrans (untruncated approximate solution) and Mibitrans (exact analytical solution) models are recommended\n    instead.\n\n    Domenico, P. A. (1987). An analytical model for multidimensional transport of a decaying contaminant species.\n    Journal of Hydrology, 91(1-2), 49-58.\n\n    Newell, C. J., McLeod, R. K., &amp; Gonzales, J. R. (1997). BIOSCREEN natural attenuation decision support\n    system version 1.4 revisions, Tech. rep., U.S. EPA.\n    \"\"\"\n\n    def __init__(\n        self,\n        hydrological_parameters,\n        attenuation_parameters,\n        source_parameters,\n        model_parameters,\n        verbose=False,\n    ):\n        \"\"\"Initialize model object.\n\n        Args:\n            hydrological_parameters (mibitrans.data.parameters.HydrologicalParameters) : Dataclass object containing\n                hydrological parameters from HydrologicalParameters.\n            attenuation_parameters (mibitrans.data.read.AttenuationParameters) : Dataclass object containing adsorption,\n                degradation and diffusion parameters from AttenuationParameters.\n            source_parameters (mibitrans.data.read.SourceParameters) : Dataclass object containing source parameters\n                from SourceParameters.\n            model_parameters (mibitrans.data.read.ModelParameters) : Dataclass object containing model parameters from\n                ModelParameters.\n            verbose (bool, optional): Verbose mode. Defaults to False.\n\n        Attributes:\n            mode (str) : Current model mode. Is 'linear' by default. Once instant reaction parameters are provided. Use\n                this attribute to switch between 'linear' and 'instant_reaction' models.\n            cxyt (np.ndarray) : Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]\n            relative_cxyt (np.ndarray) : Output array with concentrations in model domain, divided by the maximum source\n                zone concentration at t=0. Indexed as [t,y,x].\n            x (np.ndarray) : Discretized model x-dimension, in [m].\n            y (np.ndarray) : Discretized model y-dimension, in [y].\n            t (np.ndarray) : Discretized model t-dimension, in [days].\n            c_source (np.ndarray) : Nett source zone concentrations, accounting for source superposition, in [g/m^3].\n            vr (float) : Retarded groundwater flow velocity, in [m/d].\n            k_source (float) : Source zone decay rate, in [1/days].\n            biodegradation_capacity (float) : Maximum capacity of biodegradation given provided electron acceptor\n            concentrations, in [g/m^3].\n\n        Methods:\n            run : Run model with current parameters, returns Results object.\n            sample : Calculate concentration at any given position and point in time.\n            instant_reaction : Activate the instant reaction model by providing electron acceptor concentrations. And\n                optionally electron acceptor utilization factors. Switch between model modes by using the mode\n                attribute.\n\n        Raises:\n            TypeError : If input is not of the correct Dataclass.\n\n        \"\"\"\n        super().__init__(hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose)\n\n    @property\n    def short_description(self):\n        \"\"\"Short description of model type.\"\"\"\n        return \"Bioscreen model\"\n\n    def _equation_term_source_depletion(self, xxx, ttt):\n        term = np.exp(-self.k_source * (ttt - xxx / self.rv))\n        # Term can be max 1; can not have 'generation' of solute ahead of advection.\n        return np.where(term &gt; 1, 1, term)\n\n    def _equation_decay_sqrt(self):\n        return np.sqrt(1 + 4 * self._decay_rate * self._hyd_pars.alpha_x / self.rv)\n\n    def _calculate_concentration_for_all_xyt(self, xxx, yyy, ttt):\n        # Difference with the Anatrans solution is the lack of additional term and alternative source decay\n        cxyt = 0\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            decay_sqrt = self._equation_decay_sqrt()\n            x_term = self._equation_term_x(xxx, ttt, decay_sqrt)\n            z_term = self._equation_term_z(xxx)\n            source_depletion = self._equation_term_source_depletion(xxx, ttt)\n            for i in range(len(self.c_source)):\n                y_term = self._equation_term_y(i, xxx, yyy)\n                cxyt_step = 1 / 8 * self.c_source[i] * source_depletion * x_term * y_term * z_term\n                cxyt += cxyt_step\n        if self._mode == \"instant_reaction\":\n            self.cxyt_noBC = cxyt.copy()\n            cxyt -= self.biodegradation_capacity\n            cxyt = np.where(cxyt &lt; 0, 0, cxyt)\n        self.has_run = True\n        return cxyt\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.models.Bioscreen.short_description","title":"<code>short_description</code>  <code>property</code>","text":"<p>Short description of model type.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.models.Bioscreen.__init__","title":"<code>__init__(hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose=False)</code>","text":"<p>Initialize model object.</p> <p>Parameters:</p> Name Type Description Default <code>hydrological_parameters (mibitrans.data.parameters.HydrologicalParameters) </code> <p>Dataclass object containing hydrological parameters from HydrologicalParameters.</p> required <code>attenuation_parameters (mibitrans.data.read.AttenuationParameters) </code> <p>Dataclass object containing adsorption, degradation and diffusion parameters from AttenuationParameters.</p> required <code>source_parameters (mibitrans.data.read.SourceParameters) </code> <p>Dataclass object containing source parameters from SourceParameters.</p> required <code>model_parameters (mibitrans.data.read.ModelParameters) </code> <p>Dataclass object containing model parameters from ModelParameters.</p> required <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>mode</code> <code>str) </code> <p>Current model mode. Is \u2018linear\u2019 by default. Once instant reaction parameters are provided. Use this attribute to switch between \u2018linear\u2019 and \u2018instant_reaction\u2019 models.</p> <code>cxyt</code> <code>np.ndarray) </code> <p>Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]</p> <code>relative_cxyt</code> <code>np.ndarray) </code> <p>Output array with concentrations in model domain, divided by the maximum source zone concentration at t=0. Indexed as [t,y,x].</p> <code>x</code> <code>np.ndarray) </code> <p>Discretized model x-dimension, in [m].</p> <code>y</code> <code>np.ndarray) </code> <p>Discretized model y-dimension, in [y].</p> <code>t</code> <code>np.ndarray) </code> <p>Discretized model t-dimension, in [days].</p> <code>c_source</code> <code>np.ndarray) </code> <p>Nett source zone concentrations, accounting for source superposition, in [g/m^3].</p> <code>vr</code> <code>float) </code> <p>Retarded groundwater flow velocity, in [m/d].</p> <code>k_source</code> <code>float) </code> <p>Source zone decay rate, in [1/days].</p> <code>biodegradation_capacity</code> <code>float) </code> <p>Maximum capacity of biodegradation given provided electron acceptor</p> <p>Functions:</p> Name Description <code>run </code> <p>Run model with current parameters, returns Results object.</p> <code>sample </code> <p>Calculate concentration at any given position and point in time.</p> <code>instant_reaction </code> <p>Activate the instant reaction model by providing electron acceptor concentrations. And optionally electron acceptor utilization factors. Switch between model modes by using the mode attribute.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input is not of the correct Dataclass.</p> Source code in <code>mibitrans/transport/models.py</code> <pre><code>def __init__(\n    self,\n    hydrological_parameters,\n    attenuation_parameters,\n    source_parameters,\n    model_parameters,\n    verbose=False,\n):\n    \"\"\"Initialize model object.\n\n    Args:\n        hydrological_parameters (mibitrans.data.parameters.HydrologicalParameters) : Dataclass object containing\n            hydrological parameters from HydrologicalParameters.\n        attenuation_parameters (mibitrans.data.read.AttenuationParameters) : Dataclass object containing adsorption,\n            degradation and diffusion parameters from AttenuationParameters.\n        source_parameters (mibitrans.data.read.SourceParameters) : Dataclass object containing source parameters\n            from SourceParameters.\n        model_parameters (mibitrans.data.read.ModelParameters) : Dataclass object containing model parameters from\n            ModelParameters.\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Attributes:\n        mode (str) : Current model mode. Is 'linear' by default. Once instant reaction parameters are provided. Use\n            this attribute to switch between 'linear' and 'instant_reaction' models.\n        cxyt (np.ndarray) : Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]\n        relative_cxyt (np.ndarray) : Output array with concentrations in model domain, divided by the maximum source\n            zone concentration at t=0. Indexed as [t,y,x].\n        x (np.ndarray) : Discretized model x-dimension, in [m].\n        y (np.ndarray) : Discretized model y-dimension, in [y].\n        t (np.ndarray) : Discretized model t-dimension, in [days].\n        c_source (np.ndarray) : Nett source zone concentrations, accounting for source superposition, in [g/m^3].\n        vr (float) : Retarded groundwater flow velocity, in [m/d].\n        k_source (float) : Source zone decay rate, in [1/days].\n        biodegradation_capacity (float) : Maximum capacity of biodegradation given provided electron acceptor\n        concentrations, in [g/m^3].\n\n    Methods:\n        run : Run model with current parameters, returns Results object.\n        sample : Calculate concentration at any given position and point in time.\n        instant_reaction : Activate the instant reaction model by providing electron acceptor concentrations. And\n            optionally electron acceptor utilization factors. Switch between model modes by using the mode\n            attribute.\n\n    Raises:\n        TypeError : If input is not of the correct Dataclass.\n\n    \"\"\"\n    super().__init__(hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose)\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.models.Mibitrans","title":"<code>Mibitrans</code>","text":"<p>               Bases: <code>Transport3D</code></p> <p>Model class using an exact analytical solution as described in Karanovic (2007), based on Wexler (1992).</p> <p>Karanovic (2007) implemented the Wexler (1992) exact analytical solution in the Excel based BIOSCREEN-AT, and added source depletion, akin to that implemented in its predecessor BIOSCREEN by Newell et al. (1997). The Mibitrans model allows for the same method as used in BIOSCREEN-AT, but expands it by allowing multiple source zones (by means of superposition) and including the instant reaction model. These were present in the original BIOSCREEN, but not reimplemented in BIOSCREEN-AT. Using a single source zone in this model, and not using the instant reaction option will make the Mibitrans solution resolve to the equation described in Karanovic (2007). Which in turn resolves to the Wexler (1992) solution if source depletion is disabled.</p> <p>Karanovic, M., Neville, C. J., &amp; Andrews, C. B. (2007). BIOSCREEN\u2010AT: BIOSCREEN with an exact analytical solution. Groundwater, 45(2), 242-245.</p> <p>Newell, C. J., McLeod, R. K., &amp; Gonzales, J. R. (1997). BIOSCREEN natural attenuation decision support system version 1.4 revisions, Tech. rep., U.S. EPA.</p> <p>Wexler, E. J. (1992). Analytical solutions for one-, two-, and three-dimensional solute transport in ground-water systems with uniform flow. US Government Printing Office.</p> Source code in <code>mibitrans/transport/models.py</code> <pre><code>class Mibitrans(Transport3D):\n    \"\"\"Model class using an exact analytical solution as described in Karanovic (2007), based on Wexler (1992).\n\n    Karanovic (2007) implemented the Wexler (1992) exact analytical solution in the Excel based BIOSCREEN-AT, and added\n    source depletion, akin to that implemented in its predecessor BIOSCREEN by Newell et al. (1997). The Mibitrans model\n    allows for the same method as used in BIOSCREEN-AT, but expands it by allowing multiple source zones (by means of\n    superposition) and including the instant reaction model. These were present in the original BIOSCREEN, but not\n    reimplemented in BIOSCREEN-AT. Using a single source zone in this model, and not using the instant reaction option\n    will make the Mibitrans solution resolve to the equation described in Karanovic (2007). Which in turn resolves to\n    the Wexler (1992) solution if source depletion is disabled.\n\n    Karanovic, M., Neville, C. J., &amp; Andrews, C. B. (2007). BIOSCREEN\u2010AT: BIOSCREEN with an exact analytical solution.\n    Groundwater, 45(2), 242-245.\n\n    Newell, C. J., McLeod, R. K., &amp; Gonzales, J. R. (1997). BIOSCREEN natural attenuation decision support\n    system version 1.4 revisions, Tech. rep., U.S. EPA.\n\n    Wexler, E. J. (1992). Analytical solutions for one-, two-, and three-dimensional solute transport in ground-water\n    systems with uniform flow. US Government Printing Office.\n    \"\"\"\n\n    def __init__(\n        self,\n        hydrological_parameters,\n        attenuation_parameters,\n        source_parameters,\n        model_parameters,\n        verbose=False,\n    ):\n        \"\"\"Initialize model object.\n\n        Args:\n            hydrological_parameters (mibitrans.data.parameters.HydrologicalParameters) : Dataclass object containing\n                hydrological parameters from HydrologicalParameters.\n            attenuation_parameters (mibitrans.data.read.AttenuationParameters) : Dataclass object containing adsorption,\n                degradation and diffusion parameters from AttenuationParameters.\n            source_parameters (mibitrans.data.read.SourceParameters) : Dataclass object containing source parameters\n                from SourceParameters.\n            model_parameters (mibitrans.data.read.ModelParameters) : Dataclass object containing model parameters from\n                ModelParameters.\n            verbose (bool, optional): Verbose mode. Defaults to False.\n\n        Attributes:\n            mode (str) : Current model mode. Is 'linear' by default. Once instant reaction parameters are provided. Use\n                this attribute to switch between 'linear' and 'instant_reaction' models.\n            cxyt (np.ndarray) : Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]\n            relative_cxyt (np.ndarray) : Output array with concentrations in model domain, divided by the maximum source\n                zone concentration at t=0. Indexed as [t,y,x].\n            x (np.ndarray) : Discretized model x-dimension, in [m].\n            y (np.ndarray) : Discretized model y-dimension, in [y].\n            t (np.ndarray) : Discretized model t-dimension, in [days].\n            c_source (np.ndarray) : Nett source zone concentrations, accounting for source superposition, in [g/m^3].\n            vr (float) : Retarded groundwater flow velocity, in [m/d].\n            k_source (float) : Source zone decay rate, in [1/days].\n            biodegradation_capacity (float) : Maximum capacity of biodegradation given provided electron acceptor\n            concentrations, in [g/m^3].\n\n        Methods:\n            run : Run model with current parameters, returns Results object.\n            sample : Calculate concentration at any given position and point in time.\n            instant_reaction : Activate the instant reaction model by providing electron acceptor concentrations. And\n                optionally electron acceptor utilization factors. Switch between model modes by using the mode\n                attribute.\n\n        Raises:\n            TypeError : If input is not of the correct Dataclass.\n\n        Example::\n\n            obj = Mibitrans(\n                hydrological_parameters=HydrologicalParameters(),\n                attenuation_parameters=AttenuationParameters(),\n                source_parameters=SourceParameters(),\n                model_parameters=ModelParameters()\n            )\n            results = obj.run()\n\n        \"\"\"\n        super().__init__(hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose)\n\n    @property\n    def short_description(self):\n        \"\"\"Return short description of model type.\"\"\"\n        if self.biodegradation_capacity:\n            return \"Mibitrans Instant Reaction\"\n        else:\n            return \"Mibitrans Linear\"\n\n    def run(self):\n        \"\"\"Calculate the concentration for all discretized x, y and t using the analytical transport model.\"\"\"\n        self._check_model_mode_before_run()\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            self.cxyt = self._calculate_concentration_for_all_xyt()\n        return Results(self)\n\n    def sample(self, x_position, y_position, time):\n        \"\"\"Give concentration at any given position and point in time.\n\n        Args:\n            x_position (float): x position in domain extent [m].\n            y_position (float): y position in domain extent [m].\n            time (float): time for which concentration is sampled [days].\n\n        Returns:\n            concentration (float): concentration at given position and point in time [g/m^3].\n\n        \"\"\"\n        # Different sample method than parent class, as field-wide calculations use array indices\n        for par, value in locals().items():\n            if par != \"self\":\n                validate_input_values(par, value)\n\n        self._pre_run_initialization_parameters()\n\n        def integrand(t, sz):\n            div_term = 2 * np.sqrt(self.disp_y * t**4)\n            inner_term = self._src_pars.depth / (2 * np.sqrt(self.disp_z * t**4))\n            integrand_results = (\n                1\n                / (t**3)\n                * (\n                    np.exp(\n                        (self.k_source - self._decay_rate) * t**4\n                        - (x_position - self.rv * t**4) ** 2 / (4 * self.disp_x * t**4)\n                    )\n                    * (\n                        erfc((y_position - self.y_source[sz]) / div_term)\n                        - erfc((y_position + self.y_source[sz]) / div_term)\n                    )\n                    * (erfc(-inner_term) - erfc(inner_term))\n                )\n            )\n            return integrand_results\n\n        conc_array = np.zeros(len(self.c_source))\n        error_array = np.zeros(len(self.c_source))\n        time = time ** (1 / 4)\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            for sz in range(len(self.c_source)):\n                integral_term, error = quad(integrand, 0, time, limit=10000, args=(sz,))\n                source_term = (\n                    self.c_source[sz] * x_position / (8 * np.sqrt(np.pi * self.disp_x)) * np.exp(-self.k_source * time)\n                )\n                conc_array[sz] = 4 * integral_term * source_term\n                error_array[sz] = error\n            concentration = np.sum(conc_array)\n            if self._mode == \"instant_reaction\":\n                concentration -= self.biodegradation_capacity\n                if concentration &lt; 0:\n                    concentration = 0\n        return concentration\n\n    def _pre_run_initialization_parameters(self):\n        super()._pre_run_initialization_parameters()\n        self.disp_x = self._hyd_pars.alpha_x * self.rv + self._att_pars.diffusion\n        self.disp_y = self._hyd_pars.alpha_y * self.rv + self._att_pars.diffusion\n        self.disp_z = self._hyd_pars.alpha_z * self.rv + self._att_pars.diffusion\n        # self.integral_term = np.zeros(self.ttt.shape)\n        # Stores integral error for each time step and source zone\n        self.error_size = np.zeros((len(self._src_pars.source_zone_boundary), len(self.t)))\n\n    def _calculate_concentration_for_all_xyt(self):\n        cxyt = self.cxyt.copy()\n        for sz in range(len(self.c_source)):\n            integral_sum = self._equation_term_integral(sz)\n            source_term = self._equation_term_source(sz)\n            cxyt[:, :, 1:] += integral_sum[:, :, 1:] * source_term\n            # If x=0, equation resolves to c=0, therefore, x=0 needs to be evaluated separately\n            cxyt[:, :, 0] += self._equation_term_source_x_is_zero(sz)[:, :, 0]\n        if self._mode == \"instant_reaction\":\n            self.cxyt_noBC = cxyt.copy()\n            cxyt -= self.biodegradation_capacity\n            cxyt = np.where(cxyt &lt; 0, 0, cxyt)\n        return cxyt\n\n    def _equation_term_integral(self, sz):\n        integral_term = np.zeros(self.cxyt.shape)\n        for j in range(len(self.t)):\n            if self.verbose:\n                print(\"integrating for source zone \", sz, \" and t =\", self.t[j], \"days\")\n            if j == 0:\n                lower_bound = 0\n            else:\n                lower_bound = self.t[j - 1]\n            upper_bound = self.t[j]\n            integral_term[j, :, 1:], self.error_size[sz, j] = quad_vec(\n                self._equation_integrand, lower_bound, upper_bound, limit=10000 // len(self.t), args=(sz,)\n            )\n        integral_sum = np.cumsum(integral_term, axis=0)\n        return integral_sum\n\n    def _equation_integrand(self, t, sz):\n        term = 1 / (t ** (3 / 2)) * self._equation_term_x(t) * self._equation_term_y(t, sz) * self._equation_term_z(t)\n        term[np.isnan(term)] = 0\n        return term\n\n    def _equation_term_x(self, t):\n        term = np.exp(\n            (self.k_source - self._decay_rate) * t - (self.xxx[:, :, 1:] - self.rv * t) ** 2 / (4 * self.disp_x * t)\n        )\n        term[np.isnan(term)] = 0\n        return term\n\n    def _equation_term_y(self, t, sz):\n        div_term = 2 * np.sqrt(self.disp_y * t)\n        term = erfc((self.yyy - self.y_source[sz]) / div_term) - erfc((self.yyy + self.y_source[sz]) / div_term)\n        term[np.isnan(term)] = 0\n        return term\n\n    def _equation_term_z(self, t):\n        if t == 0 or self.disp_z == 0:\n            inner_term = 2\n        else:\n            inner_term = self._src_pars.depth / (2 * np.sqrt(self.disp_z * t))\n        return erfc(-inner_term) - erfc(inner_term)\n\n    def _equation_term_source(self, sz):\n        return (\n            self.c_source[sz]\n            * self.xxx[:, :, 1:]\n            / (8 * np.sqrt(np.pi * self.disp_x))\n            * np.exp(-self.k_source * self.ttt)\n        )\n\n    def _equation_term_source_x_is_zero(self, sz):\n        # Select y-positions of current source zone\n        zone_location = np.where(abs(self.yyy) &lt;= self.y_source[sz], 1, 0)\n        return self.c_source[sz] * zone_location * np.exp(-self.k_source * self.ttt)\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.models.Mibitrans.short_description","title":"<code>short_description</code>  <code>property</code>","text":"<p>Return short description of model type.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.models.Mibitrans.__init__","title":"<code>__init__(hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose=False)</code>","text":"<p>Initialize model object.</p> <p>Parameters:</p> Name Type Description Default <code>hydrological_parameters (mibitrans.data.parameters.HydrologicalParameters) </code> <p>Dataclass object containing hydrological parameters from HydrologicalParameters.</p> required <code>attenuation_parameters (mibitrans.data.read.AttenuationParameters) </code> <p>Dataclass object containing adsorption, degradation and diffusion parameters from AttenuationParameters.</p> required <code>source_parameters (mibitrans.data.read.SourceParameters) </code> <p>Dataclass object containing source parameters from SourceParameters.</p> required <code>model_parameters (mibitrans.data.read.ModelParameters) </code> <p>Dataclass object containing model parameters from ModelParameters.</p> required <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>mode</code> <code>str) </code> <p>Current model mode. Is \u2018linear\u2019 by default. Once instant reaction parameters are provided. Use this attribute to switch between \u2018linear\u2019 and \u2018instant_reaction\u2019 models.</p> <code>cxyt</code> <code>np.ndarray) </code> <p>Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]</p> <code>relative_cxyt</code> <code>np.ndarray) </code> <p>Output array with concentrations in model domain, divided by the maximum source zone concentration at t=0. Indexed as [t,y,x].</p> <code>x</code> <code>np.ndarray) </code> <p>Discretized model x-dimension, in [m].</p> <code>y</code> <code>np.ndarray) </code> <p>Discretized model y-dimension, in [y].</p> <code>t</code> <code>np.ndarray) </code> <p>Discretized model t-dimension, in [days].</p> <code>c_source</code> <code>np.ndarray) </code> <p>Nett source zone concentrations, accounting for source superposition, in [g/m^3].</p> <code>vr</code> <code>float) </code> <p>Retarded groundwater flow velocity, in [m/d].</p> <code>k_source</code> <code>float) </code> <p>Source zone decay rate, in [1/days].</p> <code>biodegradation_capacity</code> <code>float) </code> <p>Maximum capacity of biodegradation given provided electron acceptor</p> <p>Functions:</p> Name Description <code>run </code> <p>Run model with current parameters, returns Results object.</p> <code>sample </code> <p>Calculate concentration at any given position and point in time.</p> <code>instant_reaction </code> <p>Activate the instant reaction model by providing electron acceptor concentrations. And optionally electron acceptor utilization factors. Switch between model modes by using the mode attribute.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input is not of the correct Dataclass.</p> <p>Example::</p> <pre><code>obj = Mibitrans(\n    hydrological_parameters=HydrologicalParameters(),\n    attenuation_parameters=AttenuationParameters(),\n    source_parameters=SourceParameters(),\n    model_parameters=ModelParameters()\n)\nresults = obj.run()\n</code></pre> Source code in <code>mibitrans/transport/models.py</code> <pre><code>def __init__(\n    self,\n    hydrological_parameters,\n    attenuation_parameters,\n    source_parameters,\n    model_parameters,\n    verbose=False,\n):\n    \"\"\"Initialize model object.\n\n    Args:\n        hydrological_parameters (mibitrans.data.parameters.HydrologicalParameters) : Dataclass object containing\n            hydrological parameters from HydrologicalParameters.\n        attenuation_parameters (mibitrans.data.read.AttenuationParameters) : Dataclass object containing adsorption,\n            degradation and diffusion parameters from AttenuationParameters.\n        source_parameters (mibitrans.data.read.SourceParameters) : Dataclass object containing source parameters\n            from SourceParameters.\n        model_parameters (mibitrans.data.read.ModelParameters) : Dataclass object containing model parameters from\n            ModelParameters.\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Attributes:\n        mode (str) : Current model mode. Is 'linear' by default. Once instant reaction parameters are provided. Use\n            this attribute to switch between 'linear' and 'instant_reaction' models.\n        cxyt (np.ndarray) : Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]\n        relative_cxyt (np.ndarray) : Output array with concentrations in model domain, divided by the maximum source\n            zone concentration at t=0. Indexed as [t,y,x].\n        x (np.ndarray) : Discretized model x-dimension, in [m].\n        y (np.ndarray) : Discretized model y-dimension, in [y].\n        t (np.ndarray) : Discretized model t-dimension, in [days].\n        c_source (np.ndarray) : Nett source zone concentrations, accounting for source superposition, in [g/m^3].\n        vr (float) : Retarded groundwater flow velocity, in [m/d].\n        k_source (float) : Source zone decay rate, in [1/days].\n        biodegradation_capacity (float) : Maximum capacity of biodegradation given provided electron acceptor\n        concentrations, in [g/m^3].\n\n    Methods:\n        run : Run model with current parameters, returns Results object.\n        sample : Calculate concentration at any given position and point in time.\n        instant_reaction : Activate the instant reaction model by providing electron acceptor concentrations. And\n            optionally electron acceptor utilization factors. Switch between model modes by using the mode\n            attribute.\n\n    Raises:\n        TypeError : If input is not of the correct Dataclass.\n\n    Example::\n\n        obj = Mibitrans(\n            hydrological_parameters=HydrologicalParameters(),\n            attenuation_parameters=AttenuationParameters(),\n            source_parameters=SourceParameters(),\n            model_parameters=ModelParameters()\n        )\n        results = obj.run()\n\n    \"\"\"\n    super().__init__(hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose)\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.models.Mibitrans.run","title":"<code>run()</code>","text":"<p>Calculate the concentration for all discretized x, y and t using the analytical transport model.</p> Source code in <code>mibitrans/transport/models.py</code> <pre><code>def run(self):\n    \"\"\"Calculate the concentration for all discretized x, y and t using the analytical transport model.\"\"\"\n    self._check_model_mode_before_run()\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        self.cxyt = self._calculate_concentration_for_all_xyt()\n    return Results(self)\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.models.Mibitrans.sample","title":"<code>sample(x_position, y_position, time)</code>","text":"<p>Give concentration at any given position and point in time.</p> <p>Parameters:</p> Name Type Description Default <code>x_position</code> <code>float</code> <p>x position in domain extent [m].</p> required <code>y_position</code> <code>float</code> <p>y position in domain extent [m].</p> required <code>time</code> <code>float</code> <p>time for which concentration is sampled [days].</p> required <p>Returns:</p> Name Type Description <code>concentration</code> <code>float</code> <p>concentration at given position and point in time [g/m^3].</p> Source code in <code>mibitrans/transport/models.py</code> <pre><code>def sample(self, x_position, y_position, time):\n    \"\"\"Give concentration at any given position and point in time.\n\n    Args:\n        x_position (float): x position in domain extent [m].\n        y_position (float): y position in domain extent [m].\n        time (float): time for which concentration is sampled [days].\n\n    Returns:\n        concentration (float): concentration at given position and point in time [g/m^3].\n\n    \"\"\"\n    # Different sample method than parent class, as field-wide calculations use array indices\n    for par, value in locals().items():\n        if par != \"self\":\n            validate_input_values(par, value)\n\n    self._pre_run_initialization_parameters()\n\n    def integrand(t, sz):\n        div_term = 2 * np.sqrt(self.disp_y * t**4)\n        inner_term = self._src_pars.depth / (2 * np.sqrt(self.disp_z * t**4))\n        integrand_results = (\n            1\n            / (t**3)\n            * (\n                np.exp(\n                    (self.k_source - self._decay_rate) * t**4\n                    - (x_position - self.rv * t**4) ** 2 / (4 * self.disp_x * t**4)\n                )\n                * (\n                    erfc((y_position - self.y_source[sz]) / div_term)\n                    - erfc((y_position + self.y_source[sz]) / div_term)\n                )\n                * (erfc(-inner_term) - erfc(inner_term))\n            )\n        )\n        return integrand_results\n\n    conc_array = np.zeros(len(self.c_source))\n    error_array = np.zeros(len(self.c_source))\n    time = time ** (1 / 4)\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        for sz in range(len(self.c_source)):\n            integral_term, error = quad(integrand, 0, time, limit=10000, args=(sz,))\n            source_term = (\n                self.c_source[sz] * x_position / (8 * np.sqrt(np.pi * self.disp_x)) * np.exp(-self.k_source * time)\n            )\n            conc_array[sz] = 4 * integral_term * source_term\n            error_array[sz] = error\n        concentration = np.sum(conc_array)\n        if self._mode == \"instant_reaction\":\n            concentration -= self.biodegradation_capacity\n            if concentration &lt; 0:\n                concentration = 0\n    return concentration\n</code></pre>"},{"location":"reference/reference_visualize/","title":"<code>mibitrans.visualize</code> API reference","text":""},{"location":"reference/reference_visualize/#mibitrans.visualize.animation","title":"<code>animation</code>","text":""},{"location":"reference/reference_visualize/#mibitrans.visualize.animation.animate_1d","title":"<code>animate_1d(x_axis_parameter, y_axis_parameter, time_parameter, y_names=None, y_colors=None, linestyle=None)</code>","text":"<p>Animate any type and number of input 1D plottables.</p> Source code in <code>mibitrans/visualize/animation.py</code> <pre><code>def animate_1d(\n    x_axis_parameter: np.ndarray, y_axis_parameter, time_parameter, y_names=None, y_colors=None, linestyle=None\n):\n    \"\"\"Animate any type and number of input 1D plottables.\"\"\"\n    if not isinstance(y_axis_parameter, list):\n        y_axis_parameter = [y_axis_parameter]\n    fig, ax = plt.subplots()\n    plot_bin = []\n    max_conc = 0\n    for i, y in enumerate(y_axis_parameter):\n        line = ax.plot(x_axis_parameter, y[0, :], color=y_colors[i], label=y_names[i], linestyle=linestyle[i])[0]\n        if np.max(y) &gt; max_conc:\n            max_conc = np.max(y)\n        plot_bin.append(line)\n    ax.set_ylim(bottom=0, top=max_conc + max_conc / 10)\n    ax.set_xlabel(\"Distance from source [m]\")\n    ax.set_ylabel(\"Concentration [g/m3]\")\n    ax.legend()\n    n_frames = len(time_parameter)\n\n    def update(frame):\n        \"\"\"Update plot with values for the next time step in the animation.\"\"\"\n        for i, y in enumerate(y_axis_parameter):\n            plot_bin[i].set_xdata(x_axis_parameter)\n            plot_bin[i].set_ydata(y[frame, :])\n        ax.set_title(f\"Concentration distribution at t={time_parameter[frame]} days\")\n        return plot_bin\n\n    ani = animation.FuncAnimation(fig=fig, func=update, frames=n_frames)\n    return ani\n</code></pre>"},{"location":"reference/reference_visualize/#mibitrans.visualize.plot_line","title":"<code>plot_line</code>","text":"<p>Author: Jorrit Bakker.</p> <p>Module plotting a 3D matrix of contaminant plume concentrations as a line.</p>"},{"location":"reference/reference_visualize/#mibitrans.visualize.plot_line.allowed_model_types","title":"<code>allowed_model_types()</code>","text":"<p>Return object of parent class that is allowed for input/output.</p> Source code in <code>mibitrans/visualize/plot_line.py</code> <pre><code>def allowed_model_types():\n    \"\"\"Return object of parent class that is allowed for input/output.\"\"\"\n    return mibitrans.transport.model_parent.Results\n</code></pre>"},{"location":"reference/reference_visualize/#mibitrans.visualize.plot_line.breakthrough","title":"<code>breakthrough(model, x_position, y_position=0, relative_concentration=False, legend_names=None, animate=False, **kwargs)</code>","text":"<p>Plot contaminant breakthrough curve at given x and y position in model domain.</p> <p>Parameters:</p> Name Type Description Default <code>model </code> <p>Model object from mibitrans.transport, or list of model objects.</p> required <code>x_position </code> <p>x-position along the plume (longitudinal direction).</p> required <code>y_position </code> <p>y-position across the plume (transverse horizontal direction). By default, at the center of the plume (at y=0).</p> required <code>relative_concentration (bool, optional) </code> <p>If set to True, will plot concentrations relative to maximum source zone concentrations at t=0. By default, absolute concentrations are shown.</p> required <code>legend_names</code> <code>str | list</code> <p>List of legend names as strings, in the same order as given models. By default, no legend is shown.</p> <code>None</code> <code>animate</code> <code>bool</code> <p>If True, animation of contaminant plume until given time is shown. If multiple models are given as input, dt should be the same for each one to ensure accurate animation. Default is False.</p> <code>False</code> <code>**kwargs </code> <p>Arguments to be passed to plt.plot().</p> required Source code in <code>mibitrans/visualize/plot_line.py</code> <pre><code>def breakthrough(\n    model, x_position, y_position=0, relative_concentration=False, legend_names=None, animate=False, **kwargs\n):\n    \"\"\"Plot contaminant breakthrough curve at given x and y position in model domain.\n\n    Args:\n        model : Model object from mibitrans.transport, or list of model objects.\n        x_position : x-position along the plume (longitudinal direction).\n        y_position : y-position across the plume (transverse horizontal direction).\n            By default, at the center of the plume (at y=0).\n        relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum source\n            zone concentrations at t=0. By default, absolute concentrations are shown.\n        legend_names (str | list, optional): List of legend names as strings, in the same order as given models.\n            By default, no legend is shown.\n        animate (bool, optional): If True, animation of contaminant plume until given time is shown. If multiple models\n            are given as input, dt should be the same for each one to ensure accurate animation. Default is False.\n        **kwargs : Arguments to be passed to plt.plot().\n    \"\"\"\n    if not isinstance(model, list):\n        model = [model]\n    if not isinstance(legend_names, list) and legend_names is not None:\n        legend_names = [legend_names]\n\n    plot_array_list = []\n    # Checks for list model input: dt should be equal, time should be smaller than the smallest end time, y_position\n    # should be inside narrowest domain boundaries\n    for mod in model:\n        check_model_type(mod, allowed_model_types())\n        x_pos = check_x_in_domain(mod, x_position)\n        y_pos = check_y_in_domain(mod, y_position)\n        if relative_concentration:\n            plot_array_list.append(mod.relative_cxyt[:, y_pos, x_pos])\n            y_label = relative_conc_ylabel\n        else:\n            plot_array_list.append(mod.cxyt[:, y_pos, x_pos])\n            y_label = absolute_conc_ylabel\n\n    # Non animated plot\n    if not animate:\n        for i, mod in enumerate(model):\n            if legend_names is not None:\n                plt.plot(mod.t, plot_array_list[i], label=legend_names[i], **kwargs)\n            else:\n                plt.plot(mod.t, plot_array_list[i], **kwargs)\n\n        plt.ylim(bottom=0)\n        plt.xlabel(\"Time [days]\")\n        plt.ylabel(y_label)\n        plot_title = _plot_title_generator(\n            \"Breakthrough\", model[0], x_position=x_position, y_position=y_position, multiple=len(model) &gt; 1\n        )\n        plt.title(plot_title)\n        if legend_names is not None:\n            plt.legend()\n\n    # Animated plot\n    else:\n        fig, ax = plt.subplots()\n        plot_bin = []\n        max_conc = 0\n        max_time = 0\n        for i, mod in enumerate(model):\n            if legend_names is not None:\n                line = ax.plot(mod.t[0], plot_array_list[i][0], label=legend_names[i])[0]\n            else:\n                line = ax.plot(mod.t[0], plot_array_list[i][0], **kwargs)[0]\n\n            # As plot extent is decided by first initiation of plot, ensure that axis concentration and time limits\n            # are corresponding with their maximum values\n            if mod.t[-1] &gt; max_time:\n                max_time = mod.t[-1]\n            if np.max(plot_array_list[i]) &gt; max_conc:\n                max_conc = np.max(plot_array_list[i])\n            plot_bin.append(line)\n        ax.set_xlim(right=max_time)\n        ax.set_ylim(bottom=0, top=max_conc + max_conc / 10)\n        ax.set_xlabel(\"Time [days]\")\n        ax.set_ylabel(y_label)\n        if legend_names is not None:\n            ax.legend()\n\n        def update(frame):\n            for i, mod in enumerate(model):\n                plot_bin[i].set_xdata(mod.t[:frame])\n                plot_bin[i].set_ydata(plot_array_list[i][:frame])\n                ax.set_title(f\"Breakthrough curve at t={mod.t[frame]} days\")\n            return plot_bin\n\n        ani = animation.FuncAnimation(fig=fig, func=update, frames=len(model[0].t))\n        return ani\n</code></pre>"},{"location":"reference/reference_visualize/#mibitrans.visualize.plot_line.centerline","title":"<code>centerline(model, y_position=0, time=None, relative_concentration=False, legend_names=None, animate=False, **kwargs)</code>","text":"<p>Plot center of contaminant plume of one or multiple models as a line, at a specified time and y position.</p> <p>Parameters:</p> Name Type Description Default <code>model </code> <p>Model object from mibitrans.transport, or list of model objects.</p> required <code>y_position</code> <code>float</code> <p>y-position across the plume (transverse horizontal direction) for the plot. By default, the center of the plume at y=0 is plotted.</p> <code>0</code> <code>time</code> <code>float</code> <p>Point of time for the plot. Will show the closest time step to given value. By default, last point in time is plotted.</p> <code>None</code> <code>relative_concentration (bool, optional) </code> <p>If set to True, will plot concentrations relative to maximum source zone concentrations at t=0. By default, absolute concentrations are shown.</p> required <code>legend_names</code> <code>str | list</code> <p>List of legend names as strings, in the same order as given models. By default, no legend is shown.</p> <code>None</code> <code>animate</code> <code>bool</code> <p>If True, animation of contaminant plume until given time is shown. If multiple models are given as input, dt should be the same for each one to ensure accurate animation. Default is False.</p> <code>False</code> <code>**kwargs </code> <p>Arguments to be passed to plt.plot().</p> required Source code in <code>mibitrans/visualize/plot_line.py</code> <pre><code>def centerline(\n    model, y_position=0, time=None, relative_concentration=False, legend_names=None, animate=False, **kwargs\n):\n    \"\"\"Plot center of contaminant plume of one or multiple models as a line, at a specified time and y position.\n\n    Args:\n        model : Model object from mibitrans.transport, or list of model objects.\n        y_position (float, optional): y-position across the plume (transverse horizontal direction) for the plot.\n            By default, the center of the plume at y=0 is plotted.\n        time (float, optional): Point of time for the plot. Will show the closest time step to given value.\n            By default, last point in time is plotted.\n        relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum source\n            zone concentrations at t=0. By default, absolute concentrations are shown.\n        legend_names (str | list, optional): List of legend names as strings, in the same order as given models.\n            By default, no legend is shown.\n        animate (bool, optional): If True, animation of contaminant plume until given time is shown. If multiple models\n            are given as input, dt should be the same for each one to ensure accurate animation. Default is False.\n        **kwargs : Arguments to be passed to plt.plot().\n\n    \"\"\"\n    if not isinstance(model, list):\n        model = [model]\n    if not isinstance(legend_names, list) and legend_names is not None:\n        legend_names = [legend_names]\n\n    plot_array_list = []\n    # Checks for list model input: dt should be equal, time should be smaller than the smallest end time, y_position\n    # should be inside narrowest domain boundaries\n    for mod in model:\n        check_model_type(mod, allowed_model_types())\n        y_pos = check_y_in_domain(mod, y_position)\n        t_pos = check_time_in_domain(mod, time)\n\n        if relative_concentration:\n            if animate:\n                plot_array_list.append(mod.relative_cxyt[:, y_pos, :])\n            else:\n                plot_array_list.append(mod.relative_cxyt[t_pos, y_pos, :])\n            y_label = relative_conc_ylabel\n        else:\n            if animate:\n                plot_array_list.append(mod.cxyt[:, y_pos, :])\n            else:\n                plot_array_list.append(mod.cxyt[t_pos, y_pos, :])\n            y_label = absolute_conc_ylabel\n\n    # Non-animated plot\n    if not animate:\n        for i, mod in enumerate(model):\n            if legend_names is not None:\n                plt.plot(mod.x, plot_array_list[i], label=legend_names[i], **kwargs)\n            else:\n                plt.plot(mod.x, plot_array_list[i], **kwargs)\n\n        plt.ylim(bottom=0)\n        plt.xlabel(\"Distance from source [m]\")\n        plt.ylabel(y_label)\n\n        plot_title = _plot_title_generator(\n            \"Centerline\", model[0], time=model[0].t[t_pos], y_position=y_position, multiple=len(model) &gt; 1\n        )\n        plt.title(plot_title)\n        if legend_names is not None:\n            plt.legend()\n\n    # Animated plot\n    else:\n        fig, ax = plt.subplots()\n        plot_bin = []\n        for i, mod in enumerate(model):\n            if legend_names is not None:\n                line = ax.plot(mod.x, plot_array_list[i][0, :], label=legend_names[i], **kwargs)[0]\n            else:\n                line = ax.plot(mod.x, plot_array_list[i][0, :], **kwargs)[0]\n            plot_bin.append(line)\n        ax.set_ylim(bottom=0)\n        ax.set_xlabel(\"Distance from source [m]\")\n        ax.set_ylabel(y_label)\n\n        if legend_names is not None:\n            ax.legend()\n\n        def update(frame):\n            for i, mod in enumerate(model):\n                plot_bin[i].set_xdata(mod.x)\n                plot_bin[i].set_ydata(plot_array_list[i][frame, :])\n                ax.set_title(f\"Concentration distribution at t={mod.t[frame]} days\")\n            return plot_bin\n\n        ani = animation.FuncAnimation(fig=fig, func=update, frames=t_pos + 1)\n        return ani\n</code></pre>"},{"location":"reference/reference_visualize/#mibitrans.visualize.plot_line.transverse","title":"<code>transverse(model, x_position, time=None, relative_concentration=False, legend_names=None, animate=False, **kwargs)</code>","text":"<p>Plot concentration distribution as a line horizontal transverse to the plume extent.</p> <p>Parameters:</p> Name Type Description Default <code>model </code> <p>Model object from mibitrans.transport, or list of model objects.</p> required <code>x_position </code> <p>x-position along the plume (longitudinal direction) for the plot.</p> required <code>time</code> <code>float</code> <p>Point of time for the plot. Will show the closest time step to given value. By default, last point in time is plotted.</p> <code>None</code> <code>relative_concentration (bool, optional) </code> <p>If set to True, will plot concentrations relative to maximum source zone concentrations at t=0. By default, absolute concentrations are shown.</p> required <code>legend_names</code> <code>str | list</code> <p>List of legend names as strings, in the same order as given models. By default, no legend is shown.</p> <code>None</code> <code>animate</code> <code>bool</code> <p>If True, animation of contaminant plume until given time is shown. If multiple models are given as input, dt should be the same for each one to ensure accurate animation. Default is False.</p> <code>False</code> <code>**kwargs </code> <p>Arguments to be passed to plt.plot().</p> required Source code in <code>mibitrans/visualize/plot_line.py</code> <pre><code>def transverse(model, x_position, time=None, relative_concentration=False, legend_names=None, animate=False, **kwargs):\n    \"\"\"Plot concentration distribution as a line horizontal transverse to the plume extent.\n\n    Args:\n        model : Model object from mibitrans.transport, or list of model objects.\n        x_position : x-position along the plume (longitudinal direction) for the plot.\n        time (float): Point of time for the plot. Will show the closest time step to given value.\n            By default, last point in time is plotted.\n        relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum source\n            zone concentrations at t=0. By default, absolute concentrations are shown.\n        legend_names (str | list, optional): List of legend names as strings, in the same order as given models.\n            By default, no legend is shown.\n        animate (bool, optional): If True, animation of contaminant plume until given time is shown. If multiple models\n            are given as input, dt should be the same for each one to ensure accurate animation. Default is False.\n        **kwargs : Arguments to be passed to plt.plot().\n    \"\"\"\n    if not isinstance(model, list):\n        model = [model]\n    if not isinstance(legend_names, list) and legend_names is not None:\n        legend_names = [legend_names]\n\n    plot_array_list = []\n    # Checks for list model input: dt should be equal, time should be smaller than the smallest end time, y_position\n    # should be inside narrowest domain boundaries\n    for mod in model:\n        check_model_type(mod, allowed_model_types())\n        x_pos = check_x_in_domain(mod, x_position)\n        t_pos = check_time_in_domain(mod, time)\n\n        if relative_concentration:\n            if animate:\n                plot_array_list.append(mod.relative_cxyt[:, :, x_pos])\n            else:\n                plot_array_list.append(mod.relative_cxyt[t_pos, :, x_pos])\n            y_label = relative_conc_ylabel\n        else:\n            if animate:\n                plot_array_list.append(mod.cxyt[:, :, x_pos])\n            else:\n                plot_array_list.append(mod.cxyt[t_pos, :, x_pos])\n            y_label = absolute_conc_ylabel\n\n    if not animate:\n        for i, mod in enumerate(model):\n            if legend_names is not None:\n                plt.plot(mod.y, plot_array_list[i], label=legend_names[i], **kwargs)\n            else:\n                plt.plot(mod.y, plot_array_list[i], **kwargs)\n\n        plt.ylim(bottom=0)\n        plt.xlabel(\"y-position [m]\")\n        plt.ylabel(y_label)\n        plot_title = _plot_title_generator(\n            \"Transverse\", model[0], time=model[0].t[t_pos], x_position=x_position, multiple=len(model) &gt; 1\n        )\n        plt.title(plot_title)\n        if legend_names is not None:\n            plt.legend()\n    else:\n        fig, ax = plt.subplots()\n        plot_bin = []\n        max_conc = 0\n        for i, mod in enumerate(model):\n            if legend_names is not None:\n                line = ax.plot(mod.y, plot_array_list[i][0, :], label=legend_names[i])[0]\n            else:\n                line = ax.plot(mod.y, plot_array_list[i][0, :], **kwargs)[0]\n            if np.max(plot_array_list[i]) &gt; max_conc:\n                max_conc = np.max(plot_array_list[i])\n            plot_bin.append(line)\n        ax.set_ylim(bottom=0, top=max_conc + max_conc / 10)\n\n        ax.set_xlabel(\"y-position [m]\")\n        ax.set_ylabel(y_label)\n\n        if legend_names is not None:\n            ax.legend()\n\n        def update(frame):\n            for i, mod in enumerate(model):\n                plot_bin[i].set_xdata(mod.y)\n                plot_bin[i].set_ydata(plot_array_list[i][frame, :])\n                ax.set_title(f\"Concentration distribution at t={mod.t[frame]} days\")\n            return plot_bin\n\n        ani = animation.FuncAnimation(fig=fig, func=update, frames=t_pos + 1)\n        return ani\n</code></pre>"},{"location":"reference/reference_visualize/#mibitrans.visualize.plot_surface","title":"<code>plot_surface</code>","text":""},{"location":"reference/reference_visualize/#mibitrans.visualize.plot_surface.plume_2d","title":"<code>plume_2d(model, time=None, relative_concentration=False, animate=False, **kwargs)</code>","text":"<p>Plot contaminant plume as a 2D colormesh, at a specified time.</p> <p>Parameters:</p> Name Type Description Default <code>model </code> <p>Model object from mibitrans.transport.</p> required <code>time</code> <code>float</code> <p>Point of time for the plot. Will show the closest time step to given value. By default, last point in time is plotted.</p> <code>None</code> <code>relative_concentration (bool, optional) </code> <p>If set to True, will plot concentrations relative to maximum source zone concentrations at t=0. By default, absolute concentrations are shown.</p> required <code>animate</code> <code>bool</code> <p>If True, animation of contaminant plume until given time is shown. Default is False.</p> <code>False</code> <code>**kwargs </code> <p>Arguments to be passed to plt.pcolormesh().</p> required <p>Returns a matrix plot of the input plume as object.</p> Source code in <code>mibitrans/visualize/plot_surface.py</code> <pre><code>def plume_2d(model, time=None, relative_concentration=False, animate=False, **kwargs):\n    \"\"\"Plot contaminant plume as a 2D colormesh, at a specified time.\n\n    Args:\n        model : Model object from mibitrans.transport.\n        time (float): Point of time for the plot. Will show the closest time step to given value.\n            By default, last point in time is plotted.\n        relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum source\n            zone concentrations at t=0. By default, absolute concentrations are shown.\n        animate (bool, optional): If True, animation of contaminant plume until given time is shown. Default is\n            False.\n        **kwargs : Arguments to be passed to plt.pcolormesh().\n\n    Returns a matrix plot of the input plume as object.\n    \"\"\"\n    check_model_type(model, allowed_model_types())\n    t_pos = check_time_in_domain(model, time)\n    if relative_concentration:\n        model_concentration = model.relative_cxyt\n        z_label = relative_conc_zlabel\n    else:\n        model_concentration = model.cxyt\n        z_label = absolute_conc_zlabel\n    # Non animated plot\n    if not animate:\n        plt.pcolormesh(model.x, model.y, model_concentration[t_pos, :, :], **kwargs)\n        plt.xlabel(\"Distance from source (m)\")\n        plt.ylabel(\"Distance from plume center (m)\")\n        plt.colorbar(label=z_label)\n        plot_title = _plot_title_generator(\"Plume\", model, time=model.t[t_pos])\n        plt.title(plot_title)\n\n    # Animated plot\n    else:\n        fig, ax = plt.subplots()\n        mesh = ax.pcolormesh(\n            model.x, model.y, model_concentration[0, :, :], vmin=0, vmax=np.max(model_concentration), **kwargs\n        )\n        cbar = fig.colorbar(mesh, ax=ax)\n        cbar.set_label(z_label)\n        ax.set_xlabel(\"Distance from source (m)\")\n        ax.set_ylabel(\"Distance from plume center (m)\")\n\n        def update(frame):\n            mesh.set_array(model_concentration[frame, :, :])\n            ax.set_title(f\"Concentration distribution at t={model.t[frame]} days\")\n            return mesh\n\n        ani = animation.FuncAnimation(fig=fig, func=update, frames=t_pos + 1)\n        return ani\n</code></pre>"},{"location":"reference/reference_visualize/#mibitrans.visualize.plot_surface.plume_3d","title":"<code>plume_3d(model, time=None, relative_concentration=False, animate=False, **kwargs)</code>","text":"<p>Plot contaminant plume as a 3D surface, at a specified time.</p> <p>Parameters:</p> Name Type Description Default <code>model </code> <p>Model object from mibitrans.transport.</p> required <code>time</code> <code>float</code> <p>Point of time for the plot. Will show the closest time step to given value. By default, last point in time is plotted.</p> <code>None</code> <code>relative_concentration (bool, optional) </code> <p>If set to True, will plot concentrations relative to maximum source zone concentrations at t=0. By default, absolute concentrations are shown.</p> required <code>animate</code> <code>bool</code> <p>If True, animation of contaminant plume until given time is shown. Default is False.</p> <code>False</code> <code>**kwargs </code> <p>Arguments to be passed to plt.plot_surface().</p> required <p>Returns:</p> Type Description <p>ax (matplotlib.axes._axes.Axes) : Returns matplotlib axes object of plume plot.</p> Source code in <code>mibitrans/visualize/plot_surface.py</code> <pre><code>def plume_3d(model, time=None, relative_concentration=False, animate=False, **kwargs):\n    \"\"\"Plot contaminant plume as a 3D surface, at a specified time.\n\n    Args:\n        model : Model object from mibitrans.transport.\n        time (float): Point of time for the plot. Will show the closest time step to given value.\n            By default, last point in time is plotted.\n        relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum source\n            zone concentrations at t=0. By default, absolute concentrations are shown.\n        animate (bool, optional): If True, animation of contaminant plume until given time is shown. Default is\n            False.\n        **kwargs : Arguments to be passed to plt.plot_surface().\n\n    Returns:\n        ax (matplotlib.axes._axes.Axes) : Returns matplotlib axes object of plume plot.\n    \"\"\"\n    check_model_type(model, allowed_model_types())\n    t_pos = check_time_in_domain(model, time)\n    if relative_concentration:\n        model_concentration = model.relative_cxyt\n        z_label = relative_conc_zlabel\n    else:\n        model_concentration = model.cxyt\n        z_label = absolute_conc_zlabel\n\n    # Non animated plot\n    xxx = np.tile(model.x, (len(model.t), len(model.y), 1))\n    yyy = np.tile(model.y[:, None], (len(model.t), 1, len(model.x)))\n    if not animate:\n        fig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\n        ax.plot_surface(xxx[t_pos, :, :], yyy[t_pos, :, :], model_concentration[t_pos, :, :], **kwargs)\n        ax.view_init(elev=30, azim=310)\n        ax.set_xlabel(\"Distance from source (m)\")\n        ax.set_ylabel(\"Distance from plume center (m)\")\n        ax.set_zlabel(z_label)\n        plot_title = _plot_title_generator(\"Plume\", model, time=model.t[t_pos])\n        ax.set_title(plot_title)\n        return ax\n\n    # Animated plot\n    else:\n        if \"cmap\" not in kwargs and \"color\" not in kwargs:\n            kwargs[\"color\"] = \"tab:blue\"\n        model_max = np.max(model_concentration)\n        fig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\n        surface = ax.plot_surface(\n            xxx[0, :, :],\n            yyy[0, :, :],\n            model_concentration[0, :, :],\n            vmin=0,\n            vmax=model_max,\n            **kwargs,\n        )\n        ax.set_xlabel(\"Distance from source (m)\")\n        ax.set_ylabel(\"Distance from plume center (m)\")\n        ax.set_zlabel(z_label)\n        ax.set_zlim(0, model_max)\n\n        # plot_surface creates a static surface; need to create new plot every time step\n        def update(frame):\n            # nonlocal needed in order for the previous plot to be removed before new one is plotted\n            nonlocal surface\n            surface.remove()\n            surface = ax.plot_surface(\n                xxx[frame, :, :],\n                yyy[frame, :, :],\n                model_concentration[frame, :, :],\n                vmin=0,\n                vmax=model_max,\n                **kwargs,\n            )\n            ax.set_title(f\"Concentration distribution at t={model.t[frame]} days\")\n            return surface\n\n        ani = animation.FuncAnimation(fig=fig, func=update, frames=t_pos + 1)\n        return ani\n</code></pre>"},{"location":"reference/reference_visualize/#mibitrans.visualize.show_conditions","title":"<code>show_conditions</code>","text":"<p>Author: Jorrit Bakker.</p> <p>Module including various methods to visualize (input) parameter conditions, intended to only be called internally.</p>"},{"location":"reference/reference_visualize/#mibitrans.visualize.show_conditions.model_grid","title":"<code>model_grid(model_parameters)</code>","text":"<p>Visualize the model grid.</p> Source code in <code>mibitrans/visualize/show_conditions.py</code> <pre><code>def model_grid(model_parameters):\n    \"\"\"Visualize the model grid.\"\"\"\n    return None\n</code></pre>"},{"location":"reference/reference_visualize/#mibitrans.visualize.show_conditions.source_zone","title":"<code>source_zone(source_parameters)</code>","text":"<p>Visualize source zone conditions.</p> Source code in <code>mibitrans/visualize/show_conditions.py</code> <pre><code>def source_zone(source_parameters):\n    \"\"\"Visualize source zone conditions.\"\"\"\n    source_y = source_parameters.source_zone_boundary\n    source_c = source_parameters.source_zone_concentration\n\n    y_discretization = np.linspace(-source_y[-1] - source_y[-1] / 10, source_y[-1] + source_y[-1] / 10, 10000)\n    c_values = np.zeros(len(y_discretization))\n    for i, y in enumerate(source_y[::-1]):\n        c_values = np.where((y_discretization &lt;= y) &amp; (y_discretization &gt;= -y), source_c[-(i + 1)], c_values)\n\n    indexer = np.linspace(1, 0.3, len(source_y))\n    colormap = matplotlib.colormaps[\"YlGnBu\"]\n\n    plt.figure(dpi=300)\n\n    for i, y in enumerate(source_y):\n        if i == 0:\n            plt.fill_betweenx(\n                y=y_discretization,\n                x1=c_values,\n                where=(y_discretization &lt;= y) &amp; (y_discretization &gt;= -y),\n                color=colormap(indexer[i]),\n                zorder=len(source_y) + 2,\n            )\n        else:\n            plt.fill_betweenx(\n                y=y_discretization,\n                x1=c_values,\n                # Boolean array for domain of source zone i\n                where=((y_discretization &lt;= y) &amp; (y_discretization &gt; source_y[i - 1]))\n                | ((y_discretization &gt;= -y) &amp; (y_discretization &lt; -source_y[i - 1])),\n                color=colormap(indexer[i]),\n                zorder=len(source_y) + 2 - i,\n            )\n\n    plt.xlabel(r\"Source zone concentration $g/m^3$\")\n    plt.ylabel(\"Source zone y-coordinate\")\n    plt.title(\"Concentration distribution in the source zone\")\n</code></pre>"}]}