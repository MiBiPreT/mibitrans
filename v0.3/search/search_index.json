{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documention for <code>mibitrans</code> python package","text":""},{"location":"#how-to-use-mibitrans","title":"How to use mibitrans","text":"<p>A collection of analytical and semi-semianalytical solutions for hydrogeological transport phenomena</p>"},{"location":"#installation","title":"Installation","text":"<p>To install mibitrans from GitHub repository, do:</p> <pre><code>git clone git@github.com:MiBiPreT/mibitrans.git\ncd mibitrans\npython -m pip install .\n</code></pre>"},{"location":"getting-started/development/","title":"<code>mibitrans</code> developer documentation","text":""},{"location":"getting-started/development/#development-install","title":"Development install","text":"<pre><code># Create a virtual environment, e.g. with\npython -m venv env\n\n# activate virtual environment\nsource env/bin/activate\n\n# make sure to have a recent version of pip and setuptools\npython -m pip install --upgrade pip setuptools\n\n# (from the project root directory)\n# install mibitrans as an editable package\npython -m pip install --no-cache-dir --editable .\n# install development dependencies\npython -m pip install --no-cache-dir --editable .[dev]\n</code></pre> <p>Afterwards check that the install directory is present in the <code>PATH</code> environment variable.</p>"},{"location":"getting-started/development/#running-the-tests","title":"Running the tests","text":"<p>There are two ways to run tests.</p> <p>The first way requires an activated virtual environment with the development tools installed:</p> <pre><code>pytest -v\n</code></pre> <p>The second is to use <code>tox</code>, which can be installed separately (e.g. with <code>pip install tox</code>), i.e. not necessarily inside the virtual environment you use for installing <code>mibitrans</code>, but then builds the necessary virtual environments itself by simply running:</p> <pre><code>tox\n</code></pre> <p>Testing with <code>tox</code> allows for keeping the testing environment separate from your development environment. The development environment will typically accumulate (old) packages during development that interfere with testing; this problem is avoided by testing with <code>tox</code>.</p>"},{"location":"getting-started/development/#test-coverage","title":"Test coverage","text":"<p>In addition to just running the tests to see if they pass, they can be used for coverage statistics, i.e. to determine how much of the package\u2019s code is actually executed during tests. In an activated virtual environment with the development tools installed, inside the package directory, run:</p> <pre><code>coverage run\n</code></pre> <p>This runs tests and stores the result in a <code>.coverage</code> file. To see the results on the command line, run</p> <pre><code>coverage report\n</code></pre> <p><code>coverage</code> can also generate output in HTML and other formats; see <code>coverage help</code> for more information.</p>"},{"location":"getting-started/development/#running-linters-locally","title":"Running linters locally","text":"<p>For linting and sorting imports we will use ruff. Running the linters requires an  activated virtual environment with the development tools installed.</p> <pre><code># linter\nruff check .\n\n# linter with automatic fixing\nruff check . --fix\n</code></pre> <p>To fix readability of your code style you can use yapf.</p> <p>You can enable automatic linting with <code>ruff</code> on commit by enabling the git hook from <code>.githooks/pre-commit</code>, like so:</p> <pre><code>git config --local core.hooksPath .githooks\n</code></pre>"},{"location":"getting-started/development/#testing-docs-locally","title":"Testing docs locally","text":"<p>To build the documentation locally, first make sure <code>mkdocs</code> and its dependencies are installed: <pre><code>python -m pip install .[doc]\n</code></pre></p> <p>Then you can build the documentation and serve it locally with <pre><code>mkdocs serve\n</code></pre></p> <p>This will return a URL (e.g. <code>http://127.0.0.1:8000/mibitrans/</code>) where the docs site can be viewed.</p>"},{"location":"getting-started/development/#versioning","title":"Versioning","text":"<p>Bumping the version across all files is done with bump-my-version, e.g.</p> <pre><code>bump-my-version major  # bumps from e.g. 0.3.2 to 1.0.0\nbump-my-version minor  # bumps from e.g. 0.3.2 to 0.4.0\nbump-my-version patch  # bumps from e.g. 0.3.2 to 0.3.3\n</code></pre>"},{"location":"getting-started/development/#making-a-release","title":"Making a release","text":"<p>This section describes how to make a release in 3 parts:</p> <ol> <li>preparation</li> <li>making a release on PyPI</li> <li>making a release on GitHub</li> </ol>"},{"location":"getting-started/development/#13-preparation","title":"(1/3) Preparation","text":"<ol> <li>Verify that the information in CITATION.cff is correct.</li> <li>Make sure the version has been updated.</li> <li>Run the unit tests with <code>pytest -v</code></li> </ol>"},{"location":"getting-started/development/#23-pypi","title":"(2/3) PyPI","text":"<p>In a new terminal:</p> <pre><code># OPTIONAL: prepare a new directory with fresh git clone to ensure the release\n# has the state of origin/main branch\ncd $(mktemp -d mibitrans.XXXXXX)\ngit clone git@github.com:MiBiPreT/mibitrans .\n\n# make sure to have a recent version of pip and the publishing dependencies\npython -m pip install --upgrade pip\npython -m pip install .[publishing]\n\n# create the source distribution and the wheel\npython -m build\n\n# upload to test pypi instance (requires credentials)\npython -m twine upload --repository testpypi dist/*\n</code></pre> <p>Visit https://test.pypi.org/</p> <p>and verify that your package was uploaded successfully. Keep the terminal open, we\u2019ll need it later.</p> <p>In a new terminal, without an activated virtual environment or an env directory:</p> <pre><code>cd $(mktemp -d mibitrans-test.XXXXXX)\n\n# prepare a clean virtual environment and activate it\npython -m venv env\nsource env/bin/activate\n\n# make sure to have a recent version of pip and setuptools\npython -m pip install --upgrade pip\n\n# install from test pypi instance:\npython -m pip -v install --no-cache-dir \\\n--index-url https://test.pypi.org/simple/ \\\n--extra-index-url https://pypi.org/simple mibitrans\n</code></pre> <p>Check that the package works as it should when installed from pypitest.</p> <p>Then upload to pypi.org with:</p> <pre><code># Back to the first terminal,\n# FINAL STEP: upload to PyPI (requires credentials)\npython -m twine upload dist/*\n</code></pre>"},{"location":"getting-started/development/#33-github","title":"(3/3) GitHub","text":"<p>Also make a release on GitHub. If your repository uses the GitHub-Zenodo integration this will also trigger Zenodo into making a snapshot of your repository and sticking a DOI on it.</p> <p>Github provides detailed documentation on how to generate a release. Here you can also automatically generate the release notes which can serve as a changelog based on the merged pull requests since the previous release. </p>"},{"location":"reference/reference/","title":"<code>mibitrans</code> API reference","text":"<p>Documentation about mibitrans.</p>"},{"location":"reference/reference/#mibitrans.analysis","title":"<code>analysis</code>","text":""},{"location":"reference/reference/#mibitrans.analysis.mass_balance","title":"<code>mass_balance</code>","text":"<p>Author: Jorrit Bakker.</p> <p>Module calculating the mass balance based on base parameters.</p>"},{"location":"reference/reference/#mibitrans.analysis.mass_balance.MassBalance","title":"<code>MassBalance</code>","text":"<p>Calculate contaminant mass balance across model compartments.</p> Source code in <code>mibitrans/analysis/mass_balance.py</code> <pre><code>class MassBalance:\n    \"\"\"Calculate contaminant mass balance across model compartments.\"\"\"\n    def __init__(self,\n                 parameters : dict,\n                 mode: str = \"no_decay\",\n                 dx : float = None,\n                 dy : float = None,\n                 dt : float = None,\n                 ) -&gt; None:\n        \"\"\"Initialise the class and internal variables.\n\n        Args:\n            parameters (dict) : Dictionary with transport parameters.\n            mode (str) : Type of analytical model to be used. Default is no decay model.\n            dx (float) : Model step size in x direction. If left empty,\n            reasonable value will be calculated based on modeled area length. Default is None.\n            dy (float) : Model step size in y direction. If left empty,\n            reasonable value will be calculated based on modeled area width. Default is None.\n            dt (float) : Model step size for time. If left empty,\n            reasonable value will be calculated based on simulation time. Default is None.\n\n        \"\"\"\n        self.pars = parameters\n        self.mode = mode\n        self.dx = dx\n        self.dy = dy\n        self.dt = dt\n        self.mass_balance_dict = {\n        }\n\n\n    def balance(self, time = None) -&gt; dict:\n        \"\"\"Calculates mass balance at a certain time point using the analytical equation for specified model type.\n\n        Returns:\n            mass_balance_dict (dict) : Dictionary containing mass for each mass balance component\n            relevant to the model type.\n        \"\"\"\n        obj_nodecay = eq.Transport(self.pars, dx = self.dx, dy = self.dy, dt = self.dt, mode = \"no_decay\")\n        cxyt_nd, x, y, t = obj_nodecay.domenico()\n\n        # If time point is specified, closest point in time array t is taken.\n        # If not specified, defaults to last time point.\n        if time is not None:\n            time_pos = np.argmin(abs(t - time))\n            self.mass_balance_dict[\"time\"] = t[time_pos]\n        else:\n            time_pos = -1\n            self.mass_balance_dict[\"time\"] = t[time_pos]\n\n        ksource = calculate_source_decay(self.pars)\n\n        # Total source mass at t=0\n        M_source_0 = self.pars[\"m_total\"] * 1000\n        self.mass_balance_dict[\"source_mass_0\"] = M_source_0\n\n        # Total source mass at t=t, for the no decay model\n        M_source_t = M_source_0 * np.exp(-ksource * t[time_pos])\n        self.mass_balance_dict[\"source_mass_t\"] = M_source_t\n\n        # Change in source mass at t=t, due to source decay by transport\n        M_source_delta = M_source_0 - M_source_t\n        self.mass_balance_dict[\"source_mass_change\"] = M_source_delta\n\n        # Volume of single cell, as dx * dy * source thickness\n        cellsize = abs(x[1] - x[2]) * abs(y[1] - y[2]) * self.pars[\"d_source\"]\n\n        # Plume mass of no decay model; concentration is converted to mass by multiplying by cellsize and pore space.\n        plume_mass_nodecay = np.sum(cxyt_nd[time_pos, :, 1:] * cellsize * self.pars[\"n\"])\n        self.mass_balance_dict[\"plume_mass_no_decay\"] = plume_mass_nodecay\n\n        # Difference between current plume mass and change in source mass must have been transported outside of model\n        # extent for no decay scenarios; preservation of mass.\n        if M_source_delta - plume_mass_nodecay &lt; 0:\n            transport_outside_extent_nodecay = 0\n            self.mass_balance_dict[\"transport_outside_extent\"] = transport_outside_extent_nodecay\n        else:\n            transport_outside_extent_nodecay = M_source_delta - plume_mass_nodecay\n            self.mass_balance_dict[\"transport_outside_extent_nodecay\"] = transport_outside_extent_nodecay\n\n        if self.mode == \"linear_decay\":\n            obj_decay = eq.Transport(self.pars, dx = self.dx, dy = self.dy, dt = self.dt, mode = \"linear_decay\")\n            cxyt_dec, x, y, t = obj_decay.domenico()\n\n            # Plume mass of linear decay model.\n            plume_mass_lindecay = np.sum(cxyt_dec[time_pos, :, 1:] * cellsize * self.pars[\"n\"])\n            self.mass_balance_dict[\"plume_mass_linear_decay\"] = plume_mass_lindecay\n\n            # Calculate transport out of model extent linear decay as fraction of transport out of model for no decay\n            # model, scaled by ratio between no decay and linear decay plume mass.\n            transport_outside_extent_lindecay = (transport_outside_extent_nodecay * plume_mass_lindecay\n                                                 / plume_mass_nodecay)\n            self.mass_balance_dict[\"transport_outside_extent_lineardecay\"] = transport_outside_extent_lindecay\n\n            # Contaminant mass degraded by linear decay is diffrence plume mass no and linear decay plus difference in\n            # mass transported outside model extent by no and linear decay.\n            degraded_mass = (plume_mass_nodecay - plume_mass_lindecay + transport_outside_extent_nodecay\n                               - transport_outside_extent_lindecay)\n            self.mass_balance_dict[\"plume_mass_degraded_linear\"] = degraded_mass\n\n        elif self.mode == \"instant_reaction\":\n            obj_inst = eq.Transport(self.pars, dx = self.dx, dy = self.dy, dt = self.dt, mode = \"instant_reaction\")\n            cxyt_inst, x, y, t = obj_inst.domenico()\n\n            # Matrix with concentration values before subtraction of biodegradation capacity\n            cxyt_noBC = obj_inst.cxyt_noBC\n\n            BC = calculate_biodegradation_capacity(self.pars)\n            ksource_inst = calculate_source_decay_instant(self.pars, BC)\n\n            # Total source mass at t=t, for the instant reaction model\n            M_source_t_inst = M_source_0 * np.exp(-ksource_inst * t[time_pos])\n            self.mass_balance_dict[\"source_mass_instant_t\"] = M_source_t_inst\n\n            # Change in source mass at t=t due to source decay by transport and by biodegradation\n            M_source_delta = M_source_0 - M_source_t_inst\n            self.mass_balance_dict[\"source_mass_instant_change\"] = M_source_delta\n\n            # Plume mass without biodegradation according to the instant degradation model\n            plume_mass_nodecay = np.sum(cxyt_noBC[time_pos, :, 1:] * cellsize * self.pars[\"n\"])\n            self.mass_balance_dict[\"plume_mass_no_decay_instant_reaction\"] = plume_mass_nodecay\n\n            # Plume mass with biodegradation according to the instant degradation model\n            plume_mass_inst = np.sum(cxyt_inst[time_pos, :, 1:] * cellsize * self.pars[\"n\"])\n            self.mass_balance_dict[\"plume_mass_instant_reaction\"] = plume_mass_inst\n\n            # Assumption: all mass difference between instant degradation model with biodegradation and\n            # instant degradation model with biodegradation is caused by degradation.\n            degraded_mass = plume_mass_nodecay - plume_mass_inst\n            self.mass_balance_dict[\"plume_mass_degraded_instant\"] = degraded_mass\n\n            # Weight fraction of electron acceptor used for degradation and degraded contaminant\n            mass_fraction_electron_acceptor = calculate_acceptor_utilization(self.pars)\n\n            # Change in total mass of each electron acceptor\n            electron_acceptor_mass_change = mass_fraction_electron_acceptor * degraded_mass\n            self.mass_balance_dict[\"electron_acceptor_mass_change\"] = electron_acceptor_mass_change\n\n        return self.mass_balance_dict\n</code></pre>"},{"location":"reference/reference/#mibitrans.analysis.mass_balance.MassBalance.__init__","title":"<code>__init__(parameters, mode='no_decay', dx=None, dy=None, dt=None)</code>","text":"<p>Initialise the class and internal variables.</p> <p>Parameters:</p> Name Type Description Default <code>parameters (dict) </code> <p>Dictionary with transport parameters.</p> required <code>mode (str) </code> <p>Type of analytical model to be used. Default is no decay model.</p> required <code>dx (float) </code> <p>Model step size in x direction. If left empty,</p> required <code>dy (float) </code> <p>Model step size in y direction. If left empty,</p> required <code>dt (float) </code> <p>Model step size for time. If left empty,</p> required Source code in <code>mibitrans/analysis/mass_balance.py</code> <pre><code>def __init__(self,\n             parameters : dict,\n             mode: str = \"no_decay\",\n             dx : float = None,\n             dy : float = None,\n             dt : float = None,\n             ) -&gt; None:\n    \"\"\"Initialise the class and internal variables.\n\n    Args:\n        parameters (dict) : Dictionary with transport parameters.\n        mode (str) : Type of analytical model to be used. Default is no decay model.\n        dx (float) : Model step size in x direction. If left empty,\n        reasonable value will be calculated based on modeled area length. Default is None.\n        dy (float) : Model step size in y direction. If left empty,\n        reasonable value will be calculated based on modeled area width. Default is None.\n        dt (float) : Model step size for time. If left empty,\n        reasonable value will be calculated based on simulation time. Default is None.\n\n    \"\"\"\n    self.pars = parameters\n    self.mode = mode\n    self.dx = dx\n    self.dy = dy\n    self.dt = dt\n    self.mass_balance_dict = {\n    }\n</code></pre>"},{"location":"reference/reference/#mibitrans.analysis.mass_balance.MassBalance.balance","title":"<code>balance(time=None)</code>","text":"<p>Calculates mass balance at a certain time point using the analytical equation for specified model type.</p> <p>Returns:</p> Type Description <code>dict</code> <p>mass_balance_dict (dict) : Dictionary containing mass for each mass balance component</p> <code>dict</code> <p>relevant to the model type.</p> Source code in <code>mibitrans/analysis/mass_balance.py</code> <pre><code>def balance(self, time = None) -&gt; dict:\n    \"\"\"Calculates mass balance at a certain time point using the analytical equation for specified model type.\n\n    Returns:\n        mass_balance_dict (dict) : Dictionary containing mass for each mass balance component\n        relevant to the model type.\n    \"\"\"\n    obj_nodecay = eq.Transport(self.pars, dx = self.dx, dy = self.dy, dt = self.dt, mode = \"no_decay\")\n    cxyt_nd, x, y, t = obj_nodecay.domenico()\n\n    # If time point is specified, closest point in time array t is taken.\n    # If not specified, defaults to last time point.\n    if time is not None:\n        time_pos = np.argmin(abs(t - time))\n        self.mass_balance_dict[\"time\"] = t[time_pos]\n    else:\n        time_pos = -1\n        self.mass_balance_dict[\"time\"] = t[time_pos]\n\n    ksource = calculate_source_decay(self.pars)\n\n    # Total source mass at t=0\n    M_source_0 = self.pars[\"m_total\"] * 1000\n    self.mass_balance_dict[\"source_mass_0\"] = M_source_0\n\n    # Total source mass at t=t, for the no decay model\n    M_source_t = M_source_0 * np.exp(-ksource * t[time_pos])\n    self.mass_balance_dict[\"source_mass_t\"] = M_source_t\n\n    # Change in source mass at t=t, due to source decay by transport\n    M_source_delta = M_source_0 - M_source_t\n    self.mass_balance_dict[\"source_mass_change\"] = M_source_delta\n\n    # Volume of single cell, as dx * dy * source thickness\n    cellsize = abs(x[1] - x[2]) * abs(y[1] - y[2]) * self.pars[\"d_source\"]\n\n    # Plume mass of no decay model; concentration is converted to mass by multiplying by cellsize and pore space.\n    plume_mass_nodecay = np.sum(cxyt_nd[time_pos, :, 1:] * cellsize * self.pars[\"n\"])\n    self.mass_balance_dict[\"plume_mass_no_decay\"] = plume_mass_nodecay\n\n    # Difference between current plume mass and change in source mass must have been transported outside of model\n    # extent for no decay scenarios; preservation of mass.\n    if M_source_delta - plume_mass_nodecay &lt; 0:\n        transport_outside_extent_nodecay = 0\n        self.mass_balance_dict[\"transport_outside_extent\"] = transport_outside_extent_nodecay\n    else:\n        transport_outside_extent_nodecay = M_source_delta - plume_mass_nodecay\n        self.mass_balance_dict[\"transport_outside_extent_nodecay\"] = transport_outside_extent_nodecay\n\n    if self.mode == \"linear_decay\":\n        obj_decay = eq.Transport(self.pars, dx = self.dx, dy = self.dy, dt = self.dt, mode = \"linear_decay\")\n        cxyt_dec, x, y, t = obj_decay.domenico()\n\n        # Plume mass of linear decay model.\n        plume_mass_lindecay = np.sum(cxyt_dec[time_pos, :, 1:] * cellsize * self.pars[\"n\"])\n        self.mass_balance_dict[\"plume_mass_linear_decay\"] = plume_mass_lindecay\n\n        # Calculate transport out of model extent linear decay as fraction of transport out of model for no decay\n        # model, scaled by ratio between no decay and linear decay plume mass.\n        transport_outside_extent_lindecay = (transport_outside_extent_nodecay * plume_mass_lindecay\n                                             / plume_mass_nodecay)\n        self.mass_balance_dict[\"transport_outside_extent_lineardecay\"] = transport_outside_extent_lindecay\n\n        # Contaminant mass degraded by linear decay is diffrence plume mass no and linear decay plus difference in\n        # mass transported outside model extent by no and linear decay.\n        degraded_mass = (plume_mass_nodecay - plume_mass_lindecay + transport_outside_extent_nodecay\n                           - transport_outside_extent_lindecay)\n        self.mass_balance_dict[\"plume_mass_degraded_linear\"] = degraded_mass\n\n    elif self.mode == \"instant_reaction\":\n        obj_inst = eq.Transport(self.pars, dx = self.dx, dy = self.dy, dt = self.dt, mode = \"instant_reaction\")\n        cxyt_inst, x, y, t = obj_inst.domenico()\n\n        # Matrix with concentration values before subtraction of biodegradation capacity\n        cxyt_noBC = obj_inst.cxyt_noBC\n\n        BC = calculate_biodegradation_capacity(self.pars)\n        ksource_inst = calculate_source_decay_instant(self.pars, BC)\n\n        # Total source mass at t=t, for the instant reaction model\n        M_source_t_inst = M_source_0 * np.exp(-ksource_inst * t[time_pos])\n        self.mass_balance_dict[\"source_mass_instant_t\"] = M_source_t_inst\n\n        # Change in source mass at t=t due to source decay by transport and by biodegradation\n        M_source_delta = M_source_0 - M_source_t_inst\n        self.mass_balance_dict[\"source_mass_instant_change\"] = M_source_delta\n\n        # Plume mass without biodegradation according to the instant degradation model\n        plume_mass_nodecay = np.sum(cxyt_noBC[time_pos, :, 1:] * cellsize * self.pars[\"n\"])\n        self.mass_balance_dict[\"plume_mass_no_decay_instant_reaction\"] = plume_mass_nodecay\n\n        # Plume mass with biodegradation according to the instant degradation model\n        plume_mass_inst = np.sum(cxyt_inst[time_pos, :, 1:] * cellsize * self.pars[\"n\"])\n        self.mass_balance_dict[\"plume_mass_instant_reaction\"] = plume_mass_inst\n\n        # Assumption: all mass difference between instant degradation model with biodegradation and\n        # instant degradation model with biodegradation is caused by degradation.\n        degraded_mass = plume_mass_nodecay - plume_mass_inst\n        self.mass_balance_dict[\"plume_mass_degraded_instant\"] = degraded_mass\n\n        # Weight fraction of electron acceptor used for degradation and degraded contaminant\n        mass_fraction_electron_acceptor = calculate_acceptor_utilization(self.pars)\n\n        # Change in total mass of each electron acceptor\n        electron_acceptor_mass_change = mass_fraction_electron_acceptor * degraded_mass\n        self.mass_balance_dict[\"electron_acceptor_mass_change\"] = electron_acceptor_mass_change\n\n    return self.mass_balance_dict\n</code></pre>"},{"location":"reference/reference/#mibitrans.analysis.parameter_calculations","title":"<code>parameter_calculations</code>","text":"<p>Author: Jorrit Bakker.</p> <p>Module containing various methods that takes a dictionary of parameters as input and calculates the proper values that can be used in transport equations.</p>"},{"location":"reference/reference/#mibitrans.analysis.parameter_calculations.calculate_acceptor_utilization","title":"<code>calculate_acceptor_utilization(pars)</code>","text":"<p>Function that calculates relative use of electron acceptors in biodegradation of BTEX.</p> Source code in <code>mibitrans/analysis/parameter_calculations.py</code> <pre><code>def calculate_acceptor_utilization(pars):\n    \"\"\"Function that calculates relative use of electron acceptors in biodegradation of BTEX.\"\"\"\n    biodeg_array = np.zeros(len(list(acceptor_utilization_dictionary.keys())))\n    util_array = np.zeros(len(biodeg_array))\n\n    for i, (key, item) in enumerate(acceptor_utilization_dictionary.items()):\n        biodeg_array[i] = pars[key] / item\n        util_array[i] = item\n\n    biodegradation_capacity = np.sum(biodeg_array)\n    fraction_total = biodeg_array / biodegradation_capacity\n    mass_fraction = fraction_total * util_array\n\n    return(mass_fraction)\n</code></pre>"},{"location":"reference/reference/#mibitrans.analysis.parameter_calculations.calculate_biodegradation_capacity","title":"<code>calculate_biodegradation_capacity(pars)</code>","text":"<p>Function that calculates biodegradation capacity based on utilization factors for BTEX.</p> Source code in <code>mibitrans/analysis/parameter_calculations.py</code> <pre><code>def calculate_biodegradation_capacity(pars):\n    \"\"\"Function that calculates biodegradation capacity based on utilization factors for BTEX.\"\"\"\n    biodeg_cap = 0\n\n    for key, item in acceptor_utilization_dictionary.items():\n        biodeg_cap += pars[key] / item\n\n    return(biodeg_cap)\n</code></pre>"},{"location":"reference/reference/#mibitrans.analysis.parameter_calculations.calculate_dispersivity","title":"<code>calculate_dispersivity(pars)</code>","text":"<p>Give dispersivity in each direction depending on input parameters.</p> Source code in <code>mibitrans/analysis/parameter_calculations.py</code> <pre><code>def calculate_dispersivity(pars):\n    \"\"\"Give dispersivity in each direction depending on input parameters.\"\"\"\n    if \"alpha_x\" in pars.keys():\n        ax = pars[\"alpha_x\"]\n        ay = pars[\"alpha_y\"]\n        az = pars[\"alpha_z\"]\n    else:\n        # Conversion from plume length to alpha x, y and z\n        ax = 0.83 * np.log10(pars[\"lp\"])**2.414\n        ay = ax / 10\n        az = ax / 100\n\n    # Dispersivity values of 0 may give issues in analytical equation, therefore are set to small non-zero value\n    if ax &lt; 1e-10:\n        ax = 1e-10\n    if ay &lt; 1e-10:\n        ay = 1e-10\n    if az &lt; 1e-10:\n        az = 1e-10\n\n    return (ax, ay, az)\n</code></pre>"},{"location":"reference/reference/#mibitrans.analysis.parameter_calculations.calculate_flow_velocity","title":"<code>calculate_flow_velocity(pars)</code>","text":"<p>Give flow velocity depending on input parameters.</p> Source code in <code>mibitrans/analysis/parameter_calculations.py</code> <pre><code>def calculate_flow_velocity(pars):\n    \"\"\"Give flow velocity depending on input parameters.\"\"\"\n    if \"v\" in pars.keys():\n        v = pars[\"v\"]\n    else:\n        v = (pars[\"k\"] * pars[\"i\"]) / (pars[\"n\"])\n    return v\n</code></pre>"},{"location":"reference/reference/#mibitrans.analysis.parameter_calculations.calculate_linear_decay","title":"<code>calculate_linear_decay(pars)</code>","text":"<p>Give 1st order decay coefficient depending on input parameters.</p> Source code in <code>mibitrans/analysis/parameter_calculations.py</code> <pre><code>def calculate_linear_decay(pars):\n    \"\"\"Give 1st order decay coefficient depending on input parameters.\"\"\"\n    if \"mu\" in pars.keys():\n        mu = pars[\"mu\"]\n    else:\n        mu = np.log(2) / pars[\"t_half\"]\n    return mu\n</code></pre>"},{"location":"reference/reference/#mibitrans.analysis.parameter_calculations.calculate_retardation","title":"<code>calculate_retardation(pars)</code>","text":"<p>Give retardation factor depending on input parameters.</p> Source code in <code>mibitrans/analysis/parameter_calculations.py</code> <pre><code>def calculate_retardation(pars):\n    \"\"\"Give retardation factor depending on input parameters.\"\"\"\n    if \"R\" in pars.keys():\n        r = pars[\"R\"]\n    else:\n        r = 1 + (pars[\"rho\"] / pars[\"n\"]) * pars[\"Koc\"] * pars[\"foc\"]\n    return r\n</code></pre>"},{"location":"reference/reference/#mibitrans.analysis.parameter_calculations.calculate_source_decay","title":"<code>calculate_source_decay(pars)</code>","text":"<p>Function that calculates the source zone decay constant.</p> Source code in <code>mibitrans/analysis/parameter_calculations.py</code> <pre><code>def calculate_source_decay(pars):\n    \"\"\"Function that calculates the source zone decay constant.\"\"\"\n    source_y = pars[\"c_source\"][:, 0]\n    source_c = pars[\"c_source\"][:, 1]\n    Q = pars[\"v\"] * pars[\"n\"] * pars[\"d_source\"] * np.max(source_y) * 2\n\n    # Calculate weighted average concentration of source zone plume\n    C0_avg = 0\n    for i in range(len(source_y) - 1):\n        if i == 0:\n            yc = source_y[i + 1] * source_c[i] * 2\n        else:\n            yc = (source_y[i+1] - source_y[i]) * source_c[i] * 2\n        C0_avg += yc\n    C0_avg = C0_avg / (np.max(source_y) * 2)\n\n    # Multiply by 1e3 to convert soluble mass to kg\n    k_source = Q * C0_avg / (pars[\"m_total\"] * 1e3)\n\n    return(k_source)\n</code></pre>"},{"location":"reference/reference/#mibitrans.analysis.parameter_calculations.calculate_source_decay_instant","title":"<code>calculate_source_decay_instant(pars, biodeg_cap)</code>","text":"<p>Function that calculates the source zone decay constant.</p> Source code in <code>mibitrans/analysis/parameter_calculations.py</code> <pre><code>def calculate_source_decay_instant(pars, biodeg_cap):\n    \"\"\"Function that calculates the source zone decay constant.\"\"\"\n    source_y = pars[\"c_source\"][:, 0]\n    source_c = pars[\"c_source\"][:, 1]\n    Q = pars[\"v\"] * pars[\"n\"] * pars[\"d_source\"] * np.max(source_y) * 2\n\n    # Calculate weighted average concentration of source zone plume\n    C0_avg = 0\n    for i in range(len(source_y) - 1):\n        if i == 0:\n            yc = source_y[i + 1] * source_c[i] * 2\n        else:\n            yc = (source_y[i+1] - source_y[i]) * source_c[i] * 2\n        C0_avg += yc\n    C0_avg = (C0_avg / (np.max(source_y) * 2)) + biodeg_cap\n\n    # Multiply by 1e3 to convert soluble mass to g\n    k_source = Q * C0_avg / (pars[\"m_total\"] * 1e3)\n\n    return(k_source)\n</code></pre>"},{"location":"reference/reference/#mibitrans.bioscreen","title":"<code>bioscreen</code>","text":"<p>Documentation about bioscreen submodule in mibitrans.</p>"},{"location":"reference/reference/#mibitrans.bioscreen.analysis","title":"<code>analysis</code>","text":"<p>mibitrans module for data analysis.</p>"},{"location":"reference/reference/#mibitrans.bioscreen.data","title":"<code>data</code>","text":"<p>mibitrans module for data handling.</p>"},{"location":"reference/reference/#mibitrans.bioscreen.transport","title":"<code>transport</code>","text":"<p>mibitrans module for transport calculations.</p>"},{"location":"reference/reference/#mibitrans.bioscreen.vizualize","title":"<code>vizualize</code>","text":"<p>mibitrans module for data visualization.</p>"},{"location":"reference/reference/#mibitrans.data","title":"<code>data</code>","text":""},{"location":"reference/reference/#mibitrans.data.check_input","title":"<code>check_input</code>","text":"<p>Author: Jorrit Bakker.</p> <p>Module evaluating if a dictionary contains all required (correct) parameters for analysis</p>"},{"location":"reference/reference/#mibitrans.data.check_input.CheckInput","title":"<code>CheckInput</code>","text":"<p>Evaluates if input dictionary contains all required parameters and if they have the correct data type.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>class CheckInput:\n    \"\"\"Evaluates if input dictionary contains all required parameters and if they have the correct data type.\"\"\"\n    def __init__(self, dictionary, mode = None, verbose = True) -&gt; None:\n        \"\"\"Initialize parameters.\n\n        Args:\n            dictionary (dict): Input dictionary\n            mode (str, optional): Method of analysis that will be performed on dictionary. Defaults to None.\n            verbose (bool, optional): Verbose mode. Defaults to True.\n        \"\"\"\n        self.dict = dictionary\n        self.keys = self.dict.keys()\n        self.mode = mode\n        self.verbose = verbose\n        self.wrong_type = []\n        self.wrong_value = []\n        self.missing_params = []\n\n    def check_parameter(self) -&gt; bool:\n        \"\"\"Check if all required parameters are present for a specific mode.\"\"\"\n        # Either the flow velocity or hydraulic conductivity, hydraulic gradient and porosity are required by the model.\n        if not(\"v\" in self.keys or {\"k\", \"i\"}.issubset(self.keys)):\n            self.missing_params.append(\"v or (k and i)\")\n\n        # Either plume length or dispersivity in all directions are required by the model.\n        if not(\"lp\" in self.keys or {\"alpha_x\", \"alpha_y\", \"alpha_z\"}.issubset(self.keys)):\n            self.missing_params.append(\"lp or (alpha_x and alpha_y and alpha_z)\")\n\n        # Either retardation factor or bulk density, partition coefficient and fraction organic carbon\n        # are required by the model.\n        if not(\"R\" in self.keys or {\"rho\", \"Koc\", \"foc\"}.issubset(self.keys)):\n            self.missing_params.append(\"R or (rho, Koc and foc)\")\n\n        # Porosity is required by the model.\n        if \"n\" not in self.keys:\n            self.missing_params.append(\"n\")\n\n        # Source thickness is required by the model.\n        if \"d_source\" not in self.keys:\n            self.missing_params.append(\"d_source\")\n\n        # Initial concentration is required by the model.\n        if \"c_source\" not in self.keys:\n            self.missing_params.append(\"c_source\")\n\n        # Total soluble mass is required by the model.\n        if \"m_total\" not in self.keys:\n            self.missing_params.append(\"m_total\")\n\n        # Either decay coefficient or solute half-life is required for the linear decay model.\n        if self.mode == \"linear_decay\":\n            if not(\"mu\" in self.keys or \"t_half\" in self.keys):\n                self.missing_params.append(\"mu or t_half\")\n\n        # Electron acceptor and donor concentrations are required for the instant reaction model.\n        elif self.mode == \"instant_reaction\":\n            if not({\"dO\", \"dNO3\", \"Fe2\", \"dSO4\", \"CH4\"}.issubset(self.keys)):\n                self.missing_params.append(\"dO, dNO3, Fe2, dSO4, CH4\")\n\n        elif self.mode and self.mode != \"no_decay\":\n            if self.verbose:\n                print(\"Mode is not recognized. Only checking for standard requirements.\")\n\n        if self.missing_params:\n            success_flag = False\n            if self.verbose:\n                print(\"The following parameters are missing:\", self.missing_params)\n        else:\n            success_flag = True\n            if self.verbose:\n                print(\"All required parameters are present.\")\n\n        return success_flag\n\n    def check_values(self):\n        \"\"\"Check if value and value types are as expected.\"\"\"\n        from mibitrans.data.parameter_information import datatype_dictionary\n\n        # To prevent incorrect datatypes, input data types are compared to allowed data types for each parameter.\n        for key, value in self.dict.items():\n            if key in datatype_dictionary[\"int_float\"]:\n                if not isinstance(value, int) and not isinstance(value, float):\n                    # Allow total source mass to be set to infinite\n                    if key != \"m_total\" or (value not in [\"inf\", \"infinite\"]):\n                        self.wrong_type.append(key)\n                # Parameters designated as float or int can not have negative values\n                elif key == \"n\" and (value &lt;= 0 or value &gt; 1):\n                    self.wrong_value.append(key)\n                    if self.verbose:\n                        print(\"Porosity should have a value between 0 and 1\")\n                elif key == \"R\" and (value &lt; 1):\n                    self.wrong_value.append(key)\n                    if self.verbose:\n                        print(\"Retardation factor should be a value equal or larger than 1.\")\n                elif value &lt; 0:\n                    self.wrong_value.append(key)\n\n            elif key in datatype_dictionary[\"float_array\"]:\n                if not isinstance(value, np.ndarray) and not isinstance(value, float) and not isinstance(value, int):\n                    self.wrong_type.append(key)\n\n                elif isinstance(value, int) or isinstance(value, float):\n                    if value &lt; 0:\n                        self.wrong_value.append(key)\n\n                # If input is an array, it needs to be 2d and have 2 columns.\n                elif isinstance(value, np.ndarray):\n                    if np.min(value) &lt; 0:\n                        self.wrong_value.append(key)\n                    elif len(value.shape) != 2:\n                        self.wrong_value.append(key)\n                    elif value.shape[1] != 2:\n                        self.wrong_value.append(key)\n\n        if self.wrong_type or self.wrong_value:\n            success_flag = False\n            if self.verbose:\n                print(\"The following parameters are of the wrong type:\", self.wrong_type)\n                print(\"The following parameters have an invalid value:\", self.wrong_value)\n\n        else:\n            success_flag = True\n            if self.verbose:\n                print(\"All parameters are of the correct type and value.\")\n        return success_flag\n\n    def check_units(self):\n        \"\"\"Placeholder function that will check units for input parameters.\"\"\"\n        print(\"c\")\n</code></pre>"},{"location":"reference/reference/#mibitrans.data.check_input.CheckInput.__init__","title":"<code>__init__(dictionary, mode=None, verbose=True)</code>","text":"<p>Initialize parameters.</p> <p>Parameters:</p> Name Type Description Default <code>dictionary</code> <code>dict</code> <p>Input dictionary</p> required <code>mode</code> <code>str</code> <p>Method of analysis that will be performed on dictionary. Defaults to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to True.</p> <code>True</code> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>def __init__(self, dictionary, mode = None, verbose = True) -&gt; None:\n    \"\"\"Initialize parameters.\n\n    Args:\n        dictionary (dict): Input dictionary\n        mode (str, optional): Method of analysis that will be performed on dictionary. Defaults to None.\n        verbose (bool, optional): Verbose mode. Defaults to True.\n    \"\"\"\n    self.dict = dictionary\n    self.keys = self.dict.keys()\n    self.mode = mode\n    self.verbose = verbose\n    self.wrong_type = []\n    self.wrong_value = []\n    self.missing_params = []\n</code></pre>"},{"location":"reference/reference/#mibitrans.data.check_input.CheckInput.check_parameter","title":"<code>check_parameter()</code>","text":"<p>Check if all required parameters are present for a specific mode.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>def check_parameter(self) -&gt; bool:\n    \"\"\"Check if all required parameters are present for a specific mode.\"\"\"\n    # Either the flow velocity or hydraulic conductivity, hydraulic gradient and porosity are required by the model.\n    if not(\"v\" in self.keys or {\"k\", \"i\"}.issubset(self.keys)):\n        self.missing_params.append(\"v or (k and i)\")\n\n    # Either plume length or dispersivity in all directions are required by the model.\n    if not(\"lp\" in self.keys or {\"alpha_x\", \"alpha_y\", \"alpha_z\"}.issubset(self.keys)):\n        self.missing_params.append(\"lp or (alpha_x and alpha_y and alpha_z)\")\n\n    # Either retardation factor or bulk density, partition coefficient and fraction organic carbon\n    # are required by the model.\n    if not(\"R\" in self.keys or {\"rho\", \"Koc\", \"foc\"}.issubset(self.keys)):\n        self.missing_params.append(\"R or (rho, Koc and foc)\")\n\n    # Porosity is required by the model.\n    if \"n\" not in self.keys:\n        self.missing_params.append(\"n\")\n\n    # Source thickness is required by the model.\n    if \"d_source\" not in self.keys:\n        self.missing_params.append(\"d_source\")\n\n    # Initial concentration is required by the model.\n    if \"c_source\" not in self.keys:\n        self.missing_params.append(\"c_source\")\n\n    # Total soluble mass is required by the model.\n    if \"m_total\" not in self.keys:\n        self.missing_params.append(\"m_total\")\n\n    # Either decay coefficient or solute half-life is required for the linear decay model.\n    if self.mode == \"linear_decay\":\n        if not(\"mu\" in self.keys or \"t_half\" in self.keys):\n            self.missing_params.append(\"mu or t_half\")\n\n    # Electron acceptor and donor concentrations are required for the instant reaction model.\n    elif self.mode == \"instant_reaction\":\n        if not({\"dO\", \"dNO3\", \"Fe2\", \"dSO4\", \"CH4\"}.issubset(self.keys)):\n            self.missing_params.append(\"dO, dNO3, Fe2, dSO4, CH4\")\n\n    elif self.mode and self.mode != \"no_decay\":\n        if self.verbose:\n            print(\"Mode is not recognized. Only checking for standard requirements.\")\n\n    if self.missing_params:\n        success_flag = False\n        if self.verbose:\n            print(\"The following parameters are missing:\", self.missing_params)\n    else:\n        success_flag = True\n        if self.verbose:\n            print(\"All required parameters are present.\")\n\n    return success_flag\n</code></pre>"},{"location":"reference/reference/#mibitrans.data.check_input.CheckInput.check_units","title":"<code>check_units()</code>","text":"<p>Placeholder function that will check units for input parameters.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>def check_units(self):\n    \"\"\"Placeholder function that will check units for input parameters.\"\"\"\n    print(\"c\")\n</code></pre>"},{"location":"reference/reference/#mibitrans.data.check_input.CheckInput.check_values","title":"<code>check_values()</code>","text":"<p>Check if value and value types are as expected.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>def check_values(self):\n    \"\"\"Check if value and value types are as expected.\"\"\"\n    from mibitrans.data.parameter_information import datatype_dictionary\n\n    # To prevent incorrect datatypes, input data types are compared to allowed data types for each parameter.\n    for key, value in self.dict.items():\n        if key in datatype_dictionary[\"int_float\"]:\n            if not isinstance(value, int) and not isinstance(value, float):\n                # Allow total source mass to be set to infinite\n                if key != \"m_total\" or (value not in [\"inf\", \"infinite\"]):\n                    self.wrong_type.append(key)\n            # Parameters designated as float or int can not have negative values\n            elif key == \"n\" and (value &lt;= 0 or value &gt; 1):\n                self.wrong_value.append(key)\n                if self.verbose:\n                    print(\"Porosity should have a value between 0 and 1\")\n            elif key == \"R\" and (value &lt; 1):\n                self.wrong_value.append(key)\n                if self.verbose:\n                    print(\"Retardation factor should be a value equal or larger than 1.\")\n            elif value &lt; 0:\n                self.wrong_value.append(key)\n\n        elif key in datatype_dictionary[\"float_array\"]:\n            if not isinstance(value, np.ndarray) and not isinstance(value, float) and not isinstance(value, int):\n                self.wrong_type.append(key)\n\n            elif isinstance(value, int) or isinstance(value, float):\n                if value &lt; 0:\n                    self.wrong_value.append(key)\n\n            # If input is an array, it needs to be 2d and have 2 columns.\n            elif isinstance(value, np.ndarray):\n                if np.min(value) &lt; 0:\n                    self.wrong_value.append(key)\n                elif len(value.shape) != 2:\n                    self.wrong_value.append(key)\n                elif value.shape[1] != 2:\n                    self.wrong_value.append(key)\n\n    if self.wrong_type or self.wrong_value:\n        success_flag = False\n        if self.verbose:\n            print(\"The following parameters are of the wrong type:\", self.wrong_type)\n            print(\"The following parameters have an invalid value:\", self.wrong_value)\n\n    else:\n        success_flag = True\n        if self.verbose:\n            print(\"All parameters are of the correct type and value.\")\n    return success_flag\n</code></pre>"},{"location":"reference/reference/#mibitrans.data.parameter_information","title":"<code>parameter_information</code>","text":"<p>Author: Jorrit Bakker.</p> <p>File containing various dictionaries used for evaluation of names, value types and units of input data.</p>"},{"location":"reference/reference/#mibitrans.data.read","title":"<code>read</code>","text":"<p>Author: Jorrit Bakker.</p> <p>Module handling data input in the form of a dictionary.</p>"},{"location":"reference/reference/#mibitrans.data.read.from_dict","title":"<code>from_dict(dictionary, verbose=True)</code>","text":"<p>Format and structure input dictionary into a standardized dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>dictionary</code> <code>dict</code> <p>Input dictionary.</p> required <code>verbose</code> <code>bool</code> <p>Print verbose output. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary following standardized format.</p> Source code in <code>mibitrans/data/read.py</code> <pre><code>def from_dict(dictionary: dict,\n              verbose: bool = True\n              ) -&gt; dict:\n    \"\"\"Format and structure input dictionary into a standardized dictionary.\n\n    Args:\n        dictionary (dict): Input dictionary.\n        verbose (bool, optional): Print verbose output. Defaults to True.\n\n    Returns:\n        dict: Dictionary following standardized format.\n    \"\"\"\n    params = {}\n    unknown_keys = []\n\n    # Convert every input dictionary key by looping over all keys\n    for key_input, value_input in dictionary.items():\n        key_in_known_keys = False\n        for key_params, key_known in key_dictionary.items():\n            # Look if input key is listed as a possible name for a parameter\n            if key_input in key_known:\n                params[key_params] = value_input\n                key_in_known_keys = True\n                # If input key is recognized, no need to continue this loop and go to next input key.\n                break\n        if not key_in_known_keys:\n            unknown_keys.append(key_input)\n\n    if verbose and len(unknown_keys) &gt; 0:\n        print(\"The following keys were not recognized and not included in output dictionary:\", unknown_keys)\n    elif verbose:\n        print(\"All keys were recognized\")\n\n    return params\n</code></pre>"},{"location":"reference/reference/#mibitrans.transport","title":"<code>transport</code>","text":""},{"location":"reference/reference/#mibitrans.transport.analytical_equation","title":"<code>analytical_equation</code>","text":"<p>Author: Jorrit Bakker.</p> <p>Module calculating the solution to the Domenico (1987) analytical model for different scenarios.</p>"},{"location":"reference/reference/#mibitrans.transport.analytical_equation.Transport","title":"<code>Transport</code>","text":"<p>Calculate analytical solution from variations of the Domenico analytical model.</p> Source code in <code>mibitrans/transport/analytical_equation.py</code> <pre><code>class Transport:\n    \"\"\"Calculate analytical solution from variations of the Domenico analytical model.\"\"\"\n    def __init__(self,\n                 parameters : dict,\n                 mode : str = \"no_decay\",\n                 dx : float = 0,\n                 dy : float = 0,\n                 dt : float = 0,\n                 verbose : bool = False\n                 ) -&gt; None:\n        \"\"\"Initialise the class, set up dimensions and output array.\n\n        Args:\n            parameters (dict) : Dictionary with transport parameters.\n            mode (str) : Type of analytical model to be used. Default is no decay model.\n            dx (float) : Model step size in x direction. If left empty,\n            reasonable value will be calculated based on modeled area length. Default is None.\n            dy (float) : Model step size in y direction. If left empty,\n            reasonable value will be calculated based on modeled area width. Default is None.\n            dt (float) : Model step size for time. If left empty,\n            reasonable value will be calculated based on simulation time. Default is None.\n            verbose (bool, optional): Verbose mode. Defaults to False.\n\n        Raises:\n            ValueError : If input parameters are incomplete or of incorrect datatype/value.\n\n        \"\"\"\n        self.pars = parameters\n        self.mode = mode\n        self.verbose = verbose\n\n        if verbose:\n            if self.mode == \"no_decay\":\n                print(\"Initializing parameters for the no decay model.\")\n            elif self.mode == \"linear_decay\":\n                print(\"Initializing parameters for the linear decay model.\")\n            elif self.mode == \"instant_reaction\":\n                print(\"Initializing parameters for the instantaneous reaction model.\")\n            else:\n                print(\"Mode name is not recognized, initializing decay model as default. Valid model names are:\",\n                      \" 'no_decay', 'linear_decay', 'instant_reaction'.\")\n\n        if verbose:\n            print(\"Checking input parameters...\")\n\n        # Ensure that every parameter required for calculations is present in pars\n        self.ck = CheckInput(self.pars, self.mode, verbose = self.verbose)\n        par_success = self.ck.check_parameter()\n        if not par_success:\n            raise ValueError(\"Not all required input parameters are given.\")\n\n        # Ensure that every parameter required for calculations is of the correct value or data type.\n        val_success = self.ck.check_values()\n        if not val_success:\n            raise ValueError(\"Not all required input values are of the expected value or data type.\")\n\n        if verbose:\n            print(\"Calculating transport parameters...\")\n\n        self.R = calculate_retardation(self.pars)\n        v = calculate_flow_velocity(self.pars)\n        self.pars[\"v\"] = v\n\n        # No source decay occurs when source mass is infinite\n        if self.pars[\"m_total\"] in [\"inf\", \"infinite\"]:\n            self.k_source = 0\n        else:\n            self.k_source = calculate_source_decay(self.pars)\n        self.ax, self.ay, self.az = calculate_dispersivity(self.pars)\n\n        if mode == \"linear_decay\":\n            self.mu = calculate_linear_decay(self.pars)\n        else:\n            self.mu = 0\n\n        # For the rest of the calculation, retarded flow velocity is used.\n        self.v = v / self.R\n\n        self.dx = dx\n        self.dy = dy\n        self.dt = dt\n\n        # If dx, dy or dt are not given, determine a proper value based on modeled area dimensions.\n        if not isinstance(dx, (float, int)) or (dx &lt;= 0.0):\n            self.dx = self.pars[\"l_model\"] / 100\n            if verbose:\n                print(\"dx was not given or of wrong type/value, taken as fraction of model length instead.\")\n        if not isinstance(dy, (float, int)) or (dy &lt;= 0.0):\n            self.dy = self.pars[\"w_model\"] / 50\n            if verbose:\n                print(\"dy was not given or of wrong type/value, taken as fraction of model width instead.\")\n        if not isinstance(dt, (float, int)) or (dt &lt;= 0.0):\n            self.dt = self.pars[\"t_model\"] / 10\n            if verbose:\n                print(\"dt was not given or of wrong type/value, taken as fraction of model time instead.\")\n\n        self.source_y = self.pars[\"c_source\"][:,0]\n        self.source_c = self.pars[\"c_source\"][:,1]\n\n        # Source zone concentration for superposition algorithm\n        self.c0 = self.source_c[:-1] - self.source_c[1:]\n\n        # Calculate and add biodegradation capacity to the outer plume\n        if mode == \"instant_reaction\":\n            self.biodeg_cap = calculate_biodegradation_capacity(self.pars)\n            self.c0[-1] += self.biodeg_cap\n\n            # No source decay occurs when source mass is infinite\n            if self.pars[\"m_total\"] in [\"inf\", \"infinite\"]:\n                self.k_source_instant = 0\n            else:\n                self.k_source_instant = calculate_source_decay_instant(self.pars, self.biodeg_cap)\n\n        else:\n            self.biodeg_cap = 0\n\n        if verbose:\n            print(\"Setting up dimensional grids...\")\n\n        # Initialize space and time arrays\n        self.x = np.arange(0, parameters[\"l_model\"] + self.dx, self.dx)\n\n        if parameters[\"w_model\"] &gt; 2 * self.source_y[-1]:\n            self.y = np.arange(-parameters[\"w_model\"] / 2, parameters[\"w_model\"] / 2, self.dy)\n        else:\n            self.y = np.arange(-self.source_y[-1], self.source_y[-1] + self.dy, self.dy)\n\n        self.t = np.arange(self.dt, parameters[\"t_model\"] + self.dt, self.dt)\n\n        # To allow array calculations, set space and time as a 3-dimensional array.\n        self.xxx = np.tile(self.x, (len(self.t), len(self.y), 1))\n        self.yyy = np.tile(self.y[:, None], (len(self.t), 1, len(self.x)))\n        self.ttt = np.tile(self.t[:, None, None], (1, len(self.y), len(self.x)))\n        self.cxyt = np.zeros(self.xxx.shape)\n\n        self.cxyt_noBC = 0\n\n        if verbose:\n            print(\"Done with initializing!\")\n\n    def domenico(self):\n        \"\"\"Calculate the Domenico analytical model.\n\n        Returns:\n            cxyt (np.ndarray) : 3-dimensional array with values representing contaminant concentrations. Outer dimension\n            represents time, middle dimension represents y-direction and inner dimension represents x-direction.\n            x (np.ndarray) : Array with values representing positions along the x-direction.\n            y (np.ndarray) : Array with values representing positions along the y-direction.\n            t (np.ndarray) : Array with values representing points in time.\n        \"\"\"\n        # Ignore divide by zero warnings; they are a result of working with x and y positions of 0.\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            # terms for linear decay are calculated, terms are 1 for no decay and instant_reaction modes, as mu = 0.\n            decay_sqrt = np.sqrt(1 + 4 * self.mu * self.ax / self.v)\n            decay_term = np.exp(self.xxx * (1 - decay_sqrt) / (self.ax * 2))\n\n            # Advection and dispersion term in the x direction\n            x_term = erfc((self.xxx - self.v * self.ttt * decay_sqrt) / (2 * np.sqrt(self.ax * self.v * self.ttt)))\n\n            # Additional advection and dispersion term in x direction for small times, when there is no linear decay\n            if self.mode != \"linear_decay\":\n                additional_x = (np.exp(self.xxx * self.v / (self.ax * self.v))\n                                * erfc(self.xxx + self.v * self.ttt / (2 * np.sqrt(self.ax * self.v * self.ttt))))\n                x_term += additional_x\n\n            # Dispersion term in the z direction\n            z_term = (erf(self.pars[\"d_source\"] / (2 * np.sqrt(self.az * self.xxx)))\n                     - erf(-self.pars[\"d_source\"] / (2 * np.sqrt(self.az * self.xxx))))\n\n            if self.mode == \"instant_reaction\":\n                sourcedecay_term = np.exp(-self.k_source_instant * (self.ttt - self.xxx / self.v))\n            else:\n                # Source decay term\n                sourcedecay_term = np.exp(-self.k_source * (self.ttt - self.xxx / self.v))\n            # Term can be max 1; can not have 'generation' of solute ahead of advection\n            sourcedecay_term = np.where(sourcedecay_term &gt; 1, 1, sourcedecay_term)\n\n            # Superposition algorithm; calculate plume for each source zone separately, then add together.\n            ccc0_source_list = [0] * len(self.c0)\n            for i in range(len(self.c0)):\n                # Dispersion term in the y direction\n                y_term = (erf((self.yyy + self.source_y[i+1]) / (2 * np.sqrt(self.ay * self.xxx)))\n                         - erf((self.yyy - self.source_y[i+1]) / (2 * np.sqrt(self.ay * self.xxx))))\n\n                y_term[np.isnan(y_term)] = 0\n\n                # Correct source zone concentrations for source decay\n                ccc0_source_list[i] = self.c0[i] * sourcedecay_term\n\n                cxyt = 1 / 8 * ccc0_source_list[i] * decay_term * x_term * y_term * z_term\n\n                self.cxyt += cxyt\n\n        # Substract biodegradation capacity, this can cause low concentration areas to become &lt; 0. Therefore, set\n        # negative values to 0.\n        self.cxyt_noBC = self.cxyt.copy()\n        self.cxyt -= self.biodeg_cap\n        self.cxyt = np.where(self.cxyt &lt; 0, 0, self.cxyt)\n\n        return self.cxyt, self.x, self.y, self.t\n</code></pre>"},{"location":"reference/reference/#mibitrans.transport.analytical_equation.Transport.__init__","title":"<code>__init__(parameters, mode='no_decay', dx=0, dy=0, dt=0, verbose=False)</code>","text":"<p>Initialise the class, set up dimensions and output array.</p> <p>Parameters:</p> Name Type Description Default <code>parameters (dict) </code> <p>Dictionary with transport parameters.</p> required <code>mode (str) </code> <p>Type of analytical model to be used. Default is no decay model.</p> required <code>dx (float) </code> <p>Model step size in x direction. If left empty,</p> required <code>dy (float) </code> <p>Model step size in y direction. If left empty,</p> required <code>dt (float) </code> <p>Model step size for time. If left empty,</p> required <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input parameters are incomplete or of incorrect datatype/value.</p> Source code in <code>mibitrans/transport/analytical_equation.py</code> <pre><code>def __init__(self,\n             parameters : dict,\n             mode : str = \"no_decay\",\n             dx : float = 0,\n             dy : float = 0,\n             dt : float = 0,\n             verbose : bool = False\n             ) -&gt; None:\n    \"\"\"Initialise the class, set up dimensions and output array.\n\n    Args:\n        parameters (dict) : Dictionary with transport parameters.\n        mode (str) : Type of analytical model to be used. Default is no decay model.\n        dx (float) : Model step size in x direction. If left empty,\n        reasonable value will be calculated based on modeled area length. Default is None.\n        dy (float) : Model step size in y direction. If left empty,\n        reasonable value will be calculated based on modeled area width. Default is None.\n        dt (float) : Model step size for time. If left empty,\n        reasonable value will be calculated based on simulation time. Default is None.\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Raises:\n        ValueError : If input parameters are incomplete or of incorrect datatype/value.\n\n    \"\"\"\n    self.pars = parameters\n    self.mode = mode\n    self.verbose = verbose\n\n    if verbose:\n        if self.mode == \"no_decay\":\n            print(\"Initializing parameters for the no decay model.\")\n        elif self.mode == \"linear_decay\":\n            print(\"Initializing parameters for the linear decay model.\")\n        elif self.mode == \"instant_reaction\":\n            print(\"Initializing parameters for the instantaneous reaction model.\")\n        else:\n            print(\"Mode name is not recognized, initializing decay model as default. Valid model names are:\",\n                  \" 'no_decay', 'linear_decay', 'instant_reaction'.\")\n\n    if verbose:\n        print(\"Checking input parameters...\")\n\n    # Ensure that every parameter required for calculations is present in pars\n    self.ck = CheckInput(self.pars, self.mode, verbose = self.verbose)\n    par_success = self.ck.check_parameter()\n    if not par_success:\n        raise ValueError(\"Not all required input parameters are given.\")\n\n    # Ensure that every parameter required for calculations is of the correct value or data type.\n    val_success = self.ck.check_values()\n    if not val_success:\n        raise ValueError(\"Not all required input values are of the expected value or data type.\")\n\n    if verbose:\n        print(\"Calculating transport parameters...\")\n\n    self.R = calculate_retardation(self.pars)\n    v = calculate_flow_velocity(self.pars)\n    self.pars[\"v\"] = v\n\n    # No source decay occurs when source mass is infinite\n    if self.pars[\"m_total\"] in [\"inf\", \"infinite\"]:\n        self.k_source = 0\n    else:\n        self.k_source = calculate_source_decay(self.pars)\n    self.ax, self.ay, self.az = calculate_dispersivity(self.pars)\n\n    if mode == \"linear_decay\":\n        self.mu = calculate_linear_decay(self.pars)\n    else:\n        self.mu = 0\n\n    # For the rest of the calculation, retarded flow velocity is used.\n    self.v = v / self.R\n\n    self.dx = dx\n    self.dy = dy\n    self.dt = dt\n\n    # If dx, dy or dt are not given, determine a proper value based on modeled area dimensions.\n    if not isinstance(dx, (float, int)) or (dx &lt;= 0.0):\n        self.dx = self.pars[\"l_model\"] / 100\n        if verbose:\n            print(\"dx was not given or of wrong type/value, taken as fraction of model length instead.\")\n    if not isinstance(dy, (float, int)) or (dy &lt;= 0.0):\n        self.dy = self.pars[\"w_model\"] / 50\n        if verbose:\n            print(\"dy was not given or of wrong type/value, taken as fraction of model width instead.\")\n    if not isinstance(dt, (float, int)) or (dt &lt;= 0.0):\n        self.dt = self.pars[\"t_model\"] / 10\n        if verbose:\n            print(\"dt was not given or of wrong type/value, taken as fraction of model time instead.\")\n\n    self.source_y = self.pars[\"c_source\"][:,0]\n    self.source_c = self.pars[\"c_source\"][:,1]\n\n    # Source zone concentration for superposition algorithm\n    self.c0 = self.source_c[:-1] - self.source_c[1:]\n\n    # Calculate and add biodegradation capacity to the outer plume\n    if mode == \"instant_reaction\":\n        self.biodeg_cap = calculate_biodegradation_capacity(self.pars)\n        self.c0[-1] += self.biodeg_cap\n\n        # No source decay occurs when source mass is infinite\n        if self.pars[\"m_total\"] in [\"inf\", \"infinite\"]:\n            self.k_source_instant = 0\n        else:\n            self.k_source_instant = calculate_source_decay_instant(self.pars, self.biodeg_cap)\n\n    else:\n        self.biodeg_cap = 0\n\n    if verbose:\n        print(\"Setting up dimensional grids...\")\n\n    # Initialize space and time arrays\n    self.x = np.arange(0, parameters[\"l_model\"] + self.dx, self.dx)\n\n    if parameters[\"w_model\"] &gt; 2 * self.source_y[-1]:\n        self.y = np.arange(-parameters[\"w_model\"] / 2, parameters[\"w_model\"] / 2, self.dy)\n    else:\n        self.y = np.arange(-self.source_y[-1], self.source_y[-1] + self.dy, self.dy)\n\n    self.t = np.arange(self.dt, parameters[\"t_model\"] + self.dt, self.dt)\n\n    # To allow array calculations, set space and time as a 3-dimensional array.\n    self.xxx = np.tile(self.x, (len(self.t), len(self.y), 1))\n    self.yyy = np.tile(self.y[:, None], (len(self.t), 1, len(self.x)))\n    self.ttt = np.tile(self.t[:, None, None], (1, len(self.y), len(self.x)))\n    self.cxyt = np.zeros(self.xxx.shape)\n\n    self.cxyt_noBC = 0\n\n    if verbose:\n        print(\"Done with initializing!\")\n</code></pre>"},{"location":"reference/reference/#mibitrans.transport.analytical_equation.Transport.domenico","title":"<code>domenico()</code>","text":"<p>Calculate the Domenico analytical model.</p> <p>Returns:</p> Type Description <p>cxyt (np.ndarray) : 3-dimensional array with values representing contaminant concentrations. Outer dimension</p> <p>represents time, middle dimension represents y-direction and inner dimension represents x-direction.</p> <p>x (np.ndarray) : Array with values representing positions along the x-direction.</p> <p>y (np.ndarray) : Array with values representing positions along the y-direction.</p> <p>t (np.ndarray) : Array with values representing points in time.</p> Source code in <code>mibitrans/transport/analytical_equation.py</code> <pre><code>def domenico(self):\n    \"\"\"Calculate the Domenico analytical model.\n\n    Returns:\n        cxyt (np.ndarray) : 3-dimensional array with values representing contaminant concentrations. Outer dimension\n        represents time, middle dimension represents y-direction and inner dimension represents x-direction.\n        x (np.ndarray) : Array with values representing positions along the x-direction.\n        y (np.ndarray) : Array with values representing positions along the y-direction.\n        t (np.ndarray) : Array with values representing points in time.\n    \"\"\"\n    # Ignore divide by zero warnings; they are a result of working with x and y positions of 0.\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        # terms for linear decay are calculated, terms are 1 for no decay and instant_reaction modes, as mu = 0.\n        decay_sqrt = np.sqrt(1 + 4 * self.mu * self.ax / self.v)\n        decay_term = np.exp(self.xxx * (1 - decay_sqrt) / (self.ax * 2))\n\n        # Advection and dispersion term in the x direction\n        x_term = erfc((self.xxx - self.v * self.ttt * decay_sqrt) / (2 * np.sqrt(self.ax * self.v * self.ttt)))\n\n        # Additional advection and dispersion term in x direction for small times, when there is no linear decay\n        if self.mode != \"linear_decay\":\n            additional_x = (np.exp(self.xxx * self.v / (self.ax * self.v))\n                            * erfc(self.xxx + self.v * self.ttt / (2 * np.sqrt(self.ax * self.v * self.ttt))))\n            x_term += additional_x\n\n        # Dispersion term in the z direction\n        z_term = (erf(self.pars[\"d_source\"] / (2 * np.sqrt(self.az * self.xxx)))\n                 - erf(-self.pars[\"d_source\"] / (2 * np.sqrt(self.az * self.xxx))))\n\n        if self.mode == \"instant_reaction\":\n            sourcedecay_term = np.exp(-self.k_source_instant * (self.ttt - self.xxx / self.v))\n        else:\n            # Source decay term\n            sourcedecay_term = np.exp(-self.k_source * (self.ttt - self.xxx / self.v))\n        # Term can be max 1; can not have 'generation' of solute ahead of advection\n        sourcedecay_term = np.where(sourcedecay_term &gt; 1, 1, sourcedecay_term)\n\n        # Superposition algorithm; calculate plume for each source zone separately, then add together.\n        ccc0_source_list = [0] * len(self.c0)\n        for i in range(len(self.c0)):\n            # Dispersion term in the y direction\n            y_term = (erf((self.yyy + self.source_y[i+1]) / (2 * np.sqrt(self.ay * self.xxx)))\n                     - erf((self.yyy - self.source_y[i+1]) / (2 * np.sqrt(self.ay * self.xxx))))\n\n            y_term[np.isnan(y_term)] = 0\n\n            # Correct source zone concentrations for source decay\n            ccc0_source_list[i] = self.c0[i] * sourcedecay_term\n\n            cxyt = 1 / 8 * ccc0_source_list[i] * decay_term * x_term * y_term * z_term\n\n            self.cxyt += cxyt\n\n    # Substract biodegradation capacity, this can cause low concentration areas to become &lt; 0. Therefore, set\n    # negative values to 0.\n    self.cxyt_noBC = self.cxyt.copy()\n    self.cxyt -= self.biodeg_cap\n    self.cxyt = np.where(self.cxyt &lt; 0, 0, self.cxyt)\n\n    return self.cxyt, self.x, self.y, self.t\n</code></pre>"},{"location":"reference/reference/#mibitrans.visualize","title":"<code>visualize</code>","text":""},{"location":"reference/reference/#mibitrans.visualize.plot_line","title":"<code>plot_line</code>","text":"<p>Author: Jorrit Bakker.</p> <p>Module plotting a 3D matrix of contaminant plume concentrations as a line.</p>"},{"location":"reference/reference/#mibitrans.visualize.plot_line.Lineplot","title":"<code>Lineplot</code>","text":"<p>Line plotting of contaminant plume.</p> Source code in <code>mibitrans/visualize/plot_line.py</code> <pre><code>class Lineplot():\n    \"\"\"Line plotting of contaminant plume.\"\"\"\n    def __init__(self, cxyt, x, y, t):\n        \"\"\"Initialize parameters.\"\"\"\n        self.cxyt = cxyt\n        self.x = x\n        self.y = y\n        self.t = t\n\n    def centerline(self, time = None, y_pos = 0, **kwargs):\n        \"\"\"Plot center of contaminant plume as a line, at a specified time and, optionally, y position.\n\n        Args:\n            time : Point of time for the plot. By default, last point in time is plotted.\n            y_pos : y-position across the plume for the plot. By default, the center of the plume at y=0 is plotted.\n            **kwargs : Arguments to be passed to plt.plot().\n\n        Returns a line plot of the input plume as object.\n        \"\"\"\n        if time is not None:\n            time_pos = np.argmin(abs(self.t - time))\n        else:\n            time_pos = self.t[-1]\n\n        if y_pos is not None:\n            y_pos = np.argmin(abs(self.y - y_pos))\n        else:\n            y_pos = np.argmin(abs(self.y - 0))\n\n        plot_array = self.cxyt[time_pos,y_pos,:]\n\n        plt.plot(self.x,\n                 plot_array,\n                 **kwargs)\n        plt.ylim((0,np.max(plot_array) + 1/8*np.max(plot_array)))\n        plt.xlabel(\"Distance from source [m]\")\n        plt.ylabel(\"Concentration [mg/L]\")\n        plt.grid(True)\n\n\n    def transverse(self, time = None, x_pos = None):\n        \"\"\"Plot across the contaminant plume as a line, at a specified time and x position .\"\"\"\n        print(\"placeholder\")\n\n    def breakthrough(self, x_pos = None, y_pos = None):\n        \"\"\"Plot breakthrough curve of contaminant plume at a specified x and y position.\"\"\"\n        print(\"placeholder\")\n</code></pre>"},{"location":"reference/reference/#mibitrans.visualize.plot_line.Lineplot.__init__","title":"<code>__init__(cxyt, x, y, t)</code>","text":"<p>Initialize parameters.</p> Source code in <code>mibitrans/visualize/plot_line.py</code> <pre><code>def __init__(self, cxyt, x, y, t):\n    \"\"\"Initialize parameters.\"\"\"\n    self.cxyt = cxyt\n    self.x = x\n    self.y = y\n    self.t = t\n</code></pre>"},{"location":"reference/reference/#mibitrans.visualize.plot_line.Lineplot.breakthrough","title":"<code>breakthrough(x_pos=None, y_pos=None)</code>","text":"<p>Plot breakthrough curve of contaminant plume at a specified x and y position.</p> Source code in <code>mibitrans/visualize/plot_line.py</code> <pre><code>def breakthrough(self, x_pos = None, y_pos = None):\n    \"\"\"Plot breakthrough curve of contaminant plume at a specified x and y position.\"\"\"\n    print(\"placeholder\")\n</code></pre>"},{"location":"reference/reference/#mibitrans.visualize.plot_line.Lineplot.centerline","title":"<code>centerline(time=None, y_pos=0, **kwargs)</code>","text":"<p>Plot center of contaminant plume as a line, at a specified time and, optionally, y position.</p> <p>Parameters:</p> Name Type Description Default <code>time </code> <p>Point of time for the plot. By default, last point in time is plotted.</p> required <code>y_pos </code> <p>y-position across the plume for the plot. By default, the center of the plume at y=0 is plotted.</p> required <code>**kwargs </code> <p>Arguments to be passed to plt.plot().</p> required <p>Returns a line plot of the input plume as object.</p> Source code in <code>mibitrans/visualize/plot_line.py</code> <pre><code>def centerline(self, time = None, y_pos = 0, **kwargs):\n    \"\"\"Plot center of contaminant plume as a line, at a specified time and, optionally, y position.\n\n    Args:\n        time : Point of time for the plot. By default, last point in time is plotted.\n        y_pos : y-position across the plume for the plot. By default, the center of the plume at y=0 is plotted.\n        **kwargs : Arguments to be passed to plt.plot().\n\n    Returns a line plot of the input plume as object.\n    \"\"\"\n    if time is not None:\n        time_pos = np.argmin(abs(self.t - time))\n    else:\n        time_pos = self.t[-1]\n\n    if y_pos is not None:\n        y_pos = np.argmin(abs(self.y - y_pos))\n    else:\n        y_pos = np.argmin(abs(self.y - 0))\n\n    plot_array = self.cxyt[time_pos,y_pos,:]\n\n    plt.plot(self.x,\n             plot_array,\n             **kwargs)\n    plt.ylim((0,np.max(plot_array) + 1/8*np.max(plot_array)))\n    plt.xlabel(\"Distance from source [m]\")\n    plt.ylabel(\"Concentration [mg/L]\")\n    plt.grid(True)\n</code></pre>"},{"location":"reference/reference/#mibitrans.visualize.plot_line.Lineplot.transverse","title":"<code>transverse(time=None, x_pos=None)</code>","text":"<p>Plot across the contaminant plume as a line, at a specified time and x position .</p> Source code in <code>mibitrans/visualize/plot_line.py</code> <pre><code>def transverse(self, time = None, x_pos = None):\n    \"\"\"Plot across the contaminant plume as a line, at a specified time and x position .\"\"\"\n    print(\"placeholder\")\n</code></pre>"},{"location":"reference/reference/#mibitrans.visualize.plot_surface","title":"<code>plot_surface</code>","text":""},{"location":"reference/reference/#mibitrans.visualize.plot_surface.Plume","title":"<code>Plume</code>","text":"<p>Multi-dimensional plotting of contaminant plume.</p> Source code in <code>mibitrans/visualize/plot_surface.py</code> <pre><code>class Plume():\n    \"\"\"Multi-dimensional plotting of contaminant plume.\"\"\"\n    def __init__(self, cxyt, x, y, t):\n        \"\"\"Initialize parameters.\"\"\"\n        self.cxyt = cxyt\n        self.x = x\n        self.y = y\n        self.t = t\n        self.xxx = np.tile(self.x, (len(self.t), len(self.y), 1))\n        self.yyy = np.tile(self.y[:, None], (len(self.t), 1, len(self.x)))\n\n    def surface(self, time = None, **kwargs):\n        \"\"\"Plot contaminant plume as a 3D surface plot.\"\"\"\n        if time is not None:\n            time_pos = np.argmin(abs(self.t - time))\n        else:\n            time_pos = self.t[-1]\n\n        fig, ax = plt.subplots(subplot_kw={\"projection\" : \"3d\"})\n        ax.plot_surface(self.xxx[time_pos,:,:],\n                        self.yyy[time_pos,:,:],\n                        self.cxyt[time_pos,:,:],\n                        **kwargs\n                        )\n\n        ax.view_init(elev=30, azim=310)\n        ax.set_xlabel(\"Distance from source (m)\")\n        ax.set_ylabel(\"Distance from plume center (m)\")\n        ax.set_zlabel(r\"Concentration [$g/m^{-3}$]\")\n\n        return(ax)\n\n    def flat(self, time = None, **kwargs):\n        \"\"\"Plot contaminant plume as a 2D surface plot.\"\"\"\n        if time is not None:\n            time_pos = np.argmin(abs(self.t - time))\n        else:\n            time_pos = self.t[-1]\n\n        plt.pcolormesh(self.x,\n                       self.y,\n                       self.cxyt[time_pos,:,:],\n                       **kwargs\n                       )\n\n        plt.xlabel(\"Distance from source (m)\")\n        plt.ylabel(\"Distance from plume center (m)\")\n        plt.colorbar(label = \"Concentration (mg/L)\")\n</code></pre>"},{"location":"reference/reference/#mibitrans.visualize.plot_surface.Plume.__init__","title":"<code>__init__(cxyt, x, y, t)</code>","text":"<p>Initialize parameters.</p> Source code in <code>mibitrans/visualize/plot_surface.py</code> <pre><code>def __init__(self, cxyt, x, y, t):\n    \"\"\"Initialize parameters.\"\"\"\n    self.cxyt = cxyt\n    self.x = x\n    self.y = y\n    self.t = t\n    self.xxx = np.tile(self.x, (len(self.t), len(self.y), 1))\n    self.yyy = np.tile(self.y[:, None], (len(self.t), 1, len(self.x)))\n</code></pre>"},{"location":"reference/reference/#mibitrans.visualize.plot_surface.Plume.flat","title":"<code>flat(time=None, **kwargs)</code>","text":"<p>Plot contaminant plume as a 2D surface plot.</p> Source code in <code>mibitrans/visualize/plot_surface.py</code> <pre><code>def flat(self, time = None, **kwargs):\n    \"\"\"Plot contaminant plume as a 2D surface plot.\"\"\"\n    if time is not None:\n        time_pos = np.argmin(abs(self.t - time))\n    else:\n        time_pos = self.t[-1]\n\n    plt.pcolormesh(self.x,\n                   self.y,\n                   self.cxyt[time_pos,:,:],\n                   **kwargs\n                   )\n\n    plt.xlabel(\"Distance from source (m)\")\n    plt.ylabel(\"Distance from plume center (m)\")\n    plt.colorbar(label = \"Concentration (mg/L)\")\n</code></pre>"},{"location":"reference/reference/#mibitrans.visualize.plot_surface.Plume.surface","title":"<code>surface(time=None, **kwargs)</code>","text":"<p>Plot contaminant plume as a 3D surface plot.</p> Source code in <code>mibitrans/visualize/plot_surface.py</code> <pre><code>def surface(self, time = None, **kwargs):\n    \"\"\"Plot contaminant plume as a 3D surface plot.\"\"\"\n    if time is not None:\n        time_pos = np.argmin(abs(self.t - time))\n    else:\n        time_pos = self.t[-1]\n\n    fig, ax = plt.subplots(subplot_kw={\"projection\" : \"3d\"})\n    ax.plot_surface(self.xxx[time_pos,:,:],\n                    self.yyy[time_pos,:,:],\n                    self.cxyt[time_pos,:,:],\n                    **kwargs\n                    )\n\n    ax.view_init(elev=30, azim=310)\n    ax.set_xlabel(\"Distance from source (m)\")\n    ax.set_ylabel(\"Distance from plume center (m)\")\n    ax.set_zlabel(r\"Concentration [$g/m^{-3}$]\")\n\n    return(ax)\n</code></pre>"},{"location":"reference/reference/#mibitrans.visualize.show_mass_balance","title":"<code>show_mass_balance</code>","text":"<p>Author: Jorrit Bakker.</p> <p>Module calculating methods for mass balance visualization.</p>"},{"location":"reference/reference/#mibitrans.visualize.show_mass_balance.generate_mass_balance_tables","title":"<code>generate_mass_balance_tables(mass_dict)</code>","text":"<p>Generate mass balance tables for relevant model components based on input dictionary.</p> Args <p>mass_dict (dict) : Dictionary with mass balance with the structure as generated by the mass_balance module.</p> Source code in <code>mibitrans/visualize/show_mass_balance.py</code> <pre><code>def generate_mass_balance_tables(mass_dict):\n    \"\"\"Generate mass balance tables for relevant model components based on input dictionary.\n\n    Args :\n        mass_dict (dict) : Dictionary with mass balance with the structure as generated by the mass_balance module.\n\n    \"\"\"\n    # Generate table object with object headers. Seperate tables for each component for clarity\n    # table_source will contain the source decay masses from no decay and linear decay model mode.\n    table_source = PrettyTable([\"Source decay\", \"Mass (g)\"])\n    # table_nodecay will contain the plume masses for no decay model mode.\n    table_nodecay = PrettyTable([\"No decay\", \"Mass (g)\"])\n    # table_lindecay will contain the plume masses for linear decay model mode.\n    table_lindecay = PrettyTable([\"Linear decay\", \"Mass (g)\"])\n    # table_instant will contain the plume and source masses for instant reaction model mode.\n    table_instant = PrettyTable([\"Instant reaction\", \"Mass (g)\"])\n    # table_electron will contain the change in electron acceptor and byproduct masses for instant reaction model mode.\n    table_electron = PrettyTable([\"Electron acceptors/byproducts\", \"O2\", \"NO3-\", \"Fe2+\", \"SO4 2-\", \"CH4\"])\n\n    # Initialize flags which keep track of which model components are present\n    print_source = False\n    print_nodecay = False\n    print_lindecay = False\n    print_instant = False\n    print_electron = False\n\n    # Loop to add each mass balance components to their respective table\n    for key, item in mass_dict.items():\n        # Round mass balance to one decimal to avoid clutter\n        round_item = np.round(item, 1)\n\n        # Time does not need to be renamed and does not need to be added as a row to a table\n        if key != \"time\":\n            # Check if mass balance component is recognized, ignore if it is not.\n            try:\n                # Rename keys to comprehensive table headers\n                rename_key = rename_dict[key]\n            except KeyError:\n                print(f\"The following key is not recognized: '{key}' and is thus ignored\")\n                rename_key = None\n\n            # Add the right mass balance model components to each mass balance table\n            if key in [\"source_mass_0\", \"source_mass_t\", \"source_mass_change\"]:\n                print_source = True\n                # Add time information to name of source mass at t = t\n                if rename_key == \"mass t = \":\n                    rename_key = rename_key + str(mass_dict[\"time\"])\n                table_source.add_row([rename_key, round_item])\n\n            elif key in [\"plume_mass_no_decay\", \"transport_outside_extent_nodecay\"]:\n                print_nodecay = True\n                table_nodecay.add_row([rename_key, round_item])\n\n            elif key in [\"plume_mass_linear_decay\", \"transport_outside_extent_lineardecay\",\n                         \"plume_mass_degraded_linear\"]:\n                print_lindecay = True\n                table_lindecay.add_row([rename_key, round_item])\n\n            elif key in [\"source_mass_instant_t\", \"source_mass_instant_change\", \"plume_mass_no_decay_instant_reaction\",\n                         \"plume_mass_instant_reaction\", \"plume_mass_degraded_instant\"]:\n                print_instant = True\n                if rename_key == \"source mass t = \":\n                    rename_key = rename_key + str(mass_dict[\"time\"])\n                table_instant.add_row([rename_key, round_item])\n\n            elif key == \"electron_acceptor_mass_change\":\n                print_electron = True\n                oxy, no, fe, so, ch = round_item\n                # Oxygen, Nitrate and Sulfate are electron acceptors and thus consumed (negative change),\n                # Iron2+ and Methane are byproducts from electron acceptors and thus generated (postive change).\n                table_electron.add_row([rename_key, -oxy, -no, f\"+{fe}\", -so, f\"+{ch}\"])\n\n    # If mass_balance components were not present in mass balance dictionary, table get set to false,\n    # preventing returning tables with only headers.\n    table_source = table_source if print_source else False\n    table_nodecay = table_nodecay if print_nodecay else False\n    table_lindecay = table_lindecay if print_lindecay else False\n    table_instant = table_instant if print_instant else False\n    table_electron = table_electron if print_electron else False\n\n    return table_source, table_nodecay, table_lindecay, table_instant, table_electron\n</code></pre>"},{"location":"reference/reference/#mibitrans.visualize.show_mass_balance.visualize_mass_balance","title":"<code>visualize_mass_balance(mass_dict)</code>","text":"<p>Takes dictionary with mass balance and prints it as stylized tables.</p> Args <p>mass_dict (dict) : Dictionary with mass balance with the structure as generated by the mass_balance module.</p> Source code in <code>mibitrans/visualize/show_mass_balance.py</code> <pre><code>def visualize_mass_balance(mass_dict) -&gt; None:\n    \"\"\"Takes dictionary with mass balance and prints it as stylized tables.\n\n    Args :\n        mass_dict (dict) : Dictionary with mass balance with the structure as generated by the mass_balance module.\n\n    \"\"\"\n    # Mass balance table generating function separate to allow user to choose whether to print tables\n    # or just get their objects.\n    table_source, table_nodecay, table_lindecay, table_instant, table_electron = generate_mass_balance_tables(mass_dict)\n\n    print(f\"MASS BALANCE FOR t = {mass_dict['time']}\")\n\n    # If a table contained no entries, it is set to false by generating function, allowing this function to only print\n    # filled tables.\n    if table_source is not False:\n        print(table_source)\n    if table_nodecay is not False:\n        print(table_nodecay)\n    if table_lindecay is not False:\n        print(table_lindecay)\n    if table_instant is not False:\n        print(table_instant)\n    if table_electron is not False:\n        print(table_electron)\n</code></pre>"}]}