{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documention for <code>mibitrans</code> python package","text":""},{"location":"#how-to-use-mibitrans","title":"How to use mibitrans","text":"<p>A collection of analytical and semi-semianalytical solutions for hydrogeological transport phenomena</p>"},{"location":"#installation","title":"Installation","text":"<p>To install mibitrans from GitHub repository, do:</p> <pre><code>git clone git@github.com:MiBiPreT/mibitrans.git\ncd mibitrans\npython -m pip install .\n</code></pre>"},{"location":"background/bioscreen/","title":"BIOSCREEN","text":""},{"location":"background/bioscreen/#general","title":"General","text":"<p>BIOSCREEN has been developed by the U.S. Environmental Protection Agency (EPA) in collaboration with the U.S. Air Force as natural attenuation decision support tool. Its is meant as screening tool to determine if a full-scale evaluation of a contaminated site is needed. Thereby it is not replacing a more involved numerical model, but serves as preliminary step to evaluate the necessity of an involved numerical model. </p> <p>BIOSCREEN calculates contaminant concentration distributions in 3D for a constant source under uniform flow conditions based on the advection dispersion equation. The source domain can contain several zones of different concentrations. Three modes of decay can be chose to represent degradation processes: * no decay * linear decay * instantaneous biodegradation reaction</p> <p>Input parameters for BIOSCREEN are few compared to numerical models. After parameter entry, visualization of concentrations at the plume centreline or as a 3D plume can be performed for each of the three decay modes. Version 1.4 provides the option to calculate mass balances of the plume and the source. BIOSCREEN comes with two sets of example data.</p> <p>BIOSCREEN is implemented in Excel, and provides a graphical interface. The latest version is BIOSCREEN 1.4. It was released to be compatible with Microsoft Excel 5.0. Analysis is performed using macro scripts and cellular calculations. Calculations inside the Excel sheets are hidden in the background, and give insight into the actual calculations behind the model. The spatial resolution of the plume is fixed to 11 steps over the plume length and 5 steps lateral to the plume. Temporal resolution is fixed to 10 time steps. This resolution is relative to the set model extent and time.</p>"},{"location":"background/bioscreen/#transport-model","title":"Transport model","text":"<p>Transport is modeled based on the three-dimensional advection-dispersion equation (ADE) with linear equilibrium adsorption for uniform flow in \\(x\\)-direction:</p> \\[ \\begin{equation}\\tag{1}\\label{eq:01_ADE3D}     R\\frac{\\partial C}{\\partial t} = -v\\frac{\\partial C}{\\partial x} + D_{x}\\frac{\\partial ^2 C}{\\partial x^2} + D_y \\frac{\\partial^2 C}{\\partial y^2} + D_z \\frac{\\partial^2 C}{\\partial z^2} + r_{sinks} \\end{equation} \\] <p>Here \\(C(x,y,z,t)\\) is the contaminant concentration in space \\((x,y,z)\\) and time \\(t\\), \\(R\\) is the linear equilibrium retardation factor, \\(v\\) is the uniform groundwater velocity in \\(x\\)-direction, \\(D_{x}\\), \\(D_{y}\\) and \\(D_{y}\\) are the longitudinal, transverse horizontal and transverse vertical dispersion coefficients, respectively. \\(r_{sinks}\\) represents the sink term as result to decay/degradation. \\(r_{sinks} = 0\\) represents no decay/degradation. For linear decay, \\(r_{sinks} = -\\lambda C\\). In the equation \\(\\frac{\\partial C}{\\partial t}\\) represents the change of the concentration over time. \\(-v\\frac{\\partial C}{\\partial x}\\) is the change of concentration in the direction of the groundwater gradient due to advection. \\(D_{x}\\frac{\\partial ^2 C}{\\partial x^2} + D_{y}\\frac{\\partial ^2 C}{\\partial y^2}+ + D_{z}\\frac{\\partial^2 C}{\\partial z^2}\\) represent the change in concentration to dispersion. </p> <p>A specific solution of the ADE \\(\\eqref{eq:01_ADE3D}\\), depends on the specific form of the sink-term \\(r_{sinks}\\) as well as initial and boundary conditions. Transport in BIOSCREEN is modelled based on the analytical model of Domenico, [1987]. </p>"},{"location":"background/bioscreen/#domenico-model","title":"Domenico Model","text":"<p>An analytical model for the ADE for initial and boundary conditions representing typical spill field situation has been presented by Domenico, 1987. The solution has not been derived mathematically rigorous as analytical solution of the ADE, but has been composed of analytical solutions for the individual processes. As Domenico, [1987] writes, an exact solution to this problem cannot avaid some form of numerical integration. The provided analytical expression approximates the concentration distribution of a decaying species that is released to the aquifer as an extended pulse. West et al., 2007 provides a detailed overview on the effects of the approximations in the Domenico-solution and potential error it can introduce to solute transport predictions.</p> <p>Specifically, the Domenico-model takes the following assumption on initial and boundary conditions: * Flow is uniform in \\(x\\) direction with constant velocity \\(v\\). * The contaminant decays continuously at a rate of \\(\\lambda\\) (independent of position). * There is no adsorption/retardation of the contaminant. * The contaminant is released to the aquifer within a source plane of width \\(Y\\), height \\(Z\\), located at \\(x=0\\) and centered at \\(y=0\\) and \\(z=0\\), so the center of plume is always located along the \\(x\\)-axis. * The input of contaminant at the source is constant over time with an amount of \\(C_0\\) that does not change over time. Specifically, it assumes that the source is not subject to depletion or internal decay/degradation that reduced source concentrations.</p> <p>The equation describing the solute distribution in time and space of the Domenico-model reads:</p> \\[ \\begin{align}\\tag{2}     C(x, y, z, t) &amp;= \\frac{C_{0}}{8} \\exp \\left[ \\frac{x\\left(1-\\sqrt{1+4\\lambda \\alpha_x/v}\\right)}{2\\alpha_x}\\right] \\\\     &amp;\\quad \\cdot \\operatorname{erfc} \\left[ \\frac{x - vt\\sqrt{1+4\\lambda \\alpha_x/v}}{2\\sqrt{\\alpha_x vt }} \\right] \\\\     &amp;\\quad \\cdot \\left\\{ \\operatorname{erf} \\left[ \\frac{y + Y/2}{2\\sqrt{\\alpha_y x}} \\right] - \\operatorname{erf} \\left[ \\frac{y - Y/2}{2\\sqrt{\\alpha_y x)}} \\right] \\right\\} \\\\     &amp;\\quad \\cdot \\Biggl. \\left\\{ \\operatorname{erf} \\left[ \\frac{z +Z/2}{2\\sqrt{\\alpha_z x)}} \\right] - \\operatorname{erf} \\left[ \\frac{z-Z/2}{2\\sqrt{\\alpha_z x}} \\right] \\right\\} \\nonumber \\end{align} \\] <p>where \\(C(x,y,z,t)\\) is the contaminant concentration in \\(M/V^3\\) at position \\((x,y,z)\\) and time \\(t\\). \\(v\\) is the groundwater flow velocity in \\(m/d\\). \\(\\alpha_x\\) is the longitudinal dispersivity (in the x-direction). \\(\\alpha_y\\) is the transverse horizontal dispersivity (in the y-direction). \\(Y\\) and \\(Z\\) are the width and thickness/height of the source in the saturated zone in \\(m\\).</p> <p>The first two terms account for the transport of contaminants in horizontal direction due to advection and longitudinal dispersion while being subject to continuous decay. This part is based on the plug flow model of Bear, 1979 and is in line with other derivations of analytical solutions for the 1D ADE assuming uniform flow, constant decay and continuous input of contaminant.</p> <p>The two terms in the second row account for the dilution of the plume due to transverse dispersion. They were derived by Domenico and Palciauskas, 1982. The model is formulated as a boundary value problem that approximates the spreading. However, the terms are not in line with mathematically rigorous derived analytical solutions for this process. The terms \\(\\sqrt{\\alpha_{y/z} x)}\\) in the denominator should read \\(\\sqrt{\\alpha_{y/z} vt)}\\). Consequently, this form effectively assumes a linear increase of lateral dispersion as function of the plume travel distance. This is a misinterpretation of the concept of transverse spreading. Lateral spreading takes place at every distance. Note, that this should not be mixed up with the characteristics of longitudinal dispersion that is evolving over distance up to a asymptotic value that depends on aquifer heterogeneity (i.e. also not linearly with plume travel distance).</p> <p>Bioscreen makes use of the Domenico-model in various adaptions (Newell et al., 1996, 1997).</p>"},{"location":"background/bioscreen/#bioscreen-implementation-of-decay-and-no-decay-solutions","title":"BIOSCREEN Implementation of Decay and No-decay solutions","text":"<p>Bioscreen does not directly use the Domenico model, but an extension regarding source handling and retardation. For the cases of linear decay of the contaminant (\\(\\lambda \\neq 0\\)) and the case of no decay (\\(\\lambda = 0\\)), they include a source decay term accounting for reduction/depletion of the input concentration from the source in the form of \\(C_0(x,t) = C_0 \\exp{\\left( -k_s \\left( t-\\frac{x}{v}\\right)\\right)}\\).</p> <p>The analytical expression used by BIOSCREEN for no-decay (\\(\\lambda = 0\\)) and linear decay (\\(\\lambda \\neq 0\\)) reads (Newell et al., 1997):</p> \\[ \\begin{align}\\tag{3}     C(x, y, z, t) &amp; = \\frac{C_{0}}{8}\\exp{\\left( -k_s \\left( t-\\frac{x}{v}\\right)\\right)} \\\\      &amp;\\quad \\cdot  \\exp \\left[ \\frac{x\\left(1-\\sqrt{1+4\\lambda \\alpha_x/v}\\right)}{2\\alpha_x}\\right]      \\cdot \\operatorname{erfc} \\left[ \\frac{x - vt\\sqrt{1+4\\lambda \\alpha_x/v}}{2\\sqrt{\\alpha_x vt }} \\right] \\\\     &amp;\\quad \\cdot \\left\\{ \\operatorname{erf} \\left[ \\frac{y + Y/2}{2\\sqrt{\\alpha_y x}} \\right] - \\operatorname{erf} \\left[ \\frac{y - Y/2}{2\\sqrt{\\alpha_y x)}} \\right] \\right\\} \\\\     &amp;\\quad \\cdot \\Biggl. \\left\\{ \\operatorname{erf} \\left[ \\frac{Z/2}{2\\sqrt{\\alpha_z x)}} \\right] - \\operatorname{erf} \\left[ \\frac{Z/2}{2\\sqrt{\\alpha_z x}} \\right] \\right\\} \\nonumber \\end{align} \\] <p>Note that here \\(z=0\\) compared to Eq. \\(\\eqref{eq:02_domenico}\\), indicating that Bioscreen only evaluates the solution \\(z=0\\) and does not provide a vertically resolved solution.</p> <p>Bioscreen also uses the Domenico model in Eq. \\(\\eqref{eq:02_domenico}\\) as starting point for developing the model for the instantaneous reaction. </p> \\[ \\begin{align}\\tag{4}     C(x, y, z, t) &amp;= \\frac{C_{0}}{8}\\exp{\\left( -k_s \\left( t-\\frac{x}{v}\\right)+BC\\right)} \\\\     &amp;\\quad \\cdot \\operatorname{erfc} \\left[ \\frac{x - vt}{2\\sqrt{\\alpha_x vt }} \\right] \\\\     &amp;\\quad \\cdot \\left\\{ \\operatorname{erf} \\left[ \\frac{y + Y/2}{2\\sqrt{\\alpha_y x}} \\right] - \\operatorname{erf} \\left[ \\frac{y - Y/2}{2\\sqrt{\\alpha_y x)}} \\right] \\right\\} \\\\     &amp;\\quad \\cdot \\Biggl. \\left\\{ \\operatorname{erf} \\left[ \\frac{Z/2}{2\\sqrt{\\alpha_z x)}} \\right] - \\operatorname{erf} \\left[ \\frac{Z/2}{2\\sqrt{\\alpha_z x}} \\right] \\right\\} -BC \\nonumber \\end{align} \\]"},{"location":"background/bioscreen/#bioscreen-implementation-of-instant-reaction-model","title":"BIOSCREEN Implementation of Instant reaction model","text":"<p>BIOSCREEN uses a superposition approach in combination with the Domenico-model to model instantaneous aerobic and anaerobic reactions in groundwater, based on available concentrations of electron acceptors (EAs). They argue that the comparison to more complex models resolving the processes shows good agreement (within the range of assumptions) justifying the use of this heuristic approach for reactive transport modelling.</p>"},{"location":"background/bioscreen/#principle","title":"Principle","text":"<p>The general model idea is: * Calculate how much contaminant can be consumed by an instantaneous reactions with all present EA\u2019s based on their global concentrations. That amount is called biodegredation capacity BC. The BC is a lumped value that reflects the potential contaminant mass removal of available EAs. * Calculate the spatially distributed contaminant concentration as if there is no decay. But adapt the handling of the source concentration: the source zone concentration is the sum of the measured source zone concentration and the biodegradation capacity BC. * Subtract the BC from the calculated concentration for every location and time, i.e. reduce the concentration by what can be consumed by reactions.</p> <p>This procedure is implemented as a superposition of the reaction to the Domenico model. By this method, contaminant mass concentrations are transported conservatively and then corrected at any location and time within the flow field by subtracting 1 mg/L organic mass for each mg/L of BC provided by all of the available electron acceptors.</p> <p>Specifically, the equation for the instant reaction model in BIOSCREEN reads:</p> \\[ \\begin{align}\\tag{5}     C(x, y, t) + BC &amp;= \\sum_{i=0}^{n} \\Biggl\\{ \\left( C^*_{0,i} \\exp \\left[-k_s^{inst} \\left(t - \\frac{xR}{v} \\right)\\right] + BC \\right) \\bigr. \\\\     &amp;\\quad \\quad \\quad \\cdot \\left\\{ \\frac{1}{8} \\operatorname{erfc} \\left[ \\frac{x - \\frac{vt}{R}}{2\\sqrt{\\alpha_x \\frac{vt}{R}}} \\right] \\right\\}  \\\\     &amp;\\quad \\quad \\quad \\cdot \\left\\{ \\operatorname{erf} \\left[ \\frac{y + Y^*_i}{2\\sqrt{\\alpha_y x}} \\right] - \\operatorname{erf} \\left[ \\frac{y - Y^*_i}{2\\sqrt{\\alpha_y x)}} \\right] \\right\\} \\\\     &amp;\\quad \\quad \\quad \\cdot \\Biggl. \\left\\{ \\operatorname{erf} \\left[ \\frac{Z}{2\\sqrt{\\alpha_z x)}} \\right] - \\operatorname{erf} \\left[ \\frac{-Z}{2\\sqrt{\\alpha_z x}} \\right] \\right\\} \\Biggr\\}  \\end{align} \\]"},{"location":"background/bioscreen/#biodegradation-capacity-bc","title":"Biodegradation Capacity BC","text":"<p>The Biodegradation capacity is calculated via:</p> \\[ \\begin{equation}\\tag{6}    BC = \\sum_{O,N,S} (\\bar C_i^\\mathrm{upgradient} - C_i^\\mathrm{source})/UF_i + \\sum_{Fe2+,CH_4^+}  \\bar C_j^\\mathrm{source}/UF_j  \\end{equation} \\] <p>here \\(\\bar C_i^\\mathrm{upgradient}\\) is the average upgradient concentrations and \\(C_i^\\mathrm{source})\\) is the minimum source concentration of \\(i=\\)  oxygen, nitrate, sulfate. \\(\\bar C_j^\\mathrm{source}\\) is the average source concentration of \\(j=Fe2+,CH_4^+\\).  \\(UF_i\\) and \\(UF_j\\) are the utilization factors for each EA that was developed based on the stoichimetric ratios of the reactions (see below).</p> <p>The usage of measured concentrations is based on the following assumption for the different EAs: * Available EA from oxygen, nitrate and sulfate are transported with the groundwater, thus their concentrations are replenished.Their available concentrations for biodegradation are equal to the difference between average upgradient and minimum source concentrations (which is considered the available background concentration). A key assumptions here is that GW upstream is unaffected and their is full consumption of these AE in source zone. * Available EA from iron-reducing and methanogenesis reactions are determined from measure concentrations of metabolic by-products: ferrous iron (Fe2+) and methane in source zone. EAs of these reaction are difficult to quantify (C02 is produced as end product of other reactions and ferric iron (Fe3+) is dissolved from the aquifer matrix. A key assumption here is that the model does not account for depletion of \\(Fe3+\\) in aquifer matrix.</p> <p>The calculated value of BC for the given global concentrations of EAs/EA-byproducts provides an estimate of the biodegradation capacity of the groundwater flowing through the source zone and plume and the aquifer soil matrix. In the instantaneous reaction model, it is assumed that EA\u2019s are consumed to full capacity for contaminant reduction. This includes the assumption that all reactions occur over the entire area of the contaminant plume.</p>"},{"location":"background/bioscreen/#utilization-factors-uf","title":"Utilization factors UF","text":"<p>Utilization factors are based on the stoichimetric ratios of the reactions between the four BTEX compounds and each of the EAs as presented in Wiedemeier, 1995. The utilization factor for oxygen, nitrate, and sulfate can be developed showing the stoichiometric ratio of EA consumed to the mass of dissolved hydrocarbon degraded in the biodegradation reactions. Utilization factors for iron reduction and methanogenesis can be developed from the ratio of generated mass of metabolic by-products to mass of dissolved hydrocarbon degraded. </p> EA/Byproduct UF (gm/gm) Oxygen 3.14 Nitrate 4.9 Sulfate 4.7 Ferrous Iron 21.8 Methane 0.78 <p>Table: BTEX utilization factors (UF) for redox reactions</p> <p>Note that UFs are limited to reactions of EAs with BTEX constituents. When aiming to model other contaminants, the utilization factors would need to be adapted. Alternatively, available oxygen, nitrate, iron, sulfate, and methane concentrations could be adjusted accordingly to reflect alternate utilization factors. </p>"},{"location":"background/bioscreen/#references","title":"References","text":"<p>Bear, J., Hydraulics of groundwater, London ; New York : McGraw-Hill International Book Co., 1979</p> <p>Domenico, P. A., and V. V. Palciauskas, Alternative Boundaries in Solid Waste Management, Groundwater, 20 (3), 303\u2013311, 1982</p> <p>[Domenico, P., An analytical model for multidimensional transport of a decaying contaminant species, Journal of Hydrology, 91, 49\u201358, doi:10.1016/0022-1694(87)90127-2, 1987.] (https://doi.org/10.1016/0022-1694(87)90127-2)</p> <p>Newell, C. J., R. K. Mcleod, J. R. Gonzales, and J. T. Wilson, BIOSCREEN natural attenuation decision support system user\u2019s manual version 1.3, Tech. rep., U.S. EPA, 1996.</p> <p>Newell, C. J., R. K. Mcleod, J. R. Gonzales, and J. T. Wilson, BIOSCREEN Natural Attenuation Decision Support System Version 1.4 Revisions, U.S. EPA, 1997.</p> <p>West, M. R., B. H. Kueper, and M. J. Ungs, On the use and error of approximation in the Domenico (1987) solution, Groundwater, 45 (2), 126\u2013135, 2007</p> <p>Wiedemeier, T. H., J. T. Wilson, D. H. Kampbell, R. N. Miller, and J. E. Hansen, Technical protocol for implementing intrinsic remediation with long-term monitoring for natural attenuation of fuel contamination dissolved in groundwater. Volume II, Tech. Rep. AD-A\u2013324247/6/XAB, Parsons Engineering Science, Inc., Denver, CO (United States), 1995</p>"},{"location":"background/bioscreen/#bugs-in-bioscreen","title":"Bugs in BIOSCREEN","text":"<p>During the setup of <code>mibitrans</code>, BIOSCREEN has been thoroughly tested. It was found to be host to a minor erroneous calculation for the instant reaction model. BIOSCREEN uses calculations from the no decay model and corrects them for the different source decay coefficient and source zone concentrations. However, in these corrections, the wrong source decay coefficient is used, resulting in an underestimation of modelled biodegradation. The size of the error is determined by choice of parameters relating to source decay and biodegradation capacity. </p>"},{"location":"development/development/","title":"<code>mibitrans</code> developer documentation","text":""},{"location":"development/development/#development-install","title":"Development install","text":"<pre><code># Create a virtual environment, e.g. with\npython -m venv env\n\n# activate virtual environment\nsource env/bin/activate\n\n# make sure to have a recent version of pip and setuptools\npython -m pip install --upgrade pip setuptools\n\n# (from the project root directory)\n# install mibitrans as an editable package\npython -m pip install --no-cache-dir --editable .\n# install development dependencies\npython -m pip install --no-cache-dir --editable .[dev]\n</code></pre> <p>Afterwards check that the install directory is present in the <code>PATH</code> environment variable.</p>"},{"location":"development/development/#running-the-tests","title":"Running the tests","text":"<p>There are two ways to run tests.</p> <p>The first way requires an activated virtual environment with the development tools installed:</p> <pre><code>pytest -v\n</code></pre> <p>The second is to use <code>tox</code>, which can be installed separately (e.g. with <code>pip install tox</code>), i.e. not necessarily inside the virtual environment you use for installing <code>mibitrans</code>, but then builds the necessary virtual environments itself by simply running:</p> <pre><code>tox\n</code></pre> <p>Testing with <code>tox</code> allows for keeping the testing environment separate from your development environment. The development environment will typically accumulate (old) packages during development that interfere with testing; this problem is avoided by testing with <code>tox</code>.</p>"},{"location":"development/development/#test-coverage","title":"Test coverage","text":"<p>In addition to just running the tests to see if they pass, they can be used for coverage statistics, i.e. to determine how much of the package\u2019s code is actually executed during tests. In an activated virtual environment with the development tools installed, inside the package directory, run:</p> <pre><code>coverage run\n</code></pre> <p>This runs tests and stores the result in a <code>.coverage</code> file. To see the results on the command line, run</p> <pre><code>coverage report\n</code></pre> <p><code>coverage</code> can also generate output in HTML and other formats; see <code>coverage help</code> for more information.</p>"},{"location":"development/development/#running-linters-locally","title":"Running linters locally","text":"<p>For linting and sorting imports we will use ruff. Running the linters requires an  activated virtual environment with the development tools installed.</p> <pre><code># linter\nruff check .\n\n# linter with automatic fixing\nruff check . --fix\n</code></pre> <p>To fix readability of your code style you can use yapf.</p> <p>You can enable automatic linting with <code>ruff</code> on commit by enabling the git hook from <code>.githooks/pre-commit</code>, like so:</p> <pre><code>git config --local core.hooksPath .githooks\n</code></pre>"},{"location":"development/development/#cleaning-notebooks","title":"Cleaning notebooks","text":"<p>The linter tests now also check that the example notebooks are \u201cclean\u201d. This means they do not contain the output and execution metadata that Jupyter adds when you execute them. Removing this reduces the size and noisiness of the diffs and consequently makes reviewing changes easier.</p> <p>To clean the notebooks locally before each commit, you can use the <code>nb-clean</code> tool, which is listed as one of the <code>[dev]</code> dependencies of the project. They are installable with: <pre><code>python -m pip install .[dev]\n</code></pre></p> <p>You can then run: <pre><code>nb-clean add-filter\n</code></pre> This adds a git hook that will automatically clean any staged notebooks before they are committed. If you would rather run this manually, you can instead use: <pre><code>nb-clean clean mynotebook.ipynb\n</code></pre> replacing with the name of the notebook in question.</p>"},{"location":"development/development/#testing-docs-locally","title":"Testing docs locally","text":"<p>To build the documentation locally, first make sure <code>mkdocs</code> and its dependencies are installed: <pre><code>python -m pip install .[doc]\n</code></pre></p> <p>Then you can build the documentation and serve it locally with <pre><code>mkdocs serve\n</code></pre></p> <p>This will return a URL (e.g. <code>http://127.0.0.1:8000/mibitrans/</code>) where the docs site can be viewed.</p>"},{"location":"development/development/#versioning","title":"Versioning","text":"<p>Bumping the version across all files is done with bump-my-version, e.g.</p> <pre><code>bump-my-version bump major  # bumps from e.g. 0.3.2 to 1.0.0\nbump-my-version bump minor  # bumps from e.g. 0.3.2 to 0.4.0\nbump-my-version bump patch  # bumps from e.g. 0.3.2 to 0.3.3\n</code></pre>"},{"location":"development/development/#making-a-release","title":"Making a release","text":"<p>To create a release you need write permission on the repository.</p> <p>This section describes how to make a release:</p> <ol> <li>preparation</li> <li>making a release on GitHub</li> </ol>"},{"location":"development/development/#12-preparation","title":"(1/2) Preparation","text":"<ol> <li>Checkout the main branch locally</li> <li>Verify that the information (especially the author list) in <code>CITATION.cff</code> is correct.</li> <li>Make sure the version has been updated.</li> <li>Run the unit tests with <code>pytest -v</code></li> <li>Make sure the docs build and look good</li> </ol>"},{"location":"development/development/#22-github","title":"(2/2) GitHub","text":"<p>When all is well, navigate to the releases on GitHub.</p> <ol> <li>Press draft a new release button</li> <li>Select the \u201cChoose a tag\u201d drop down and write out the new version (e.g. v1.3.2)</li> <li>Press \u201cGenerate release notes\u201d to automatically fill the title (with the version number) and generate a description (the changelog from the merge pull requests)</li> <li>Press the Publish release button</li> </ol> <p>This will create the release on github and automatically trigger:</p> <ol> <li>The <code>.github/workflows/publish.yml</code> workflow which will build the package and publish it on PyPI</li> <li>The Zenodo-Github integration into making a snapshot of your repository and sticking a DOI on it and adding the new version to the main Zenodo entry for your software.</li> </ol>"},{"location":"introduction/introduction/","title":"Introduction","text":""},{"location":"introduction/introduction/#general","title":"General","text":"<p>Contaminated sites pose a risk to humans and the environment. Innovative cleaning technologies are needed to remediate these sites and remove contaminants such as petroleum hydrocarbons (PHC), cyanides and hexachlorocyclohexane (HCH).</p> <p>Conventional methods of contaminated site remediation are often costly and upkeep intensive. Bioremediation is an alternative of particular interest, as it degrades contaminants on-site. Assessment of ongoing biodegradation is an important step to check the feasibility for bioremediation. Similarly, modeling the fate of contaminants is key for understanding the processes involved and predicting bioremediation in the field. </p> <p>Estimating the extend of a contaminant plume through modelling is highly valuable for designing monitoring and site remediation strategies. Predicting the fate of contaminant in the subsurface requires combining simulations on groundwater flow, contaminant transport and chemical reactions. Simulations allows making predictions on amounts, locations and time scales of biodegradation as well as measures of bioremediation. Complex numerical models can provide a detailed picture by taking site geometry, complex flow pattern and contaminant source distrubution into account. But they require sufficient data and detailed knowledge of site conditions and come at high computational cost and expert knowledge for setup. Simple models, based on analytical and semi-analytical solutions of the subsurface transport equation do not necessarily provide a realistic distribution of the contaminant, but they allow a quick estimate of plume travel distances, plume extend and mass balance. They are thus a good first transport screening option.</p> <p>The purpose of the <code>mibitrans</code> package is to provide such as transport screening model based on hydrogeological field data for biodegredation and bioremediation. </p>"},{"location":"introduction/introduction/#mibirem","title":"MIBIREM","text":"<p>MIBIREM - Innovative technological toolbox for bioremediation is a EU funded consortium project by 12 international partners all over Europe working together to develop an Innovative technological toolbox for bioremediation. The project will develop molecular methods for the monitoring, isolation, cultivation and subsequent deposition of whole microbiomes. The toolbox will also include the methodology for the improvement of specific microbiome functions, including evolution and enrichment. The performance of selected microbiomes will be tested under real field conditions. The <code>mibitrans</code> package is part of this toolbox.</p>"},{"location":"introduction/introduction/#bioremediation","title":"Bioremediation","text":"<p>Bioremediation uses living organisms (including bacteria) to digest and neutralize environmental contaminants. Like the microbiome in the gut, which supports the body in digesting food, microbiomes at contaminated sites can degrade organic contaminant in soil and groundwater.</p> <p>Processes relevant for general biodegradation and bioremediation prediction are:</p> <ul> <li>hydrogeological flow and transport: this includes groundwater flow driven by hydraulic gradients, advective transport of contaminant, diffusion and dispersion</li> <li>transformation and phase transition processes: dissolution, volatilization, adsorption/retardation, decay</li> <li>biochemical processes: chemical reaction and microbial degradation</li> <li>microbiome evolution: spatial distribution and temporal development of bacteria actively degrading contaminants under various and/or changing environmental conditions.</li> </ul> <p>Modeling all these processes at the same time, requires a high level of model detail, spatially resolved parameter information and knowledge on initial and boundary conditions. This is typically not feasible in the field. Thus, we follow the approach to select and combine most relevant processes and have modeling sub-modules (repositories within the MiBiPreT organization) which can be used for data analysis and predictive modeling of individual or combined processes. At the same time, modules are designed to allow for coupling of processes and (modeling) sub-modules at a advanced stage of tool development.</p>"},{"location":"introduction/introduction/#functionality","title":"Functionality","text":"<p><code>mibitrans</code> is supposed to serve as hydrogeological transport screening model based on field data for biodegredation and bioremediation. In parts <code>mibitrans</code> reproduces - and extends- the functionality of the Excel-based screening tool <code>BIOSCREEN</code> [Newell et al., 1996]. Thus, transport is modelled based on the 3D advection dispersion equation considering linear equilibrium adsorption and various options for biodegradation. The option of no decay is also available. <code>mibitrans</code> is validated by comparing example field data with results from <code>BIOSCREEN</code>. </p>"},{"location":"introduction/introduction/#structure","title":"Structure","text":"<p>The core elements and folders for users of <code>mibitrans</code> are:</p> <ul> <li>The folder <code>mibitrans</code> contains the main functionality split up into folders for:<ul> <li><code>data</code></li> <li><code>transport</code></li> <li><code>analysis</code> </li> <li><code>visualization</code></li> </ul> </li> <li>The folder <code>examples</code> contains example workflows in the form of Jupyter-Notebooks outlining application of functionality on example data.</li> </ul>"},{"location":"introduction/introduction/#references","title":"References","text":"<p>Newell, C. J., R. K. Mcleod, J. R. Gonzales, and J. T. Wilson, BIOSCREEN natural attenuation decision support system user\u2019s manual version 1.3, Tech. rep., U.S. EPA, 1996.</p> <p>Newell, C. J., R. K. McLeod, and J. R. Gonzales, BIOSCREEN natural attenuation decision support system version 1.4 revisions, Tech. rep., U.S. EPA, 1997.</p>"},{"location":"reference/reference_analysis/","title":"<code>mibitrans.analysis</code> API reference","text":""},{"location":"reference/reference_analysis/#mibitrans.analysis.mass_balance","title":"<code>mass_balance</code>","text":"<p>Author: Jorrit Bakker.</p> <p>Module calculating the mass balance based on base parameters.</p>"},{"location":"reference/reference_analysis/#mibitrans.analysis.mass_balance.MassBalance","title":"<code>MassBalance</code>","text":"<p>Calculate mass balance characteristics of input model.</p> Source code in <code>mibitrans/analysis/mass_balance.py</code> <pre><code>class MassBalance:\n    \"\"\"Calculate mass balance characteristics of input model.\"\"\"\n\n    def __init__(self, results, time, verbose=False):\n        \"\"\"Mass balance object with source and plume characteristics at given time(s), of input model.\n\n        Args:\n            results: Input model for which mass balance is calculated, should be a child class of Transport3D.\n            time (float | str): Time at which to initially calculate the mass balance. Either as a value between 0 and\n                model end time. Or as 'all', which will calculate mass balance attributes for each time step as arrays.\n            verbose (bool, optional): Verbose mode. Defaults to False.\n\n        Call:\n            Calling the MassBalance object will recalculate the mass balance characteristics of input model for given\n                input time.\n\n        Properties:\n            plume_mass: Mass of the contaminant plume inside the model extent, at the given time(s), in [g].\n            source_mass: Mass of the contaminant source at the given time(s), in [g]. No values are given for models\n                with infinite source mass.\n            delta_source: Difference in mass between contaminant source at given time and source at t = 0, in [g].\n            degraded_mass: Mass of plume contaminant degradation at the given time(s), compared to a model without\n                degradation, in [g]. Has no value if model does not consider degradation.\n            model_without_degradation: Object of model without degradation. Has no value if model does not consider\n                degradation.\n            instant_reaction_degraded_mass(self): Difference in plume mass instant reaction with and without\n                biodegradation capacity subtracted, in [g].\n            electron_acceptor_change(self): Change in electron acceptor/byproduct masses at the given time(s), in [g].\n                Only for instant reaction.\n        \"\"\"\n        check_model_type(results, mibitrans.transport.model_parent.Results)\n        self.results = results\n        self.verbose = verbose\n        self.t = self._time_check(time)\n\n        self._plume_mass_t = None\n        self._source_mass_t = None\n        self._delta_source_t = None\n        self._degraded_mass_t = None\n        self._electron_acceptor_change_t = None\n        self._instant_reaction_degraded_mass_t = None\n        self._model_without_degradation = None\n\n        # Volume of single cell, as dx * dy * source thickness\n        self.cellsize = (\n            abs(results.x[0] - results.x[1]) * abs(results.y[0] - results.y[1]) * results.source_parameters.depth\n        )\n\n        # Mass balance output differs if the source is represented as an infinite mass.\n        if self.results.source_parameters.total_mass == np.inf:\n            self.source_mass_finite = False\n        else:\n            self.source_mass_finite = True\n\n        match self.results.mode:\n            # Instant reaction model\n            case \"instant_reaction\":\n                self.model_instant_reaction = True\n                self.model_degradation = True\n            # Linear decay model\n            case \"linear\" if self.results.attenuation_parameters.decay_rate &gt; 0:\n                self.model_degradation = True\n                self.model_instant_reaction = False\n            # No decay model\n            case _:\n                self.model_degradation = False\n                self.model_instant_reaction = False\n\n        if self.verbose:\n            print(\"Calculating mass balance...\")\n\n        self._calculation_routine()\n\n    def __call__(self, time=None, method=None):\n        \"\"\"Recalculate the mass balance characteristics of input model for given time and method.\"\"\"\n        if time:\n            self.t = self._time_check(time)\n\n        if self.verbose:\n            print(\"Recalculating mass balance...\")\n\n        self._calculation_routine()\n\n    @property\n    def plume_mass(self):\n        \"\"\"Mass of the contaminant plume in the model extent, at the given time(s), in [g].\"\"\"\n        return self._plume_mass_t\n\n    @property\n    def source_mass(self):\n        \"\"\"Mass of the contaminant source at the given time(s), in [g]. No values are given for infinite source mass.\"\"\"\n        return self._source_mass_t\n\n    @property\n    def delta_source(self):\n        \"\"\"Difference in mass between contaminant source at given time and source at t = 0, in [g].\"\"\"\n        return self._delta_source_t\n\n    @property\n    def degraded_mass(self):\n        \"\"\"Mass of plume contaminant degradation at the given time(s), compared to a no degradation model, in [g].\"\"\"\n        return self._degraded_mass_t\n\n    @property\n    def model_without_degradation(self):\n        \"\"\"Model with no degradation used to compare with given model.\"\"\"\n        return self._model_without_degradation\n\n    @property\n    def instant_reaction_degraded_mass(self):\n        \"\"\"Difference in plume mass instant reaction with and without biodegradation capacity subtracted, in [g].\n\n        For the instant reaction model, the underlying assumption reads that observed concentrations in the source zone\n        are post-degradation. Therefore, the source concentrations without any biodegradation would be higher, the\n        amount which is determined by the biodegradation capacity. Then, according to this method, the degraded mass\n        is the difference between plume mass before and after subtracting the biodegradation capacity.\n        \"\"\"\n        return self._instant_reaction_degraded_mass_t\n\n    @property\n    def electron_acceptor_change(self):\n        \"\"\"Change in electron acceptor/byproduct masses at the given time(s), in [g]. Only for instant reaction.\n\n        Electron acceptor/byproduct consumption or generation is based on the degraded plume mass (specifically\n        'instant_reaction_degraded_mass'), the utilization factor and relative abundance of the acceptors/byproducts.\n        Under the governing assumptions of the instant reaction model, a crude estimate of the total consumption of\n        electron acceptors and the generation of byproduct is calculated.\n        \"\"\"\n        return self._electron_acceptor_change_t\n\n    def source_threshold(self, threshold):\n        \"\"\"Calculate when source mass is below given threshold. No values are given for infinite source mass.\"\"\"\n        validate_input_values(\"threshold\", threshold)\n        if not self.source_mass_finite:\n            raise ValueError(\"Source mass is infinite and therefore cannot go below given threshold.\")\n        else:\n            time_to_threshold = (\n                -1 / self.results.k_source * np.log(threshold / self.results.source_parameters.total_mass)\n            )\n        return time_to_threshold\n\n    def _calculation_routine(self):\n        \"\"\"Perform mass_balance calculations.\"\"\"\n        self._check_model_extent()\n        self._plume_mass_t = self._calculate_plume_mass(self.results)\n        self._source_mass_t = self._calculate_source_mass()\n        self._delta_source_t = self._calculate_delta_source()\n        if self.model_degradation:\n            self._model_without_degradation = self._calculate_model_without_degradation()\n            self._degraded_mass_t = self._calculate_degraded_mass()\n        if self.model_instant_reaction:\n            self._instant_reaction_degraded_mass_t = self._calculate_instant_reaction_degraded_mass()\n            self._electron_acceptor_change_t = self._calculate_electron_acceptor_change()\n\n    def _check_model_extent(self):\n        \"\"\"Check if contaminant plume at given time is reasonably situated within the model extent.\"\"\"\n        # Relative concentration considered to be boundary of the plume extent.\n        extent_threshold_value = 0.01\n        if isinstance(self.t, np.ndarray):\n            cxyt_y_boundary = self.results.relative_cxyt[:, [0, -1], :]\n            cxyt_x_boundary = self.results.relative_cxyt[:, :, -1]\n        else:\n            cxyt_y_boundary = self.results.relative_cxyt[self._t_index, [0, -1], :]\n            cxyt_x_boundary = self.results.relative_cxyt[self._t_index, :, -1]\n\n        y_boundary_above_threshold = np.where(cxyt_y_boundary &gt; extent_threshold_value, cxyt_y_boundary, 0.0)\n        x_boundary_above_threshold = np.where(cxyt_x_boundary &gt; extent_threshold_value, cxyt_x_boundary, 0.0)\n        if np.sum(y_boundary_above_threshold) &gt; 0:\n            y_max = np.round(\n                np.max(y_boundary_above_threshold) * np.max(self.results.source_parameters.source_zone_concentration), 2\n            )\n            warnings.warn(\n                \"Contaminant plume extents beyond the model width, with a maximum concentration at the \"\n                f\"boundary of {y_max}g/m3. To ensure reliable mass balance, re-run the model with increased dimensions \"\n                \"to include the entire plume width in the model extent.\"\n            )\n        if np.sum(x_boundary_above_threshold) &gt; 0:\n            x_max = np.round(\n                np.max(x_boundary_above_threshold) * np.max(self.results.source_parameters.source_zone_concentration), 2\n            )\n            warnings.warn(\n                \"Contaminant plume extents beyond the model length, with a maximum concentration at the \"\n                f\"boundary of {x_max}g/m3. To ensure reliable mass balance, re-run the model with increased dimensions \"\n                \"to include the entire plume length in the model extent.\"\n            )\n\n    def _calculate_plume_mass(self, model):\n        \"\"\"Calculate plume mass of input model, for the given time(s).\"\"\"\n        # Plume mass of model; concentration is converted to mass by multiplying by cellsize and pore space.\n        if isinstance(self.t, np.ndarray):\n            plume_mass_t = np.sum(\n                model.cxyt[:, :, 1:] * self.cellsize * self.results.hydrological_parameters.porosity, axis=(1, 2)\n            )\n        else:\n            plume_mass_t = np.sum(\n                model.cxyt[self._t_index, :, 1:] * self.cellsize * self.results.hydrological_parameters.porosity\n            )\n\n        return plume_mass_t\n\n    def _calculate_source_mass(self):\n        \"\"\"Calculate source mass of input model, for the given time(s).\"\"\"\n        if self.source_mass_finite:\n            source_mass_t = self.results.source_parameters.total_mass * np.exp(-self.results.k_source * self.t)\n        else:\n            source_mass_t = np.inf\n\n        return source_mass_t\n\n    def _calculate_delta_source(self):\n        \"\"\"Calculate difference in source mass between t=0 and given time(s).\"\"\"\n        if self.source_mass_finite:\n            delta_source_t = self.results.source_parameters.total_mass - self._source_mass_t\n        else:\n            Q, c0_avg = calculate_discharge_and_average_source_zone_concentration(self.results)\n            delta_source_t = Q * c0_avg * self.t\n        return delta_source_t\n\n    def _calculate_model_without_degradation(self):\n        \"\"\"Make a no degradation model for comparison, pass the input parameters to a new class instance as kwargs.\"\"\"\n        model_without_degradation = self.results.model_type(**self.results.input_parameters)\n        model_without_degradation.attenuation_parameters.decay_rate = 0\n        model_without_degradation.run()\n        return model_without_degradation\n\n    def _calculate_degraded_mass(self):\n        \"\"\"Calculate difference between input model plume mass and no degradation model, for a given time(s).\"\"\"\n        no_degradation_plume_mass = self._calculate_plume_mass(self._model_without_degradation)\n        degraded_mass_t = no_degradation_plume_mass - self._plume_mass_t\n        return degraded_mass_t\n\n    def _calculate_instant_reaction_degraded_mass(self):\n        \"\"\"Calculate difference between input model plume mass and no degradation model for instant reaction model.\"\"\"\n        if isinstance(self.t, np.ndarray):\n            plume_mass_t_noBC = np.sum(\n                self.results.cxyt_noBC[:, :, 1:] * self.cellsize * self.results.hydrological_parameters.porosity,\n                axis=(1, 2),\n            )\n        else:\n            plume_mass_t_noBC = np.sum(\n                self.results.cxyt_noBC[self._t_index, :, 1:]\n                * self.cellsize\n                * self.results.hydrological_parameters.porosity\n            )\n\n        degraded_mass_instant_t = plume_mass_t_noBC - self._plume_mass_t\n        return degraded_mass_instant_t\n\n    def _calculate_electron_acceptor_change(self):\n        \"\"\"Calculate the change in electron acceptor mass for given time(s) for instant reaction model.\"\"\"\n        mass_fraction_degraded_acceptor = self.results.electron_acceptors.array / self.results.biodegradation_capacity\n        electron_acceptor_change = {}\n        electron_acceptors = [\"oxygen\", \"nitrate\", \"ferrous_iron\", \"sulfate\", \"methane\"]\n        for i, ea in enumerate(electron_acceptors):\n            electron_acceptor_change[ea] = self._instant_reaction_degraded_mass_t * mass_fraction_degraded_acceptor[i]\n\n        return electron_acceptor_change\n\n    def _time_check(self, time):\n        \"\"\"Check if time input is valid.\"\"\"\n        if time is None or time == \"all\":\n            t = self.results.t\n        elif isinstance(time, str):\n            warnings.warn(\"String not recognized, defaulting to 'all', for all time points.\")\n            t = self.results.t\n        else:\n            self._t_index = check_time_in_domain(self.results, time)\n            t = float(self.results.t[self._t_index])\n        return t\n</code></pre>"},{"location":"reference/reference_analysis/#mibitrans.analysis.mass_balance.MassBalance.degraded_mass","title":"<code>degraded_mass</code>  <code>property</code>","text":"<p>Mass of plume contaminant degradation at the given time(s), compared to a no degradation model, in [g].</p>"},{"location":"reference/reference_analysis/#mibitrans.analysis.mass_balance.MassBalance.delta_source","title":"<code>delta_source</code>  <code>property</code>","text":"<p>Difference in mass between contaminant source at given time and source at t = 0, in [g].</p>"},{"location":"reference/reference_analysis/#mibitrans.analysis.mass_balance.MassBalance.electron_acceptor_change","title":"<code>electron_acceptor_change</code>  <code>property</code>","text":"<p>Change in electron acceptor/byproduct masses at the given time(s), in [g]. Only for instant reaction.</p> <p>Electron acceptor/byproduct consumption or generation is based on the degraded plume mass (specifically \u2018instant_reaction_degraded_mass\u2019), the utilization factor and relative abundance of the acceptors/byproducts. Under the governing assumptions of the instant reaction model, a crude estimate of the total consumption of electron acceptors and the generation of byproduct is calculated.</p>"},{"location":"reference/reference_analysis/#mibitrans.analysis.mass_balance.MassBalance.instant_reaction_degraded_mass","title":"<code>instant_reaction_degraded_mass</code>  <code>property</code>","text":"<p>Difference in plume mass instant reaction with and without biodegradation capacity subtracted, in [g].</p> <p>For the instant reaction model, the underlying assumption reads that observed concentrations in the source zone are post-degradation. Therefore, the source concentrations without any biodegradation would be higher, the amount which is determined by the biodegradation capacity. Then, according to this method, the degraded mass is the difference between plume mass before and after subtracting the biodegradation capacity.</p>"},{"location":"reference/reference_analysis/#mibitrans.analysis.mass_balance.MassBalance.model_without_degradation","title":"<code>model_without_degradation</code>  <code>property</code>","text":"<p>Model with no degradation used to compare with given model.</p>"},{"location":"reference/reference_analysis/#mibitrans.analysis.mass_balance.MassBalance.plume_mass","title":"<code>plume_mass</code>  <code>property</code>","text":"<p>Mass of the contaminant plume in the model extent, at the given time(s), in [g].</p>"},{"location":"reference/reference_analysis/#mibitrans.analysis.mass_balance.MassBalance.source_mass","title":"<code>source_mass</code>  <code>property</code>","text":"<p>Mass of the contaminant source at the given time(s), in [g]. No values are given for infinite source mass.</p>"},{"location":"reference/reference_analysis/#mibitrans.analysis.mass_balance.MassBalance.__call__","title":"<code>__call__(time=None, method=None)</code>","text":"<p>Recalculate the mass balance characteristics of input model for given time and method.</p> Source code in <code>mibitrans/analysis/mass_balance.py</code> <pre><code>def __call__(self, time=None, method=None):\n    \"\"\"Recalculate the mass balance characteristics of input model for given time and method.\"\"\"\n    if time:\n        self.t = self._time_check(time)\n\n    if self.verbose:\n        print(\"Recalculating mass balance...\")\n\n    self._calculation_routine()\n</code></pre>"},{"location":"reference/reference_analysis/#mibitrans.analysis.mass_balance.MassBalance.__init__","title":"<code>__init__(results, time, verbose=False)</code>","text":"<p>Mass balance object with source and plume characteristics at given time(s), of input model.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <p>Input model for which mass balance is calculated, should be a child class of Transport3D.</p> required <code>time</code> <code>float | str</code> <p>Time at which to initially calculate the mass balance. Either as a value between 0 and model end time. Or as \u2018all\u2019, which will calculate mass balance attributes for each time step as arrays.</p> required <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> Call <p>Calling the MassBalance object will recalculate the mass balance characteristics of input model for given     input time.</p> Properties <p>plume_mass: Mass of the contaminant plume inside the model extent, at the given time(s), in [g]. source_mass: Mass of the contaminant source at the given time(s), in [g]. No values are given for models     with infinite source mass. delta_source: Difference in mass between contaminant source at given time and source at t = 0, in [g]. degraded_mass: Mass of plume contaminant degradation at the given time(s), compared to a model without     degradation, in [g]. Has no value if model does not consider degradation. model_without_degradation: Object of model without degradation. Has no value if model does not consider     degradation. instant_reaction_degraded_mass(self): Difference in plume mass instant reaction with and without     biodegradation capacity subtracted, in [g]. electron_acceptor_change(self): Change in electron acceptor/byproduct masses at the given time(s), in [g].     Only for instant reaction.</p> Source code in <code>mibitrans/analysis/mass_balance.py</code> <pre><code>def __init__(self, results, time, verbose=False):\n    \"\"\"Mass balance object with source and plume characteristics at given time(s), of input model.\n\n    Args:\n        results: Input model for which mass balance is calculated, should be a child class of Transport3D.\n        time (float | str): Time at which to initially calculate the mass balance. Either as a value between 0 and\n            model end time. Or as 'all', which will calculate mass balance attributes for each time step as arrays.\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Call:\n        Calling the MassBalance object will recalculate the mass balance characteristics of input model for given\n            input time.\n\n    Properties:\n        plume_mass: Mass of the contaminant plume inside the model extent, at the given time(s), in [g].\n        source_mass: Mass of the contaminant source at the given time(s), in [g]. No values are given for models\n            with infinite source mass.\n        delta_source: Difference in mass between contaminant source at given time and source at t = 0, in [g].\n        degraded_mass: Mass of plume contaminant degradation at the given time(s), compared to a model without\n            degradation, in [g]. Has no value if model does not consider degradation.\n        model_without_degradation: Object of model without degradation. Has no value if model does not consider\n            degradation.\n        instant_reaction_degraded_mass(self): Difference in plume mass instant reaction with and without\n            biodegradation capacity subtracted, in [g].\n        electron_acceptor_change(self): Change in electron acceptor/byproduct masses at the given time(s), in [g].\n            Only for instant reaction.\n    \"\"\"\n    check_model_type(results, mibitrans.transport.model_parent.Results)\n    self.results = results\n    self.verbose = verbose\n    self.t = self._time_check(time)\n\n    self._plume_mass_t = None\n    self._source_mass_t = None\n    self._delta_source_t = None\n    self._degraded_mass_t = None\n    self._electron_acceptor_change_t = None\n    self._instant_reaction_degraded_mass_t = None\n    self._model_without_degradation = None\n\n    # Volume of single cell, as dx * dy * source thickness\n    self.cellsize = (\n        abs(results.x[0] - results.x[1]) * abs(results.y[0] - results.y[1]) * results.source_parameters.depth\n    )\n\n    # Mass balance output differs if the source is represented as an infinite mass.\n    if self.results.source_parameters.total_mass == np.inf:\n        self.source_mass_finite = False\n    else:\n        self.source_mass_finite = True\n\n    match self.results.mode:\n        # Instant reaction model\n        case \"instant_reaction\":\n            self.model_instant_reaction = True\n            self.model_degradation = True\n        # Linear decay model\n        case \"linear\" if self.results.attenuation_parameters.decay_rate &gt; 0:\n            self.model_degradation = True\n            self.model_instant_reaction = False\n        # No decay model\n        case _:\n            self.model_degradation = False\n            self.model_instant_reaction = False\n\n    if self.verbose:\n        print(\"Calculating mass balance...\")\n\n    self._calculation_routine()\n</code></pre>"},{"location":"reference/reference_analysis/#mibitrans.analysis.mass_balance.MassBalance.source_threshold","title":"<code>source_threshold(threshold)</code>","text":"<p>Calculate when source mass is below given threshold. No values are given for infinite source mass.</p> Source code in <code>mibitrans/analysis/mass_balance.py</code> <pre><code>def source_threshold(self, threshold):\n    \"\"\"Calculate when source mass is below given threshold. No values are given for infinite source mass.\"\"\"\n    validate_input_values(\"threshold\", threshold)\n    if not self.source_mass_finite:\n        raise ValueError(\"Source mass is infinite and therefore cannot go below given threshold.\")\n    else:\n        time_to_threshold = (\n            -1 / self.results.k_source * np.log(threshold / self.results.source_parameters.total_mass)\n        )\n    return time_to_threshold\n</code></pre>"},{"location":"reference/reference_analysis/#mibitrans.analysis.parameter_calculations","title":"<code>parameter_calculations</code>","text":"<p>Author: Jorrit Bakker.</p> <p>Module containing various methods that takes a dictionary of parameters as input and calculates the proper values that can be used in transport equations.</p>"},{"location":"reference/reference_analysis/#mibitrans.analysis.parameter_calculations.calculate_discharge_and_average_source_zone_concentration","title":"<code>calculate_discharge_and_average_source_zone_concentration(model)</code>","text":"<p>Calculate discharge through source zone and average source zone concentration, returned in respective order.</p> Source code in <code>mibitrans/analysis/parameter_calculations.py</code> <pre><code>def calculate_discharge_and_average_source_zone_concentration(model):\n    \"\"\"Calculate discharge through source zone and average source zone concentration, returned in respective order.\"\"\"\n    if model.mode == \"instant_reaction\":\n        bc = model.biodegradation_capacity\n    else:\n        bc = 0\n    y_src = np.zeros(len(model.source_parameters.source_zone_boundary) + 1)\n    y_src[1:] = model.source_parameters.source_zone_boundary\n    c_src = model.source_parameters.source_zone_concentration\n    Q = (\n        model.hydrological_parameters.velocity\n        * model.hydrological_parameters.porosity\n        * model.source_parameters.depth\n        * np.max(y_src)\n        * 2\n    )\n\n    weighted_conc = np.zeros(len(model.source_parameters.source_zone_boundary))\n    for i in range(len(model.source_parameters.source_zone_boundary)):\n        weighted_conc[i] = (y_src[i + 1] - y_src[i]) * c_src[i]\n\n    c0_avg = bc + np.sum(weighted_conc) / np.max(y_src)\n\n    return Q, c0_avg\n</code></pre>"},{"location":"reference/reference_analysis/#mibitrans.analysis.parameter_calculations.calculate_utilization","title":"<code>calculate_utilization(model)</code>","text":"<p>Function that calculates relative use of electron acceptors in biodegradation of BTEX.</p> Source code in <code>mibitrans/analysis/parameter_calculations.py</code> <pre><code>def calculate_utilization(model):\n    \"\"\"Function that calculates relative use of electron acceptors in biodegradation of BTEX.\"\"\"\n    util_factor = model._utilization_factor.dictionary\n    biodeg_array = np.zeros(len(list(util_factor.keys())))\n    util_array = np.zeros(len(biodeg_array))\n\n    for i, (key, value) in enumerate(util_factor.items()):\n        biodeg_array[i] = getattr(model._electron_acceptors, util_to_conc_name[key]) / value\n        util_array[i] = value\n\n    biodegradation_capacity = np.sum(biodeg_array)\n    fraction_total = biodeg_array / biodegradation_capacity\n    mass_fraction = fraction_total * util_array\n\n    return mass_fraction\n</code></pre>"},{"location":"reference/reference_data/","title":"<code>mibitrans.data</code> API reference","text":""},{"location":"reference/reference_data/#mibitrans.data.check_input","title":"<code>check_input</code>","text":"<p>Author: Jorrit Bakker.</p> <p>Module evaluating if a dictionary contains all required (correct) parameters for analysis</p>"},{"location":"reference/reference_data/#mibitrans.data.check_input.DomainValueError","title":"<code>DomainValueError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised for values that are outside their possible domain.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>class DomainValueError(Exception):\n    \"\"\"Exception raised for values that are outside their possible domain.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message):\n        \"\"\"Initialize error class.\"\"\"\n        self.message = message\n        super().__init__(self.message)\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.check_input.DomainValueError.__init__","title":"<code>__init__(message)</code>","text":"<p>Initialize error class.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>def __init__(self, message):\n    \"\"\"Initialize error class.\"\"\"\n    self.message = message\n    super().__init__(self.message)\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.check_input.MissingValueError","title":"<code>MissingValueError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when one or more required parameters are missing.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>class MissingValueError(Exception):\n    \"\"\"Exception raised when one or more required parameters are missing.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message):\n        \"\"\"Initialize error class.\"\"\"\n        self.message = message\n        super().__init__(self.message)\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.check_input.MissingValueError.__init__","title":"<code>__init__(message)</code>","text":"<p>Initialize error class.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>def __init__(self, message):\n    \"\"\"Initialize error class.\"\"\"\n    self.message = message\n    super().__init__(self.message)\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.check_input.check_dictionary","title":"<code>check_dictionary(value)</code>","text":"<p>Check if variable is a dictionary, and raise an error if it is not.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>def check_dictionary(value):\n    \"\"\"Check if variable is a dictionary, and raise an error if it is not.\"\"\"\n    if not isinstance(value, dict):\n        raise TypeError(f\"Input must be a dict, but is {type(value)} instead.\")\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.check_input.check_model_type","title":"<code>check_model_type(parameter, allowed_model_types)</code>","text":"<p>Check if variable is of the given allowed model types, and raise an error if it is not.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>def check_model_type(parameter, allowed_model_types):\n    \"\"\"Check if variable is of the given allowed model types, and raise an error if it is not.\"\"\"\n    if not isinstance(parameter, allowed_model_types):\n        if isinstance(allowed_model_types, tuple):\n            raise TypeError(\n                f\"Input argument model should be subclass of {allowed_model_types}, but is {type(parameter)} instead.\"\n            )\n        else:\n            raise TypeError(\n                f\"Input argument model should be in {allowed_model_types.__subclasses__()}, \"\n                f\"but is {type(parameter)} instead.\"\n            )\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.check_input.check_time_in_domain","title":"<code>check_time_in_domain(model, time)</code>","text":"<p>Check if time input is valid, and returns the index of nearest time.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>def check_time_in_domain(model, time):\n    \"\"\"Check if time input is valid, and returns the index of nearest time.\"\"\"\n    if time is not None:\n        error = _check_numeric_positive(\"time\", time)\n        if error is not None:\n            raise error\n        elif time &gt; np.max(model.t):\n            warnings.warn(\n                f\"Desired time is larger than maximum time of model ({time} &gt; {np.max(model.t)}). Using maximum time \"\n                f\"of model instead.\"\n            )\n            time_pos = len(model.t) - 1\n        else:\n            time_pos = np.argmin(abs(model.t - time))\n    else:\n        time_pos = len(model.t) - 1\n    return time_pos\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.check_input.check_x_in_domain","title":"<code>check_x_in_domain(model, x_position)</code>","text":"<p>Check if x-position input is valid, and returns the index of nearest x position.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>def check_x_in_domain(model, x_position):\n    \"\"\"Check if x-position input is valid, and returns the index of nearest x position.\"\"\"\n    error = _check_numeric_positive(\"x_position\", x_position)\n    if error is not None:\n        raise error\n    if x_position &gt; np.max(model.x):\n        warnings.warn(\n            f\"Desired x position is outside of model domain ({x_position} &gt; {np.max(model.x)}). \"\n            f\"Using closest position inside model domain instead.\"\n        )\n\n    x_pos = np.argmin(abs(model.x - x_position))\n    return x_pos\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.check_input.check_y_in_domain","title":"<code>check_y_in_domain(model, y_position)</code>","text":"<p>Check if y-position input is valid, and returns the index of nearest y position.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>def check_y_in_domain(model, y_position):\n    \"\"\"Check if y-position input is valid, and returns the index of nearest y position.\"\"\"\n    error = _check_numeric(\"y_position\", y_position)\n    if error is not None:\n        raise error\n    if y_position &gt; np.max(model.y):\n        warnings.warn(\n            f\"Desired y position is outside of model domain (abs({y_position}) &gt; {np.max(model.y)}). \"\n            f\"Using closest position inside model domain instead.\"\n        )\n\n    y_pos = np.argmin(abs(model.y - y_position))\n    return y_pos\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.check_input.validate_input_values","title":"<code>validate_input_values(parameter, value)</code>","text":"<p>Validate if input parameter is of correct type and in correct domain.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>def validate_input_values(parameter, value):\n    \"\"\"Validate if input parameter is of correct type and in correct domain.\"\"\"\n    match parameter:\n        # Any input for verbose argument is fine; if set to anything other than False, 0 or None, verbose is on\n        case \"verbose\":\n            error = None\n        case \"_on_change\":\n            error = None\n        # Specific check for retardation, which has domain &gt;= 1\n        case \"retardation\":\n            error = _check_numeric_retardation(parameter, value)\n        # Specific check for total mass, which can be a positive float, or a specific string\n        case \"total_mass\":\n            error = _check_total_mass(parameter, value)\n        # Specific check for electron acceptor utilization factor, which should be UtilizationFactor dataclass\n        case \"utilization_factor\":\n            error = _check_dataclass(parameter, value, mibitrans.data.parameter_information.UtilizationFactor)\n        # Parameters which can be any float value\n        case \"y_position\":\n            error = _check_numeric(parameter, value)\n        # Parameters which have domain [0,1]\n        case \"porosity\" | \"fraction_organic_carbon\":\n            error = _check_numeric_fraction(parameter, value)\n        # Parameters which are input as single values, lists or numpy arrays\n        case \"source_zone_boundary\" | \"source_zone_concentration\":\n            error = _check_array_list_numeric_positive(parameter, value)\n        case \"electron_acceptors\":\n            error = _check_electron_acceptor(value)\n        # All other parameters are checked as floats on positive domain\n        case _:\n            error = _check_numeric_positive(parameter, value)\n\n    if error and (value is not None):\n        raise error\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.check_input.validate_source_zones","title":"<code>validate_source_zones(boundary, concentration)</code>","text":"<p>Validate and adapt input of source_zone_boundary and source_zone_concentration arrays.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>def validate_source_zones(boundary, concentration):\n    \"\"\"Validate and adapt input of source_zone_boundary and source_zone_concentration arrays.\"\"\"\n    # Ensure boundary and concentration are numpy arrays\n    if isinstance(boundary, (float, int, np.floating, np.integer)):\n        boundary = np.array([boundary])\n    else:\n        boundary = np.array(boundary)\n\n    if isinstance(concentration, (float, int, np.floating, np.integer)):\n        concentration = np.array([concentration], dtype=float)\n    else:\n        concentration = np.array(concentration, dtype=float)\n\n    # Each given source zone boundary should have a given concentration, and vice versa\n    if boundary.shape != concentration.shape:\n        raise ValueError(\n            f\"Length of source zone boundary ({len(boundary)}) and source zone concentration \"\n            f\"({len(concentration)}) do not match. Make sure they are of equal length.\"\n        )\n\n    # Reorder source zone locations if they are not given in order from close to far from source zone center\n    if len(boundary) &gt; 1:\n        if not all(boundary[:-1] &lt;= boundary[1:]):\n            sort_location = np.argsort(boundary)\n            boundary.sort()\n            concentration = concentration[sort_location]\n            warnings.warn(\n                \"Source zone boundary locations should be ordered by distance from source zone center. \"\n                \"Zone boundaries and concentrations have consequently been reordered as follows:\"\n                f\"Source zone boundaries: {boundary}\"\n                f\"Source zone concentrations: {concentration}\"\n            )\n        # Superposition method only works if the zone closer to the center has higher concentration than outer zones\n        if not all(concentration[:-1] &gt; concentration[1:]):\n            raise ValueError(\n                \"Source zone concentrations should be in descending order; no source zone can have a concentration \"\n                \"higher than the concentration of a zone closer to source center, due to the superposition method.\"\n            )\n    return boundary, concentration\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameter_information","title":"<code>parameter_information</code>","text":"<p>Author: Jorrit Bakker.</p> <p>File containing various dictionaries used for evaluation of names, value types and units of input data.</p>"},{"location":"reference/reference_data/#mibitrans.data.parameter_information.ElectronAcceptors","title":"<code>ElectronAcceptors</code>  <code>dataclass</code>","text":"<p>Make object with concentrations of electron acceptors.</p> <p>Dataclass which handles the entry of electron acceptor concentrations used for the instant reaction biodegradation method. As plume concentrations for reduced electron acceptor species and as difference between plume and background concentrations for the electron acceptors themselves.</p> <p>delta_oxygen (float) : Difference between background oxygen and plume oxygen concentrations, in [g/m^3].     Only required for instant reaction models. delta_nitrate (float) : Difference between background nitrate and contaminant plume nitrate concentrations,     in [g/m^3]. Only required for instant reaction models. ferrous_iron (float) : Ferrous iron concentration in contaminant plume, in [g/m^3]. Only required for     instant reaction models. delta_sulfate (float) : Difference between background sulfate and plume sulfate concentrations, in [g/m^3].     Only required for instant reaction models. methane (float) : Methane concentration in contaminant plume, in [g/m^3]. Only required for     instant reaction models.</p> Source code in <code>mibitrans/data/parameter_information.py</code> <pre><code>@dataclass\nclass ElectronAcceptors:\n    \"\"\"Make object with concentrations of electron acceptors.\n\n    Dataclass which handles the entry of electron acceptor concentrations used for the instant reaction biodegradation\n    method. As plume concentrations for reduced electron acceptor species and as difference between plume and background\n    concentrations for the electron acceptors themselves.\n\n    delta_oxygen (float) : Difference between background oxygen and plume oxygen concentrations, in [g/m^3].\n        Only required for instant reaction models.\n    delta_nitrate (float) : Difference between background nitrate and contaminant plume nitrate concentrations,\n        in [g/m^3]. Only required for instant reaction models.\n    ferrous_iron (float) : Ferrous iron concentration in contaminant plume, in [g/m^3]. Only required for\n        instant reaction models.\n    delta_sulfate (float) : Difference between background sulfate and plume sulfate concentrations, in [g/m^3].\n        Only required for instant reaction models.\n    methane (float) : Methane concentration in contaminant plume, in [g/m^3]. Only required for\n        instant reaction models.\n    \"\"\"\n\n    delta_oxygen: float\n    delta_nitrate: float\n    ferrous_iron: float\n    delta_sulfate: float\n    methane: float\n\n    def __setattr__(self, parameter, value):\n        \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n        validate_input_values(parameter, value)\n        super().__setattr__(parameter, value)\n\n    @property\n    def dictionary(self):\n        \"\"\"Returns electron acceptors in the form of a dictionary.\"\"\"\n        return dict(\n            delta_oxygen=self.delta_oxygen,\n            delta_nitrate=self.delta_nitrate,\n            ferrous_iron=self.ferrous_iron,\n            delta_sulfate=self.delta_sulfate,\n            methane=self.methane,\n        )\n\n    @property\n    def array(self):\n        \"\"\"Return electron acceptor concentrations in the form of an array, in order of [O2, NO3, Fe, SO4, CH4].\"\"\"\n        return np.array([self.delta_oxygen, self.delta_nitrate, self.ferrous_iron, self.delta_sulfate, self.methane])\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameter_information.ElectronAcceptors.array","title":"<code>array</code>  <code>property</code>","text":"<p>Return electron acceptor concentrations in the form of an array, in order of [O2, NO3, Fe, SO4, CH4].</p>"},{"location":"reference/reference_data/#mibitrans.data.parameter_information.ElectronAcceptors.dictionary","title":"<code>dictionary</code>  <code>property</code>","text":"<p>Returns electron acceptors in the form of a dictionary.</p>"},{"location":"reference/reference_data/#mibitrans.data.parameter_information.ElectronAcceptors.__setattr__","title":"<code>__setattr__(parameter, value)</code>","text":"<p>Override parent method to validate input when attribute is set.</p> Source code in <code>mibitrans/data/parameter_information.py</code> <pre><code>def __setattr__(self, parameter, value):\n    \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n    validate_input_values(parameter, value)\n    super().__setattr__(parameter, value)\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameter_information.UtilizationFactor","title":"<code>UtilizationFactor</code>  <code>dataclass</code>","text":"<p>Make object containing information about electron acceptor utilization factor.</p> <p>Parameters:</p> Name Type Description Default <code>util_oxygen (float) </code> <p>utilization factor of oxygen, as mass of oxygen consumed per mass of biodegraded contaminant [g/g].</p> required <code>util_nitrate (float) </code> <p>utilization factor of nitrate, as mass of nitrate consumed per mass of biodegraded contaminant [g/g].</p> required <code>util_ferrous_iron (float) </code> <p>utilization factor of ferrous iron, as mass of ferrous iron generated per mass of biodegraded contaminant [g/g].</p> required <code>util_sulfate (float) </code> <p>utilization factor of sulfate, as mass of sulfate consumed per mass of biodegraded contaminant [g/g].</p> required <code>util_methane (float) </code> <p>utilization factor of methane, as mass of methane generated per mass of biodegraded contaminant [g/g].</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If input parameters are incomplete or outside the valid domain.</p> <code>TypeError</code> <p>If input parameters of incorrect datatype.</p> Source code in <code>mibitrans/data/parameter_information.py</code> <pre><code>@dataclass\nclass UtilizationFactor:\n    \"\"\"Make object containing information about electron acceptor utilization factor.\n\n    Args:\n        util_oxygen (float) : utilization factor of oxygen, as mass of oxygen consumed\n            per mass of biodegraded contaminant [g/g].\n        util_nitrate (float) : utilization factor of nitrate, as mass of nitrate consumed\n            per mass of biodegraded contaminant [g/g].\n        util_ferrous_iron (float) : utilization factor of ferrous iron, as mass of ferrous iron generated\n            per mass of biodegraded contaminant [g/g].\n        util_sulfate (float) : utilization factor of sulfate, as mass of sulfate consumed\n            per mass of biodegraded contaminant [g/g].\n        util_methane (float) : utilization factor of methane, as mass of methane generated\n            per mass of biodegraded contaminant [g/g].\n\n    Raises:\n        ValueError : If input parameters are incomplete or outside the valid domain.\n        TypeError : If input parameters of incorrect datatype.\n\n    \"\"\"\n\n    util_oxygen: float\n    util_nitrate: float\n    util_ferrous_iron: float\n    util_sulfate: float\n    util_methane: float\n\n    def __setattr__(self, parameter, value):\n        \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n        if parameter != \"dictionary\":\n            validate_input_values(parameter, value)\n        super().__setattr__(parameter, value)\n\n    @property\n    def dictionary(self):\n        \"\"\"Returns utilization factors in the form of a dictionary.\"\"\"\n        return dict(\n            util_oxygen=self.util_oxygen,\n            util_nitrate=self.util_nitrate,\n            util_ferrous_iron=self.util_ferrous_iron,\n            util_sulfate=self.util_sulfate,\n            util_methane=self.util_methane,\n        )\n\n    @property\n    def array(self):\n        \"\"\"Return utilization factors in the form of an array, in order of [O2, NO3, Fe, SO4, CH4].\"\"\"\n        return np.array(\n            [self.util_oxygen, self.util_nitrate, self.util_ferrous_iron, self.util_sulfate, self.util_methane]\n        )\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameter_information.UtilizationFactor.array","title":"<code>array</code>  <code>property</code>","text":"<p>Return utilization factors in the form of an array, in order of [O2, NO3, Fe, SO4, CH4].</p>"},{"location":"reference/reference_data/#mibitrans.data.parameter_information.UtilizationFactor.dictionary","title":"<code>dictionary</code>  <code>property</code>","text":"<p>Returns utilization factors in the form of a dictionary.</p>"},{"location":"reference/reference_data/#mibitrans.data.parameter_information.UtilizationFactor.__setattr__","title":"<code>__setattr__(parameter, value)</code>","text":"<p>Override parent method to validate input when attribute is set.</p> Source code in <code>mibitrans/data/parameter_information.py</code> <pre><code>def __setattr__(self, parameter, value):\n    \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n    if parameter != \"dictionary\":\n        validate_input_values(parameter, value)\n    super().__setattr__(parameter, value)\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters","title":"<code>parameters</code>","text":"<p>Author: Jorrit Bakker.</p> <p>Module handling data input in the form of a dictionary.</p>"},{"location":"reference/reference_data/#mibitrans.data.parameters.AttenuationParameters","title":"<code>AttenuationParameters</code>  <code>dataclass</code>","text":"<p>Dataclass handling parameters related to adsorption, diffusion and degradation.</p> <p>Parameters:</p> Name Type Description Default <code>retardation (float) </code> <p>Retardation factor for transported contaminant [-]. Default is 1.</p> required <code>decay_rate (float) </code> <p>First order (linear) decay coefficient in [1/day]. Only required for linear decay models. Default is 0. Also sets corresponding half life.</p> required <code>half_life (float) </code> <p>Contaminant half life for 1st order (linear) decay, in [days]. Only required for linear decay models. Default is 0. Also sets corresponding decay_rate.</p> required <code>diffusion (float) </code> <p>Molecular diffusion [m2/day]. Default is 0.</p> required <code>bulk_density (float) </code> <p>Soil bulk density, in [g/m^3]. Optional if retardation is specified.</p> required <code>partition_coefficient (float) </code> <p>Partition coefficient of the transported contaminant to soil organic matter, in [m^3/g]. Optional if retardation is specified.</p> required <code>fraction_organic_carbon (float) </code> <p>Fraction of organic material in the soil [-]. Optional if retardation is specified.</p> required <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> <p>Methods:</p> Name Description <code>calculate_retardation </code> <p>Calculate retardation factor from bulk density, partition coefficient and fraction organic carbon when given porosity [-]</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input parameters are incomplete or outside the valid domain.</p> <code>TypeError</code> <p>If input parameters of incorrect datatype.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>@dataclass\nclass AttenuationParameters:\n    \"\"\"Dataclass handling parameters related to adsorption, diffusion and degradation.\n\n    Args:\n        retardation (float) : Retardation factor for transported contaminant [-]. Default is 1.\n        decay_rate (float) : First order (linear) decay coefficient in [1/day]. Only required for linear decay models.\n            Default is 0. Also sets corresponding half life.\n        half_life (float) : Contaminant half life for 1st order (linear) decay, in [days]. Only required for\n            linear decay models. Default is 0. Also sets corresponding decay_rate.\n        diffusion (float) : Molecular diffusion [m2/day]. Default is 0.\n        bulk_density (float) : Soil bulk density, in [g/m^3]. Optional if retardation is specified.\n        partition_coefficient (float) : Partition coefficient of the transported contaminant to soil organic matter,\n            in [m^3/g]. Optional if retardation is specified.\n        fraction_organic_carbon (float) : Fraction of organic material in the soil [-].\n            Optional if retardation is specified.\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Methods:\n        calculate_retardation : Calculate retardation factor from bulk density, partition coefficient and\n            fraction organic carbon when given porosity [-]\n\n    Raises:\n        ValueError : If input parameters are incomplete or outside the valid domain.\n        TypeError : If input parameters of incorrect datatype.\n    \"\"\"\n\n    retardation: float = 1\n    decay_rate: float = 0\n    half_life: float = 0\n    diffusion: float = 0\n    bulk_density: float = None\n    partition_coefficient: float = None\n    fraction_organic_carbon: float = None\n    verbose: bool = False\n\n    def __setattr__(self, parameter, value):\n        \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n        validate_input_values(parameter, value)\n        # Separate setattr for decay rate and half life because they should always be equivalent\n        if parameter == \"decay_rate\" or parameter == \"half_life\":\n            decay_rate, half_life = self._set_decay(parameter, value)\n            super().__setattr__(\"decay_rate\", decay_rate)\n            super().__setattr__(\"half_life\", half_life)\n        else:\n            super().__setattr__(parameter, value)\n\n    def __post_init__(self):\n        \"\"\"Check argument presence, types and domain.\"\"\"\n        self.initialized = True\n\n    def calculate_retardation(self, porosity: float):\n        \"\"\"Calculate retardation factor from soil adsorption parametrers and porosity.\"\"\"\n        self.retardation = (\n            1 + (self.bulk_density / porosity) * self.partition_coefficient * self.fraction_organic_carbon\n        )\n        if self.verbose:\n            print(f\"Retardation factor has been calculated to be {self.retardation}.\")\n\n    def _require_linear_decay(self):\n        if self.decay_rate is None and self.half_life is None:\n            raise MissingValueError(\"Linear reaction model requires decay rate or half life.\")\n\n    def _set_decay(self, parameter, value):\n        if parameter == \"decay_rate\" and (value != 0 or hasattr(self, \"initialized\")):\n            decay_rate = value\n            if value != 0:\n                half_life = np.log(2) / value\n            else:\n                half_life = 0\n        elif parameter == \"half_life\" and (value != 0 or hasattr(self, \"initialized\")):\n            half_life = value\n            if value != 0:\n                decay_rate = np.log(2) / value\n            else:\n                decay_rate = 0\n        elif parameter == \"decay_rate\":\n            decay_rate = value\n            half_life = 0\n        elif parameter == \"half_life\":\n            decay_rate = self.decay_rate\n            half_life = self.half_life\n        else:\n            decay_rate = 0\n            half_life = 0\n\n        if self.decay_rate != decay_rate and self.decay_rate != 0 and not hasattr(self, \"initialized\") and value != 0:\n            warnings.warn(\n                \"Both contaminant decay rate and half life were defined, but are not equal. \"\n                \"Value for decay rate will be used.\",\n                UserWarning,\n            )\n            half_life = np.log(2) / self.decay_rate\n            decay_rate = self.decay_rate\n\n        return decay_rate, half_life\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.AttenuationParameters.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Check argument presence, types and domain.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Check argument presence, types and domain.\"\"\"\n    self.initialized = True\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.AttenuationParameters.__setattr__","title":"<code>__setattr__(parameter, value)</code>","text":"<p>Override parent method to validate input when attribute is set.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>def __setattr__(self, parameter, value):\n    \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n    validate_input_values(parameter, value)\n    # Separate setattr for decay rate and half life because they should always be equivalent\n    if parameter == \"decay_rate\" or parameter == \"half_life\":\n        decay_rate, half_life = self._set_decay(parameter, value)\n        super().__setattr__(\"decay_rate\", decay_rate)\n        super().__setattr__(\"half_life\", half_life)\n    else:\n        super().__setattr__(parameter, value)\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.AttenuationParameters.calculate_retardation","title":"<code>calculate_retardation(porosity)</code>","text":"<p>Calculate retardation factor from soil adsorption parametrers and porosity.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>def calculate_retardation(self, porosity: float):\n    \"\"\"Calculate retardation factor from soil adsorption parametrers and porosity.\"\"\"\n    self.retardation = (\n        1 + (self.bulk_density / porosity) * self.partition_coefficient * self.fraction_organic_carbon\n    )\n    if self.verbose:\n        print(f\"Retardation factor has been calculated to be {self.retardation}.\")\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.HydrologicalParameters","title":"<code>HydrologicalParameters</code>  <code>dataclass</code>","text":"<p>Dataclass handling input of hydrological parameters.</p> <p>Parameters:</p> Name Type Description Default <code>velocity (float) </code> <p>Flow velocity in the direction of the groundwater gradient, in [m/d]. Optional if h_gradient and h_conductivity are specified.</p> required <code>h_gradient (float) </code> <p>Hydraulic gradient of the groundwater, in [m/m]. Optional if velocity is specified.</p> required <code>h_conductivity (float) </code> <p>Hydraulic conductivity of the aquifer, in [m/d]. Optional if velocity is specified.</p> required <code>porosity (float) </code> <p>Effective soil porosity [-]</p> required <code>alpha_x (float) </code> <p>The dispersivity in the x (longitudinal) direction in [m]</p> required <code>alpha_y (float) </code> <p>The dispersivity in the y (transverse-horizontal) direction in [m]</p> required <code>alpha_z (float, optional) </code> <p>The dispersivity in the z (transverse-vertical) direction in [m]. Defaults to 1e-10</p> required <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input parameters are incomplete or outside the valid domain.</p> <code>TypeError</code> <p>If input parameters of incorrect datatype.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>@dataclass\nclass HydrologicalParameters:\n    \"\"\"Dataclass handling input of hydrological parameters.\n\n    Args:\n        velocity (float) : Flow velocity in the direction of the groundwater gradient, in [m/d]. Optional if h_gradient\n            and h_conductivity are specified.\n        h_gradient (float) : Hydraulic gradient of the groundwater, in [m/m]. Optional if velocity is specified.\n        h_conductivity (float) : Hydraulic conductivity of the aquifer, in [m/d]. Optional if velocity is specified.\n        porosity (float) : Effective soil porosity [-]\n        alpha_x (float) : The dispersivity in the x (longitudinal) direction in [m]\n        alpha_y (float) : The dispersivity in the y (transverse-horizontal) direction in [m]\n        alpha_z (float, optional) : The dispersivity in the z (transverse-vertical) direction in [m]. Defaults to 1e-10\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Raises:\n        ValueError : If input parameters are incomplete or outside the valid domain.\n        TypeError : If input parameters of incorrect datatype.\n    \"\"\"\n\n    velocity: float = None\n    h_gradient: float = None\n    h_conductivity: float = None\n    porosity: float = None\n    alpha_x: float = None\n    alpha_y: float = None\n    alpha_z: float = 1e-10\n    verbose: bool = False\n\n    def __setattr__(self, parameter, value):\n        \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n        validate_input_values(parameter, value)\n        super().__setattr__(parameter, value)\n\n    def __post_init__(self):\n        \"\"\"Check argument presence, types and domain. Calculate velocity if not given.\"\"\"\n        self._validate_input_presence()\n\n        # Velocity is calculated from hydraulic gradient and conductivity when both are given.\n        if self.h_gradient and self.h_conductivity:\n            # Giving h_gradient &amp; h_conductivity more specific than giving velocity. Input velocity will be overridden.\n            if self.velocity is not None:\n                warnings.warn(\n                    \"Both velocity and h_gradient &amp; h_conductivity are defined. Value for velocity will be overridden.\",\n                    UserWarning,\n                )\n            self.velocity = self.h_gradient * self.h_conductivity / self.porosity\n            if self.verbose:\n                print(f\"Groundwater flow velocity has been calculated to be {self.velocity} m/d.\")\n\n    def _validate_input_presence(self):\n        missing_arguments = []\n        if self.porosity is None:\n            missing_arguments.append(\"porosity\")\n        if self.alpha_x is None:\n            missing_arguments.append(\"alpha_x\")\n        if self.alpha_y is None:\n            missing_arguments.append(\"alpha_y\")\n\n        if len(missing_arguments) &gt; 0:\n            raise MissingValueError(\n                f\"HydrologicalParameters missing {len(missing_arguments)} arguments: {missing_arguments}.\"\n            )\n\n        if self.velocity is None and (self.h_gradient is None or self.h_conductivity is None):\n            raise MissingValueError(\n                \"HydrologicalParameters missing required arguments: either velocity or both h_gradient and\"\n                \"h_conductivity.\"\n            )\n\n        if self.verbose:\n            print(\"All required hydrological input arguments are present.\")\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.HydrologicalParameters.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Check argument presence, types and domain. Calculate velocity if not given.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Check argument presence, types and domain. Calculate velocity if not given.\"\"\"\n    self._validate_input_presence()\n\n    # Velocity is calculated from hydraulic gradient and conductivity when both are given.\n    if self.h_gradient and self.h_conductivity:\n        # Giving h_gradient &amp; h_conductivity more specific than giving velocity. Input velocity will be overridden.\n        if self.velocity is not None:\n            warnings.warn(\n                \"Both velocity and h_gradient &amp; h_conductivity are defined. Value for velocity will be overridden.\",\n                UserWarning,\n            )\n        self.velocity = self.h_gradient * self.h_conductivity / self.porosity\n        if self.verbose:\n            print(f\"Groundwater flow velocity has been calculated to be {self.velocity} m/d.\")\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.HydrologicalParameters.__setattr__","title":"<code>__setattr__(parameter, value)</code>","text":"<p>Override parent method to validate input when attribute is set.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>def __setattr__(self, parameter, value):\n    \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n    validate_input_values(parameter, value)\n    super().__setattr__(parameter, value)\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.ModelParameters","title":"<code>ModelParameters</code>  <code>dataclass</code>","text":"<p>Dataclass handling model discretization parameters.</p> <p>Parameters:</p> Name Type Description Default <code>model_length (float) </code> <p>Model extent in the longitudinal (x) direction in [m].</p> required <code>model_width (float) </code> <p>Model extent in the transverse horizontal (y) direction in [m].</p> required <code>model_time (float) </code> <p>Model duration in [days].</p> required <code>dx (float, optional) </code> <p>Model grid discretization step size in the longitudinal (x) direction, in [m]. By default, dx = (model_length / 100).</p> required <code>dy (float, optional) </code> <p>Model grid discretization step size in the transverse horizontal (y) direction, in [m]. By default, dy = (model_width / 50).</p> required <code>dt (float, optional) </code> <p>Model time discretization step size, in [days]. By default, dt = (model_time / 10).</p> required <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input parameters are incomplete or outside the valid domain.</p> <code>ValueError</code> <p>If model dimensions are smaller than their given step size.</p> <code>TypeError</code> <p>If input parameters of incorrect datatype.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>@dataclass\nclass ModelParameters:\n    \"\"\"Dataclass handling model discretization parameters.\n\n    Args:\n        model_length (float) : Model extent in the longitudinal (x) direction in [m].\n        model_width (float) : Model extent in the transverse horizontal (y) direction in [m].\n        model_time (float) : Model duration in [days].\n        dx (float, optional) : Model grid discretization step size in the longitudinal (x) direction, in [m]. By\n            default, dx = (model_length / 100).\n        dy (float, optional) : Model grid discretization step size in the transverse horizontal (y) direction, in [m].\n            By default, dy = (model_width / 50).\n        dt (float, optional) : Model time discretization step size, in [days]. By default, dt = (model_time / 10).\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Raises:\n        ValueError : If input parameters are incomplete or outside the valid domain.\n        ValueError : If model dimensions are smaller than their given step size.\n        TypeError : If input parameters of incorrect datatype.\n\n    \"\"\"\n\n    model_length: float\n    model_width: float\n    model_time: float\n    dx: float = None\n    dy: float = None\n    dt: float = None\n    verbose: bool = False\n\n    def __setattr__(self, parameter, value):\n        \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n        validate_input_values(parameter, value)\n        super().__setattr__(parameter, value)\n        self._validate_stepsize(parameter)\n\n    def _validate_stepsize(self, parameter):\n        \"\"\"Validate if model step size is not larger than the corresponding model dimension.\"\"\"\n        match parameter:\n            case \"dx\" | \"model_length\":\n                if self.dx is not None and self.model_length is not None:\n                    if self.dx &gt; self.model_length:\n                        raise ValueError(\n                            f\"Model x-direction step size ({self.dx}) \"\n                            f\"is greater than the model length ({self.model_length}).\"\n                        )\n            case \"dy\" | \"model_width\":\n                if self.dy is not None and self.model_width is not None:\n                    if self.dy &gt; self.model_width:\n                        raise ValueError(\n                            f\"Model y-direction step size ({self.dy}) \"\n                            f\"is greater than the model width ({self.model_width}).\"\n                        )\n            case \"dt\" | \"model_time\":\n                if self.dt is not None and self.model_time is not None:\n                    if self.dt &gt; self.model_time:\n                        raise ValueError(\n                            f\"Model time step size ({self.dt}) \"\n                            f\"is greater than the total model time ({self.model_time}).\"\n                        )\n\n    def __post_init__(self):\n        \"\"\"Set model discretization parameters if not provided.\"\"\"\n        if not self.dx:\n            self.dx = self.model_length / 100\n        if not self.dy:\n            self.dy = self.model_width / 50\n        if not self.dt:\n            self.dt = self.model_time / 10\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.ModelParameters.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Set model discretization parameters if not provided.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Set model discretization parameters if not provided.\"\"\"\n    if not self.dx:\n        self.dx = self.model_length / 100\n    if not self.dy:\n        self.dy = self.model_width / 50\n    if not self.dt:\n        self.dt = self.model_time / 10\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.ModelParameters.__setattr__","title":"<code>__setattr__(parameter, value)</code>","text":"<p>Override parent method to validate input when attribute is set.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>def __setattr__(self, parameter, value):\n    \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n    validate_input_values(parameter, value)\n    super().__setattr__(parameter, value)\n    self._validate_stepsize(parameter)\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.SourceParameters","title":"<code>SourceParameters</code>  <code>dataclass</code>","text":"<p>Dataclass handling source parameters. Specifying concentrations and extent of source zone.</p> <p>Parameters:</p> Name Type Description Default <code>source_zone_boundary (np.ndarray) </code> <p>Outer boundary of each source zone, in transverse horizontal direction (y-coordiante) [m]. y=0 is at the middle of the contaminant source. Input as numpy array of length equal to the amount of source zone. Last value in the array is the limit of the source. For a source with a single source zone, only one value is required. Source is symmetrical in the x-axis.</p> required <code>source_zone_concentration (np.ndarray) </code> <p>Contaminant concentration in each source zone [g/m^3]. Input as numpy array in the same order and of the same length as specified in source_zone_boundary.</p> required <code>depth (float) </code> <p>Depth (transverse vertical or z-dimension) of the source zone in [m].</p> required <code>total_mass (float | str) </code> <p>Mass of contaminant present in source zone, either expressed in [g], or set to \u2018infinite\u2019. The latter meaning that the source mass and therefore, the source zone concentrations do not diminish over time.</p> required <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input parameters are incomplete or outside the valid domain.</p> <code>TypeError</code> <p>If input parameters of incorrect datatype.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>@dataclass\nclass SourceParameters:\n    \"\"\"Dataclass handling source parameters. Specifying concentrations and extent of source zone.\n\n    Args:\n        source_zone_boundary (np.ndarray) : Outer boundary of each source zone, in transverse horizontal direction\n            (y-coordiante) [m]. y=0 is at the middle of the contaminant source. Input as numpy array of length equal\n            to the amount of source zone. Last value in the array is the limit of the source. For a source with a single\n            source zone, only one value is required. Source is symmetrical in the x-axis.\n        source_zone_concentration (np.ndarray) : Contaminant concentration in each source zone [g/m^3]. Input as numpy\n            array in the same order and of the same length as specified in source_zone_boundary.\n        depth (float) : Depth (transverse vertical or z-dimension) of the source zone in [m].\n        total_mass (float | str) : Mass of contaminant present in source zone, either expressed in [g],\n            or set to 'infinite'. The latter meaning that the source mass and therefore, the source zone concentrations\n            do not diminish over time.\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Raises:\n        ValueError : If input parameters are incomplete or outside the valid domain.\n        TypeError : If input parameters of incorrect datatype.\n    \"\"\"\n\n    source_zone_boundary: np.ndarray = None\n    source_zone_concentration: np.ndarray = None\n    depth: float = None\n    total_mass: float | str = \"infinite\"\n    verbose: bool = False\n\n    def __setattr__(self, parameter, value):\n        \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n        validate_input_values(parameter, value)\n        if parameter == \"total_mass\" and (isinstance(value, str) or value == np.inf):\n            value = np.inf\n        super().__setattr__(parameter, value)\n        # When setting source zone boundary or concentration, and both present, check validity in respect to each other.\n        if parameter in [\"source_zone_boundary\", \"source_zone_concentration\"] and (\n            self.source_zone_boundary is not None and self.source_zone_concentration is not None\n        ):\n            boundary, concentration = validate_source_zones(self.source_zone_boundary, self.source_zone_concentration)\n            super().__setattr__(\"source_zone_boundary\", boundary)\n            super().__setattr__(\"source_zone_concentration\", concentration)\n\n    def __post_init__(self):\n        \"\"\"Check argument presence, types and domain.\"\"\"\n        self._validate_input_presence()\n\n        # Make sure naming for infinite source mass is consistent from this point onward\n        if isinstance(self.total_mass, str):\n            self.total_mass = \"infinite\"\n\n    def interpolate(self, n_zones, method):\n        \"\"\"Rediscretize source to n zones. Either through linear interpolation or using a normal distribution.\"\"\"\n        warnings.warn(\"This functionality is not implemented yet. Try again later.\")\n        return None\n\n    def visualize(self):\n        \"\"\"Plot the source zone concentration distribution.\"\"\"\n        source_zone(self)\n\n    def _validate_input_presence(self):\n        # Check if all required arguments are present\n        missing_arguments = []\n        if self.source_zone_boundary is None:\n            missing_arguments.append(\"source_zone_boundary\")\n        if self.source_zone_concentration is None:\n            missing_arguments.append(\"source_zone_concentration\")\n        if self.depth is None:\n            missing_arguments.append(\"depth\")\n\n        if len(missing_arguments) &gt; 0:\n            raise MissingValueError(\n                f\"SourceParameters missing {len(missing_arguments)} arguments: {missing_arguments}.\"\n            )\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.SourceParameters.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Check argument presence, types and domain.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Check argument presence, types and domain.\"\"\"\n    self._validate_input_presence()\n\n    # Make sure naming for infinite source mass is consistent from this point onward\n    if isinstance(self.total_mass, str):\n        self.total_mass = \"infinite\"\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.SourceParameters.__setattr__","title":"<code>__setattr__(parameter, value)</code>","text":"<p>Override parent method to validate input when attribute is set.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>def __setattr__(self, parameter, value):\n    \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n    validate_input_values(parameter, value)\n    if parameter == \"total_mass\" and (isinstance(value, str) or value == np.inf):\n        value = np.inf\n    super().__setattr__(parameter, value)\n    # When setting source zone boundary or concentration, and both present, check validity in respect to each other.\n    if parameter in [\"source_zone_boundary\", \"source_zone_concentration\"] and (\n        self.source_zone_boundary is not None and self.source_zone_concentration is not None\n    ):\n        boundary, concentration = validate_source_zones(self.source_zone_boundary, self.source_zone_concentration)\n        super().__setattr__(\"source_zone_boundary\", boundary)\n        super().__setattr__(\"source_zone_concentration\", concentration)\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.SourceParameters.interpolate","title":"<code>interpolate(n_zones, method)</code>","text":"<p>Rediscretize source to n zones. Either through linear interpolation or using a normal distribution.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>def interpolate(self, n_zones, method):\n    \"\"\"Rediscretize source to n zones. Either through linear interpolation or using a normal distribution.\"\"\"\n    warnings.warn(\"This functionality is not implemented yet. Try again later.\")\n    return None\n</code></pre>"},{"location":"reference/reference_data/#mibitrans.data.parameters.SourceParameters.visualize","title":"<code>visualize()</code>","text":"<p>Plot the source zone concentration distribution.</p> Source code in <code>mibitrans/data/parameters.py</code> <pre><code>def visualize(self):\n    \"\"\"Plot the source zone concentration distribution.\"\"\"\n    source_zone(self)\n</code></pre>"},{"location":"reference/reference_transport/","title":"<code>mibitrans.transport</code> API reference","text":""},{"location":"reference/reference_transport/#mibitrans.transport.model_parent","title":"<code>model_parent</code>","text":""},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results","title":"<code>Results</code>","text":"<p>Object that holds model results and input parameters for individual runs.</p> Source code in <code>mibitrans/transport/model_parent.py</code> <pre><code>class Results:\n    \"\"\"Object that holds model results and input parameters for individual runs.\"\"\"\n\n    def __init__(self, model):\n        \"\"\"Records input parameters and resulting output based given model.\n\n        Args:\n            model (Transport3D): Model object from which to initialize results. Should be child class of Transport3D.\n\n        Properties:\n            model_type (Transport3D) : Class instance of model used to generate results.\n            short_description (str) : Short description of model.\n            x (np.ndarray) : Numpy array with model x (longitudinal direction) discretization, corresponding to\n                model_parameters, with distance in [m].\n            y (np.ndarray) : Numpy array with model y (transverse horizontal direction) discretization, corresponding to\n                model_parameters, with distance in [m].\n            t (np.ndarray) : Numpy array with model t (time) discretization, corresponding to\n                model_parameters, with time in [days].\n            hydrological_parameters (HydrologicalParameters) : Dataclass holding the hydrological parameters used to\n                run the model.\n            attenuation_parameters (AttenuationParameters) : Dataclass holding the attenuation parameters used to run\n                the model.\n            source_parameters (SourceParameters) : Dataclass holding the source parameters used to run the model.\n            model_parameters (ModelParameters): Dataclass holding the model parameters used to run the model.\n            electron_acceptors (ElectronAcceptors): Dataclass holding the electron acceptor concentrations used to run\n                the model. Only for instant reaction, None for other models.\n            utilization_factor (UtilizationFactor): Dataclass holding the electron acceptor utilization factors used to\n                run the model. Only for instant reaction, None for other models.\n            mode (str) : Model mode of the used model. Either 'linear' or 'instant_reaction'\n            rv (float) : Retarded flow velocity, as v / R [m/day].\n            k_source (float) : Source depletion rate [1/days]. For infinite source mass, k_source = 0, and therefore, no\n                source depletion takes place.\n            c_source (np.ndarray) : Initial nett source zone concentrations. For multiple source zones, nett\n                concentration in nth source zone is original concentration minus concentration in source zone n - 1. For\n                instant reaction model, the biodegradation capacity is added to the outermost source zone.\n            biodegradation_capacity (float) : Maximum capacity of biodegradation taking place, based on electron\n                acceptor concentrations and utilization factor.\n            cxyt (np.ndarray) : Three-dimensional numpy array with concentrations for all x, y and t positions. Indexed\n             as cxyt[t,y,x]. In [g/m3].\n            relative_cxyt (np.ndarray) : Three-dimensional numpy array with relative concentrations for all x, y and t\n                positions. Compared to maximum source zone concentrations.\n            cxyt_noBC (np.ndarray) : Three-dimensional numpy array with concentrations for all x, y and t of instant\n                reaction models, without subtracting the biodegradation capacity, in [g/m3].\n            input_parameters (dict) : Dictionary of input parameter dataclasses for the model. Does not include instant\n                reaction parameters.\n\n        Methods:\n            centerline : Plot center of contaminant plume, at a specified time and y position.\n            transverse : Plot concentration distribution as a line horizontal transverse to the plume extent.\n            breakthrough : Plot contaminant breakthrough curve at given x and y position in model domain.\n            plume_2d : Plot contaminant plume as a 2D colormesh, at a specified time.\n            plume_3d : Plot contaminant plume as a 3D surface, at a specified time.\n            mass_balance : Return a mass balance object with source and plume characteristics at given time(s).\n        \"\"\"\n        self._model_type = model.__class__\n        self._short_description = model.short_description\n        self._x = model.x\n        self._y = model.y\n        self._t = model.t\n\n        # All properties of Transport3D that are objects should be copied; if not copied, changing them in the class\n        # object where they originated will also change them here, which is not the intended behaviour.\n        self._hydrological_parameters = copy.copy(model.hydrological_parameters)\n        self._attenuation_parameters = copy.copy(model.attenuation_parameters)\n        self._source_parameters = copy.copy(model.source_parameters)\n        self._model_parameters = copy.copy(model.model_parameters)\n        self._electron_acceptors = copy.copy(model._electron_acceptors)\n        self._utilization_factor = copy.copy(model._utilization_factor)\n\n        self._mode = model.mode\n        self._rv = model.rv\n        self._k_source = model.k_source\n        self._c_source = model.c_source\n        self._biodegradation_capacity = model.biodegradation_capacity\n\n        self._cxyt = model.cxyt\n        self._relative_cxyt = model.relative_cxyt\n        self._cxyt_noBC = model.cxyt_noBC\n\n    @property\n    def model_type(self):\n        \"\"\"Class object of the model that generated the results.\"\"\"\n        return self._model_type\n\n    @property\n    def short_description(self):\n        \"\"\"Short description of the model that generated the results.\"\"\"\n        return self._short_description\n\n    @property\n    def x(self):\n        \"\"\"Model x discretization array.\"\"\"\n        return self._x\n\n    @property\n    def y(self):\n        \"\"\"Model y discretization array.\"\"\"\n        return self._y\n\n    @property\n    def t(self):\n        \"\"\"Model t discretization array.\"\"\"\n        return self._t\n\n    @property\n    def hydrological_parameters(self):\n        \"\"\"Hydrological parameters of the model used for the results.\"\"\"\n        return self._hydrological_parameters\n\n    @property\n    def attenuation_parameters(self):\n        \"\"\"Attenuation parameters of the model used for the results.\"\"\"\n        return self._attenuation_parameters\n\n    @property\n    def source_parameters(self):\n        \"\"\"Source parameters of the model used for the results.\"\"\"\n        return self._source_parameters\n\n    @property\n    def model_parameters(self):\n        \"\"\"Space-time discretization parameters of the model used for the results.\"\"\"\n        return self._model_parameters\n\n    @property\n    def electron_acceptors(self):\n        \"\"\"Electron acceptor/byproduct concentrations of the model used for the results.\"\"\"\n        return self._electron_acceptors\n\n    @property\n    def utilization_factor(self):\n        \"\"\"Utilization factor of the model used for the results.\"\"\"\n        return self._utilization_factor\n\n    @property\n    def mode(self):\n        \"\"\"Model mode used for running the model.\"\"\"\n        return self._mode\n\n    @property\n    def rv(self):\n        \"\"\"Retarded flow velocity used in the model.\"\"\"\n        return self._rv\n\n    @property\n    def k_source(self):\n        \"\"\"Source depletion rate used in the model.\"\"\"\n        return self._k_source\n\n    @property\n    def c_source(self):\n        \"\"\"Nett source zone concentration used in the model.\"\"\"\n        return self._c_source\n\n    @property\n    def biodegradation_capacity(self):\n        \"\"\"Biodegradation capacity of the model used for the results. Only for instant reaction models.\"\"\"\n        return self._biodegradation_capacity\n\n    @property\n    def cxyt(self):\n        \"\"\"Modelled concentration for all x, y and t, using the input parameters present in this object.\"\"\"\n        return self._cxyt\n\n    @property\n    def relative_cxyt(self):\n        \"\"\"Modelled concentration for all x, y and t, divided by the maximum source zone concentration.\"\"\"\n        return self._relative_cxyt\n\n    @property\n    def cxyt_noBC(self):\n        \"\"\"Concentration in domain without subtracting biodegradation capacity, in the instant reaction model.\"\"\"\n        return self._cxyt_noBC\n\n    @property\n    def input_parameters(self):\n        \"\"\"Return the input arguments for the model in the form of a dictionary, based on current values.\"\"\"\n        return dict(\n            hydrological_parameters=self.hydrological_parameters,\n            attenuation_parameters=self.attenuation_parameters,\n            source_parameters=self.source_parameters,\n            model_parameters=self.model_parameters,\n        )\n\n    def centerline(self, y_position=0, time=None, relative_concentration=False, animate=False, **kwargs):\n        \"\"\"Plot center of contaminant plume of this model, at a specified time and y position.\n\n        Args:\n            y_position (float, optional): y-position across the plume (transverse horizontal direction) for the plot.\n                By default, the center of the plume at y=0 is plotted.\n            time (float, optional): Point of time for the plot. Will show the closest time step to given value.\n                By default, last point in time is plotted.\n            relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum\n                source zone concentrations at t=0. By default, absolute concentrations are shown.\n            animate (bool, optional): If True, animation of contaminant plume until given time is shown. Default is\n                False.\n            **kwargs : Arguments to be passed to plt.plot().\n\n        \"\"\"\n        if animate:\n            anim = pline.centerline(\n                self,\n                y_position=y_position,\n                time=time,\n                relative_concentration=relative_concentration,\n                animate=animate,\n                **kwargs,\n            )\n            return anim\n        else:\n            pline.centerline(\n                self,\n                y_position=y_position,\n                time=time,\n                relative_concentration=relative_concentration,\n                animate=animate,\n                **kwargs,\n            )\n            return None\n\n    def transverse(self, x_position, time=None, relative_concentration=False, animate=False, **kwargs):\n        \"\"\"Plot concentration distribution as a line horizontal transverse to the plume extent.\n\n        Args:\n            x_position : x-position along the plume (longitudinal direction) for the plot.\n            time (float): Point of time for the plot. Will show the closest time step to given value.\n                By default, last point in time is plotted.\n            relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum\n                source zone concentrations at t=0. By default, absolute concentrations are shown.\n            animate (bool, optional): If True, animation of contaminant plume until given time is shown. Default is\n                False.\n            **kwargs : Arguments to be passed to plt.plot().\n        \"\"\"\n        if animate:\n            anim = pline.transverse(\n                self,\n                x_position=x_position,\n                time=time,\n                relative_concentration=relative_concentration,\n                animate=animate,\n                **kwargs,\n            )\n            return anim\n        else:\n            pline.transverse(\n                self,\n                x_position=x_position,\n                time=time,\n                relative_concentration=relative_concentration,\n                animate=animate,\n                **kwargs,\n            )\n            return None\n\n    def breakthrough(self, x_position, y_position=0, relative_concentration=False, animate=False, **kwargs):\n        \"\"\"Plot contaminant breakthrough curve at given x and y position in model domain.\n\n        Args:\n            x_position : x-position along the plume (longitudinal direction).\n            y_position : y-position across the plume (transverse horizontal direction).\n                By default, at the center of the plume (at y=0).\n            relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum\n                source zone concentrations at t=0. By default, absolute concentrations are shown.\n            animate (bool, optional): If True, animation of contaminant plume until given time is shown. Default is\n                False.\n            **kwargs : Arguments to be passed to plt.plot().\n        \"\"\"\n        if animate:\n            anim = pline.breakthrough(\n                self,\n                x_position=x_position,\n                y_position=y_position,\n                relative_concentration=relative_concentration,\n                animate=animate,\n                **kwargs,\n            )\n            return anim\n        else:\n            pline.breakthrough(\n                self,\n                x_position=x_position,\n                y_position=y_position,\n                relative_concentration=relative_concentration,\n                animate=animate,\n                **kwargs,\n            )\n            return None\n\n    def plume_2d(self, time=None, relative_concentration=False, animate=False, **kwargs):\n        \"\"\"Plot contaminant plume as a 2D colormesh, at a specified time.\n\n        Args:\n            time (float): Point of time for the plot. Will show the closest time step to given value.\n                By default, last point in time is plotted.\n            relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum\n                source zone concentrations at t=0. By default, absolute concentrations are shown.\n            animate (bool, optional): If True, animation of contaminant plume until given time is shown. Default is\n                False.\n            **kwargs : Arguments to be passed to plt.pcolormesh().\n\n        Returns a matrix plot of the input plume as object.\n        \"\"\"\n        anim = psurf.plume_2d(self, time=time, relative_concentration=relative_concentration, animate=animate, **kwargs)\n        return anim\n\n    def plume_3d(self, time=None, relative_concentration=False, animate=False, **kwargs):\n        \"\"\"Plot contaminant plume as a 3D surface, at a specified time.\n\n        Args:\n            time (float): Point of time for the plot. Will show the closest time step to given value.\n                By default, last point in time is plotted.\n            relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum\n                source zone concentrations at t=0. By default, absolute concentrations are shown.\n            animate (bool, optional): If True, animation of contaminant plume until given time is shown. Default is\n                False.\n            **kwargs : Arguments to be passed to plt.plot_surface().\n\n        Returns:\n            ax (matplotlib.axes._axes.Axes) : Matplotlib Axes object of plume plot.\n                or if animate == True\n            anim (matplotib.animation.FuncAnimation) : Matplotlib FuncAnimation object of plume plot.\n        \"\"\"\n        ax_or_anim = psurf.plume_3d(\n            self, time=time, relative_concentration=relative_concentration, animate=animate, **kwargs\n        )\n        return ax_or_anim\n\n    def mass_balance(self, time=\"all\", verbose=False):\n        \"\"\"Return a mass balance object with source and plume characteristics at given time(s).\n\n        Args:\n            time (float | str): Time at which to initially calculate the mass balance. Either as a value between 0 and\n                model end time. Or as 'all', which will calculate mass balance attributes for each time step as arrays.\n            verbose (bool, optional): Verbose mode. Defaults to False.\n\n        Returns:\n            mass_balance_object: Object of the MassBalance class. Output is accessed through object properties. Can be\n                called to change the time of the mass balance.\n\n        The mass balance object has the following properties:\n            plume_mass: Mass of the contaminant plume inside the model extent, at the given time(s), in [g].\n            source_mass: Mass of the contaminant source at the given time(s), in [g]. No values are given for models\n                with infinite source mass.\n            delta_source: Difference in mass between contaminant source at given time and source at t = 0, in [g].\n            degraded_mass: Mass of plume contaminant degradation at the given time(s), compared to a model without\n                degradation, in [g]. Has no value if model does not consider degradation.\n            model_without_degradation: Object of model without degradation. Has no value if model does not consider\n                degradation.\n            instant_reaction_degraded_mass(self): Difference in plume mass instant reaction with and without\n                biodegradation capacity subtracted, in [g].\n            electron_acceptor_change(self): Change in electron acceptor/byproduct masses at the given time(s), in [g].\n                Only for instant reaction.\n        \"\"\"\n        return MassBalance(self, time, verbose)\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.attenuation_parameters","title":"<code>attenuation_parameters</code>  <code>property</code>","text":"<p>Attenuation parameters of the model used for the results.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.biodegradation_capacity","title":"<code>biodegradation_capacity</code>  <code>property</code>","text":"<p>Biodegradation capacity of the model used for the results. Only for instant reaction models.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.c_source","title":"<code>c_source</code>  <code>property</code>","text":"<p>Nett source zone concentration used in the model.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.cxyt","title":"<code>cxyt</code>  <code>property</code>","text":"<p>Modelled concentration for all x, y and t, using the input parameters present in this object.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.cxyt_noBC","title":"<code>cxyt_noBC</code>  <code>property</code>","text":"<p>Concentration in domain without subtracting biodegradation capacity, in the instant reaction model.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.electron_acceptors","title":"<code>electron_acceptors</code>  <code>property</code>","text":"<p>Electron acceptor/byproduct concentrations of the model used for the results.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.hydrological_parameters","title":"<code>hydrological_parameters</code>  <code>property</code>","text":"<p>Hydrological parameters of the model used for the results.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.input_parameters","title":"<code>input_parameters</code>  <code>property</code>","text":"<p>Return the input arguments for the model in the form of a dictionary, based on current values.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.k_source","title":"<code>k_source</code>  <code>property</code>","text":"<p>Source depletion rate used in the model.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.mode","title":"<code>mode</code>  <code>property</code>","text":"<p>Model mode used for running the model.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.model_parameters","title":"<code>model_parameters</code>  <code>property</code>","text":"<p>Space-time discretization parameters of the model used for the results.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.model_type","title":"<code>model_type</code>  <code>property</code>","text":"<p>Class object of the model that generated the results.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.relative_cxyt","title":"<code>relative_cxyt</code>  <code>property</code>","text":"<p>Modelled concentration for all x, y and t, divided by the maximum source zone concentration.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.rv","title":"<code>rv</code>  <code>property</code>","text":"<p>Retarded flow velocity used in the model.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.short_description","title":"<code>short_description</code>  <code>property</code>","text":"<p>Short description of the model that generated the results.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.source_parameters","title":"<code>source_parameters</code>  <code>property</code>","text":"<p>Source parameters of the model used for the results.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.t","title":"<code>t</code>  <code>property</code>","text":"<p>Model t discretization array.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.utilization_factor","title":"<code>utilization_factor</code>  <code>property</code>","text":"<p>Utilization factor of the model used for the results.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.x","title":"<code>x</code>  <code>property</code>","text":"<p>Model x discretization array.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.y","title":"<code>y</code>  <code>property</code>","text":"<p>Model y discretization array.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.__init__","title":"<code>__init__(model)</code>","text":"<p>Records input parameters and resulting output based given model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Transport3D</code> <p>Model object from which to initialize results. Should be child class of Transport3D.</p> required Properties <p>model_type (Transport3D) : Class instance of model used to generate results. short_description (str) : Short description of model. x (np.ndarray) : Numpy array with model x (longitudinal direction) discretization, corresponding to     model_parameters, with distance in [m]. y (np.ndarray) : Numpy array with model y (transverse horizontal direction) discretization, corresponding to     model_parameters, with distance in [m]. t (np.ndarray) : Numpy array with model t (time) discretization, corresponding to     model_parameters, with time in [days]. hydrological_parameters (HydrologicalParameters) : Dataclass holding the hydrological parameters used to     run the model. attenuation_parameters (AttenuationParameters) : Dataclass holding the attenuation parameters used to run     the model. source_parameters (SourceParameters) : Dataclass holding the source parameters used to run the model. model_parameters (ModelParameters): Dataclass holding the model parameters used to run the model. electron_acceptors (ElectronAcceptors): Dataclass holding the electron acceptor concentrations used to run     the model. Only for instant reaction, None for other models. utilization_factor (UtilizationFactor): Dataclass holding the electron acceptor utilization factors used to     run the model. Only for instant reaction, None for other models. mode (str) : Model mode of the used model. Either \u2018linear\u2019 or \u2018instant_reaction\u2019 rv (float) : Retarded flow velocity, as v / R [m/day]. k_source (float) : Source depletion rate [1/days]. For infinite source mass, k_source = 0, and therefore, no     source depletion takes place. c_source (np.ndarray) : Initial nett source zone concentrations. For multiple source zones, nett     concentration in nth source zone is original concentration minus concentration in source zone n - 1. For     instant reaction model, the biodegradation capacity is added to the outermost source zone. biodegradation_capacity (float) : Maximum capacity of biodegradation taking place, based on electron     acceptor concentrations and utilization factor. cxyt (np.ndarray) : Three-dimensional numpy array with concentrations for all x, y and t positions. Indexed  as cxyt[t,y,x]. In [g/m3]. relative_cxyt (np.ndarray) : Three-dimensional numpy array with relative concentrations for all x, y and t     positions. Compared to maximum source zone concentrations. cxyt_noBC (np.ndarray) : Three-dimensional numpy array with concentrations for all x, y and t of instant     reaction models, without subtracting the biodegradation capacity, in [g/m3]. input_parameters (dict) : Dictionary of input parameter dataclasses for the model. Does not include instant     reaction parameters.</p> <p>Functions:</p> Name Description <code>centerline </code> <p>Plot center of contaminant plume, at a specified time and y position.</p> <code>transverse </code> <p>Plot concentration distribution as a line horizontal transverse to the plume extent.</p> <code>breakthrough </code> <p>Plot contaminant breakthrough curve at given x and y position in model domain.</p> <code>plume_2d </code> <p>Plot contaminant plume as a 2D colormesh, at a specified time.</p> <code>plume_3d </code> <p>Plot contaminant plume as a 3D surface, at a specified time.</p> <code>mass_balance </code> <p>Return a mass balance object with source and plume characteristics at given time(s).</p> Source code in <code>mibitrans/transport/model_parent.py</code> <pre><code>def __init__(self, model):\n    \"\"\"Records input parameters and resulting output based given model.\n\n    Args:\n        model (Transport3D): Model object from which to initialize results. Should be child class of Transport3D.\n\n    Properties:\n        model_type (Transport3D) : Class instance of model used to generate results.\n        short_description (str) : Short description of model.\n        x (np.ndarray) : Numpy array with model x (longitudinal direction) discretization, corresponding to\n            model_parameters, with distance in [m].\n        y (np.ndarray) : Numpy array with model y (transverse horizontal direction) discretization, corresponding to\n            model_parameters, with distance in [m].\n        t (np.ndarray) : Numpy array with model t (time) discretization, corresponding to\n            model_parameters, with time in [days].\n        hydrological_parameters (HydrologicalParameters) : Dataclass holding the hydrological parameters used to\n            run the model.\n        attenuation_parameters (AttenuationParameters) : Dataclass holding the attenuation parameters used to run\n            the model.\n        source_parameters (SourceParameters) : Dataclass holding the source parameters used to run the model.\n        model_parameters (ModelParameters): Dataclass holding the model parameters used to run the model.\n        electron_acceptors (ElectronAcceptors): Dataclass holding the electron acceptor concentrations used to run\n            the model. Only for instant reaction, None for other models.\n        utilization_factor (UtilizationFactor): Dataclass holding the electron acceptor utilization factors used to\n            run the model. Only for instant reaction, None for other models.\n        mode (str) : Model mode of the used model. Either 'linear' or 'instant_reaction'\n        rv (float) : Retarded flow velocity, as v / R [m/day].\n        k_source (float) : Source depletion rate [1/days]. For infinite source mass, k_source = 0, and therefore, no\n            source depletion takes place.\n        c_source (np.ndarray) : Initial nett source zone concentrations. For multiple source zones, nett\n            concentration in nth source zone is original concentration minus concentration in source zone n - 1. For\n            instant reaction model, the biodegradation capacity is added to the outermost source zone.\n        biodegradation_capacity (float) : Maximum capacity of biodegradation taking place, based on electron\n            acceptor concentrations and utilization factor.\n        cxyt (np.ndarray) : Three-dimensional numpy array with concentrations for all x, y and t positions. Indexed\n         as cxyt[t,y,x]. In [g/m3].\n        relative_cxyt (np.ndarray) : Three-dimensional numpy array with relative concentrations for all x, y and t\n            positions. Compared to maximum source zone concentrations.\n        cxyt_noBC (np.ndarray) : Three-dimensional numpy array with concentrations for all x, y and t of instant\n            reaction models, without subtracting the biodegradation capacity, in [g/m3].\n        input_parameters (dict) : Dictionary of input parameter dataclasses for the model. Does not include instant\n            reaction parameters.\n\n    Methods:\n        centerline : Plot center of contaminant plume, at a specified time and y position.\n        transverse : Plot concentration distribution as a line horizontal transverse to the plume extent.\n        breakthrough : Plot contaminant breakthrough curve at given x and y position in model domain.\n        plume_2d : Plot contaminant plume as a 2D colormesh, at a specified time.\n        plume_3d : Plot contaminant plume as a 3D surface, at a specified time.\n        mass_balance : Return a mass balance object with source and plume characteristics at given time(s).\n    \"\"\"\n    self._model_type = model.__class__\n    self._short_description = model.short_description\n    self._x = model.x\n    self._y = model.y\n    self._t = model.t\n\n    # All properties of Transport3D that are objects should be copied; if not copied, changing them in the class\n    # object where they originated will also change them here, which is not the intended behaviour.\n    self._hydrological_parameters = copy.copy(model.hydrological_parameters)\n    self._attenuation_parameters = copy.copy(model.attenuation_parameters)\n    self._source_parameters = copy.copy(model.source_parameters)\n    self._model_parameters = copy.copy(model.model_parameters)\n    self._electron_acceptors = copy.copy(model._electron_acceptors)\n    self._utilization_factor = copy.copy(model._utilization_factor)\n\n    self._mode = model.mode\n    self._rv = model.rv\n    self._k_source = model.k_source\n    self._c_source = model.c_source\n    self._biodegradation_capacity = model.biodegradation_capacity\n\n    self._cxyt = model.cxyt\n    self._relative_cxyt = model.relative_cxyt\n    self._cxyt_noBC = model.cxyt_noBC\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.breakthrough","title":"<code>breakthrough(x_position, y_position=0, relative_concentration=False, animate=False, **kwargs)</code>","text":"<p>Plot contaminant breakthrough curve at given x and y position in model domain.</p> <p>Parameters:</p> Name Type Description Default <code>x_position </code> <p>x-position along the plume (longitudinal direction).</p> required <code>y_position </code> <p>y-position across the plume (transverse horizontal direction). By default, at the center of the plume (at y=0).</p> required <code>relative_concentration (bool, optional) </code> <p>If set to True, will plot concentrations relative to maximum source zone concentrations at t=0. By default, absolute concentrations are shown.</p> required <code>animate</code> <code>bool</code> <p>If True, animation of contaminant plume until given time is shown. Default is False.</p> <code>False</code> <code>**kwargs </code> <p>Arguments to be passed to plt.plot().</p> required Source code in <code>mibitrans/transport/model_parent.py</code> <pre><code>def breakthrough(self, x_position, y_position=0, relative_concentration=False, animate=False, **kwargs):\n    \"\"\"Plot contaminant breakthrough curve at given x and y position in model domain.\n\n    Args:\n        x_position : x-position along the plume (longitudinal direction).\n        y_position : y-position across the plume (transverse horizontal direction).\n            By default, at the center of the plume (at y=0).\n        relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum\n            source zone concentrations at t=0. By default, absolute concentrations are shown.\n        animate (bool, optional): If True, animation of contaminant plume until given time is shown. Default is\n            False.\n        **kwargs : Arguments to be passed to plt.plot().\n    \"\"\"\n    if animate:\n        anim = pline.breakthrough(\n            self,\n            x_position=x_position,\n            y_position=y_position,\n            relative_concentration=relative_concentration,\n            animate=animate,\n            **kwargs,\n        )\n        return anim\n    else:\n        pline.breakthrough(\n            self,\n            x_position=x_position,\n            y_position=y_position,\n            relative_concentration=relative_concentration,\n            animate=animate,\n            **kwargs,\n        )\n        return None\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.centerline","title":"<code>centerline(y_position=0, time=None, relative_concentration=False, animate=False, **kwargs)</code>","text":"<p>Plot center of contaminant plume of this model, at a specified time and y position.</p> <p>Parameters:</p> Name Type Description Default <code>y_position</code> <code>float</code> <p>y-position across the plume (transverse horizontal direction) for the plot. By default, the center of the plume at y=0 is plotted.</p> <code>0</code> <code>time</code> <code>float</code> <p>Point of time for the plot. Will show the closest time step to given value. By default, last point in time is plotted.</p> <code>None</code> <code>relative_concentration (bool, optional) </code> <p>If set to True, will plot concentrations relative to maximum source zone concentrations at t=0. By default, absolute concentrations are shown.</p> required <code>animate</code> <code>bool</code> <p>If True, animation of contaminant plume until given time is shown. Default is False.</p> <code>False</code> <code>**kwargs </code> <p>Arguments to be passed to plt.plot().</p> required Source code in <code>mibitrans/transport/model_parent.py</code> <pre><code>def centerline(self, y_position=0, time=None, relative_concentration=False, animate=False, **kwargs):\n    \"\"\"Plot center of contaminant plume of this model, at a specified time and y position.\n\n    Args:\n        y_position (float, optional): y-position across the plume (transverse horizontal direction) for the plot.\n            By default, the center of the plume at y=0 is plotted.\n        time (float, optional): Point of time for the plot. Will show the closest time step to given value.\n            By default, last point in time is plotted.\n        relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum\n            source zone concentrations at t=0. By default, absolute concentrations are shown.\n        animate (bool, optional): If True, animation of contaminant plume until given time is shown. Default is\n            False.\n        **kwargs : Arguments to be passed to plt.plot().\n\n    \"\"\"\n    if animate:\n        anim = pline.centerline(\n            self,\n            y_position=y_position,\n            time=time,\n            relative_concentration=relative_concentration,\n            animate=animate,\n            **kwargs,\n        )\n        return anim\n    else:\n        pline.centerline(\n            self,\n            y_position=y_position,\n            time=time,\n            relative_concentration=relative_concentration,\n            animate=animate,\n            **kwargs,\n        )\n        return None\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.mass_balance","title":"<code>mass_balance(time='all', verbose=False)</code>","text":"<p>Return a mass balance object with source and plume characteristics at given time(s).</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float | str</code> <p>Time at which to initially calculate the mass balance. Either as a value between 0 and model end time. Or as \u2018all\u2019, which will calculate mass balance attributes for each time step as arrays.</p> <code>'all'</code> <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>mass_balance_object</code> <p>Object of the MassBalance class. Output is accessed through object properties. Can be called to change the time of the mass balance.</p> The mass balance object has the following properties <p>plume_mass: Mass of the contaminant plume inside the model extent, at the given time(s), in [g]. source_mass: Mass of the contaminant source at the given time(s), in [g]. No values are given for models     with infinite source mass. delta_source: Difference in mass between contaminant source at given time and source at t = 0, in [g]. degraded_mass: Mass of plume contaminant degradation at the given time(s), compared to a model without     degradation, in [g]. Has no value if model does not consider degradation. model_without_degradation: Object of model without degradation. Has no value if model does not consider     degradation. instant_reaction_degraded_mass(self): Difference in plume mass instant reaction with and without     biodegradation capacity subtracted, in [g]. electron_acceptor_change(self): Change in electron acceptor/byproduct masses at the given time(s), in [g].     Only for instant reaction.</p> Source code in <code>mibitrans/transport/model_parent.py</code> <pre><code>def mass_balance(self, time=\"all\", verbose=False):\n    \"\"\"Return a mass balance object with source and plume characteristics at given time(s).\n\n    Args:\n        time (float | str): Time at which to initially calculate the mass balance. Either as a value between 0 and\n            model end time. Or as 'all', which will calculate mass balance attributes for each time step as arrays.\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Returns:\n        mass_balance_object: Object of the MassBalance class. Output is accessed through object properties. Can be\n            called to change the time of the mass balance.\n\n    The mass balance object has the following properties:\n        plume_mass: Mass of the contaminant plume inside the model extent, at the given time(s), in [g].\n        source_mass: Mass of the contaminant source at the given time(s), in [g]. No values are given for models\n            with infinite source mass.\n        delta_source: Difference in mass between contaminant source at given time and source at t = 0, in [g].\n        degraded_mass: Mass of plume contaminant degradation at the given time(s), compared to a model without\n            degradation, in [g]. Has no value if model does not consider degradation.\n        model_without_degradation: Object of model without degradation. Has no value if model does not consider\n            degradation.\n        instant_reaction_degraded_mass(self): Difference in plume mass instant reaction with and without\n            biodegradation capacity subtracted, in [g].\n        electron_acceptor_change(self): Change in electron acceptor/byproduct masses at the given time(s), in [g].\n            Only for instant reaction.\n    \"\"\"\n    return MassBalance(self, time, verbose)\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.plume_2d","title":"<code>plume_2d(time=None, relative_concentration=False, animate=False, **kwargs)</code>","text":"<p>Plot contaminant plume as a 2D colormesh, at a specified time.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>Point of time for the plot. Will show the closest time step to given value. By default, last point in time is plotted.</p> <code>None</code> <code>relative_concentration (bool, optional) </code> <p>If set to True, will plot concentrations relative to maximum source zone concentrations at t=0. By default, absolute concentrations are shown.</p> required <code>animate</code> <code>bool</code> <p>If True, animation of contaminant plume until given time is shown. Default is False.</p> <code>False</code> <code>**kwargs </code> <p>Arguments to be passed to plt.pcolormesh().</p> required <p>Returns a matrix plot of the input plume as object.</p> Source code in <code>mibitrans/transport/model_parent.py</code> <pre><code>def plume_2d(self, time=None, relative_concentration=False, animate=False, **kwargs):\n    \"\"\"Plot contaminant plume as a 2D colormesh, at a specified time.\n\n    Args:\n        time (float): Point of time for the plot. Will show the closest time step to given value.\n            By default, last point in time is plotted.\n        relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum\n            source zone concentrations at t=0. By default, absolute concentrations are shown.\n        animate (bool, optional): If True, animation of contaminant plume until given time is shown. Default is\n            False.\n        **kwargs : Arguments to be passed to plt.pcolormesh().\n\n    Returns a matrix plot of the input plume as object.\n    \"\"\"\n    anim = psurf.plume_2d(self, time=time, relative_concentration=relative_concentration, animate=animate, **kwargs)\n    return anim\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.plume_3d","title":"<code>plume_3d(time=None, relative_concentration=False, animate=False, **kwargs)</code>","text":"<p>Plot contaminant plume as a 3D surface, at a specified time.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>Point of time for the plot. Will show the closest time step to given value. By default, last point in time is plotted.</p> <code>None</code> <code>relative_concentration (bool, optional) </code> <p>If set to True, will plot concentrations relative to maximum source zone concentrations at t=0. By default, absolute concentrations are shown.</p> required <code>animate</code> <code>bool</code> <p>If True, animation of contaminant plume until given time is shown. Default is False.</p> <code>False</code> <code>**kwargs </code> <p>Arguments to be passed to plt.plot_surface().</p> required <p>Returns:</p> Type Description <p>ax (matplotlib.axes._axes.Axes) : Matplotlib Axes object of plume plot. or if animate == True</p> <p>anim (matplotib.animation.FuncAnimation) : Matplotlib FuncAnimation object of plume plot.</p> Source code in <code>mibitrans/transport/model_parent.py</code> <pre><code>def plume_3d(self, time=None, relative_concentration=False, animate=False, **kwargs):\n    \"\"\"Plot contaminant plume as a 3D surface, at a specified time.\n\n    Args:\n        time (float): Point of time for the plot. Will show the closest time step to given value.\n            By default, last point in time is plotted.\n        relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum\n            source zone concentrations at t=0. By default, absolute concentrations are shown.\n        animate (bool, optional): If True, animation of contaminant plume until given time is shown. Default is\n            False.\n        **kwargs : Arguments to be passed to plt.plot_surface().\n\n    Returns:\n        ax (matplotlib.axes._axes.Axes) : Matplotlib Axes object of plume plot.\n            or if animate == True\n        anim (matplotib.animation.FuncAnimation) : Matplotlib FuncAnimation object of plume plot.\n    \"\"\"\n    ax_or_anim = psurf.plume_3d(\n        self, time=time, relative_concentration=relative_concentration, animate=animate, **kwargs\n    )\n    return ax_or_anim\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Results.transverse","title":"<code>transverse(x_position, time=None, relative_concentration=False, animate=False, **kwargs)</code>","text":"<p>Plot concentration distribution as a line horizontal transverse to the plume extent.</p> <p>Parameters:</p> Name Type Description Default <code>x_position </code> <p>x-position along the plume (longitudinal direction) for the plot.</p> required <code>time</code> <code>float</code> <p>Point of time for the plot. Will show the closest time step to given value. By default, last point in time is plotted.</p> <code>None</code> <code>relative_concentration (bool, optional) </code> <p>If set to True, will plot concentrations relative to maximum source zone concentrations at t=0. By default, absolute concentrations are shown.</p> required <code>animate</code> <code>bool</code> <p>If True, animation of contaminant plume until given time is shown. Default is False.</p> <code>False</code> <code>**kwargs </code> <p>Arguments to be passed to plt.plot().</p> required Source code in <code>mibitrans/transport/model_parent.py</code> <pre><code>def transverse(self, x_position, time=None, relative_concentration=False, animate=False, **kwargs):\n    \"\"\"Plot concentration distribution as a line horizontal transverse to the plume extent.\n\n    Args:\n        x_position : x-position along the plume (longitudinal direction) for the plot.\n        time (float): Point of time for the plot. Will show the closest time step to given value.\n            By default, last point in time is plotted.\n        relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum\n            source zone concentrations at t=0. By default, absolute concentrations are shown.\n        animate (bool, optional): If True, animation of contaminant plume until given time is shown. Default is\n            False.\n        **kwargs : Arguments to be passed to plt.plot().\n    \"\"\"\n    if animate:\n        anim = pline.transverse(\n            self,\n            x_position=x_position,\n            time=time,\n            relative_concentration=relative_concentration,\n            animate=animate,\n            **kwargs,\n        )\n        return anim\n    else:\n        pline.transverse(\n            self,\n            x_position=x_position,\n            time=time,\n            relative_concentration=relative_concentration,\n            animate=animate,\n            **kwargs,\n        )\n        return None\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D","title":"<code>Transport3D</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Parent class for all 3-dimensional analytical solutions.</p> Source code in <code>mibitrans/transport/model_parent.py</code> <pre><code>class Transport3D(ABC):\n    \"\"\"Parent class for all 3-dimensional analytical solutions.\"\"\"\n\n    def __init__(\n        self, hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose=False\n    ):\n        \"\"\"Initialize parent class object.\n\n        Args:\n            hydrological_parameters (mibitrans.data.parameters.HydrologicalParameters) : Dataclass object containing\n                hydrological parameters from HydrologicalParameters.\n            attenuation_parameters (mibitrans.data.read.AttenuationParameters) : Dataclass object containing adsorption,\n                degradation and diffusion parameters from AttenuationParameters.\n            source_parameters (mibitrans.data.read.SourceParameters) : Dataclass object containing source parameters\n                from SourceParameters.\n            model_parameters (mibitrans.data.read.ModelParameters) : Dataclass object containing model parameters from\n                ModelParameters.\n            verbose (bool, optional): Verbose mode. Defaults to False.\n        \"\"\"\n        # Check if input arguments are of the correct dataclass\n        for key, value in locals().items():\n            if key not in [\"self\", \"verbose\"]:\n                self._check_input_dataclasses(key, value)\n\n        self._hyd_pars = copy.copy(hydrological_parameters)\n        self._att_pars = copy.copy(attenuation_parameters)\n        self._src_pars = copy.copy(source_parameters)\n        self._mod_pars = copy.copy(model_parameters)\n        self._decay_rate = self._att_pars.decay_rate\n\n        self.verbose = verbose\n        self._mode = \"linear\"\n        self._electron_acceptors = None\n        self._utilization_factor = None\n        self.biodegradation_capacity = None\n        self.cxyt_noBC = None\n        self._pre_run_initialization_parameters()\n\n    @property\n    def input_parameters(self):\n        \"\"\"Return the input arguments for the model in the form of a dictionary, based on current values.\"\"\"\n        return dict(\n            hydrological_parameters=self.hydrological_parameters,\n            attenuation_parameters=self.attenuation_parameters,\n            source_parameters=self.source_parameters,\n            model_parameters=self.model_parameters,\n            verbose=self.verbose,\n        )\n\n    @property\n    def hydrological_parameters(self):\n        \"\"\"Rename to shorthand form of hydrological_parameters inside class for ease of use.\"\"\"\n        return self._hyd_pars\n\n    @hydrological_parameters.setter\n    def hydrological_parameters(self, value):\n        self._check_input_dataclasses(\"hydrological_parameters\", value)\n        self._hyd_pars = copy.copy(value)\n\n    @property\n    def attenuation_parameters(self):\n        \"\"\"Rename to shorthand form of attenuation_parameters inside class for ease of use.\"\"\"\n        return self._att_pars\n\n    @attenuation_parameters.setter\n    def attenuation_parameters(self, value):\n        self._check_input_dataclasses(\"attenuation_parameters\", value)\n        self._att_pars = copy.copy(value)\n\n    @property\n    def source_parameters(self):\n        \"\"\"Rename to shorthand form of source_parameters inside class for ease of use.\"\"\"\n        return self._src_pars\n\n    @source_parameters.setter\n    def source_parameters(self, value):\n        self._check_input_dataclasses(\"source_parameters\", value)\n        self._src_pars = copy.copy(value)\n\n    @property\n    def model_parameters(self):\n        \"\"\"Rename to shorthand form of model_parameters inside class for ease of use.\"\"\"\n        return self._mod_pars\n\n    @model_parameters.setter\n    def model_parameters(self, value):\n        self._check_input_dataclasses(\"model_parameters\", value)\n        self._mod_pars = copy.copy(value)\n\n    @property\n    def mode(self):\n        \"\"\"Model mode property. Either 'linear' or 'instant_reaction'.\"\"\"\n        return self._mode\n\n    @mode.setter\n    def mode(self, value):\n        match value:\n            case \"linear\" | \"linear decay\" | \"linear_decay\" | 0:\n                self._mode = \"linear\"\n            case \"instant\" | \"instant_reaction\" | \"instant reaction\" | 1:\n                if self._electron_acceptors is None or self._utilization_factor is None:\n                    raise ValueError(\n                        \"Model mode was set to 'instant reaction', but electron acceptor parameters are \"\n                        \"missing. Use the instant_reaction method to supply the electron acceptor \"\n                        \"concentrations.\"\n                    )\n                self._mode = \"instant_reaction\"\n            case _:\n                warnings.warn(f\"Mode '{value}' not recognized. Defaulting to 'linear' instead.\", UserWarning)\n                self._mode = \"linear\"\n\n    @property\n    def electron_acceptors(self):\n        \"\"\"Return dictionary of electron acceptor parameters.\"\"\"\n        return self._electron_acceptors.dictionary\n\n    @property\n    def utilization_factor(self):\n        \"\"\"Return dictionary of utilization factor property.\"\"\"\n        return self._utilization_factor.dictionary\n\n    @property\n    def relative_cxyt(self):\n        \"\"\"Compute relative concentration c(x,y,t)/c0, where c0 is the maximum source zone concentration at t=0.\"\"\"\n        maximum_concentration = np.max(self.source_parameters.source_zone_concentration)\n        relative_cxyt = self.cxyt / maximum_concentration\n        return relative_cxyt\n\n    @property\n    @abstractmethod\n    def short_description(self):\n        \"\"\"Short string describing model type.\"\"\"\n        pass\n\n    @abstractmethod\n    def run(self):\n        \"\"\"Method that runs the model and ensures that initialisation is performed.\"\"\"\n        pass\n\n    @abstractmethod\n    def sample(self, x_position, y_position, t_position):\n        \"\"\"Method that calculates concentration at single, specified location in model domain.\"\"\"\n        pass\n\n    @abstractmethod\n    def _calculate_concentration_for_all_xyt(self) -&gt; np.ndarray:\n        \"\"\"Method that calculates and return concentration array for all model x, y and t.\"\"\"\n        pass\n\n    def _pre_run_initialization_parameters(self):\n        \"\"\"Parameter initialization for model.\"\"\"\n        # One-dimensional model domain arrays\n        self.x = np.arange(0, self._mod_pars.model_length + self._mod_pars.dx, self._mod_pars.dx)\n        self.y = self._calculate_y_discretization()\n        self.t = np.arange(self._mod_pars.dt, self._mod_pars.model_time + self._mod_pars.dt, self._mod_pars.dt)\n\n        # Three-dimensional model domain arrays\n        self.xxx = self.x[None, None, :]\n        self.yyy = self.y[None, :, None]\n        self.ttt = self.t[:, None, None]\n\n        if (\n            self._att_pars.bulk_density is not None\n            and self._att_pars.partition_coefficient is not None\n            and self._att_pars.fraction_organic_carbon is not None\n        ):\n            self._att_pars.calculate_retardation(self._hyd_pars.porosity)\n\n        self.rv = self._hyd_pars.velocity / self._att_pars.retardation\n\n        # cxyt is concentration output array\n        self.cxyt = np.zeros((len(self.t), len(self.y), len(self.x)))\n\n        # Calculate retardation if not already specified in adsorption_parameters\n        self.k_source = self._calculate_source_decay()\n        self.y_source = self._src_pars.source_zone_boundary\n        # Subtract outer source zones from inner source zones\n        self.c_source = self._src_pars.source_zone_concentration.copy()\n        self.c_source[:-1] = self.c_source[:-1] - self.c_source[1:]\n        if self._mode == \"instant_reaction\":\n            self.c_source[-1] += self.biodegradation_capacity\n            self._decay_rate = 0\n        else:\n            self._decay_rate = self._att_pars.decay_rate\n\n    def _calculate_source_decay(self):\n        \"\"\"Calculate source decay/depletion.\"\"\"\n        if self._src_pars.total_mass != np.inf:\n            Q, c0_avg = calculate_discharge_and_average_source_zone_concentration(self)\n            k_source = Q * c0_avg / self._src_pars.total_mass\n        # If source mass is not a float, it is an infinite source, therefore, no source decay takes place.\n        else:\n            k_source = 0\n\n        return k_source\n\n    def _check_input_dataclasses(self, key, value):\n        \"\"\"Check if input parameters are the correct dataclasses. Raise an error if not.\"\"\"\n        dataclass_dict = {\n            \"hydrological_parameters\": mibitrans.data.parameters.HydrologicalParameters,\n            \"attenuation_parameters\": mibitrans.data.parameters.AttenuationParameters,\n            \"source_parameters\": mibitrans.data.parameters.SourceParameters,\n            \"model_parameters\": mibitrans.data.parameters.ModelParameters,\n        }\n\n        if not isinstance(value, dataclass_dict[key]):\n            raise TypeError(f\"Input argument {key} should be {dataclass_dict[key]}, but is {type(value)} instead.\")\n\n    def _calculate_y_discretization(self):\n        \"\"\"Calculate y-direction discretization.\"\"\"\n        if self._mod_pars.model_width &gt;= 2 * self._src_pars.source_zone_boundary[-1]:\n            y = np.arange(\n                -self._mod_pars.model_width / 2, self._mod_pars.model_width / 2 + self._mod_pars.dy, self._mod_pars.dy\n            )\n        else:\n            y = np.arange(\n                -self._src_pars.source_zone_boundary[-1],\n                self._src_pars.source_zone_boundary[-1] + self._mod_pars.dy,\n                self._mod_pars.dy,\n            )\n            warnings.warn(\n                \"Source zone boundary is larger than model width. Model width adjusted to fit entire source zone.\"\n            )\n        return y\n\n    def _calculate_biodegradation_capacity(self):\n        \"\"\"Determine biodegradation capacity based on electron acceptor concentrations and utilization factor.\"\"\"\n        biodegradation_capacity = 0\n        for key, item in self._utilization_factor.dictionary.items():\n            biodegradation_capacity += getattr(self._electron_acceptors, util_to_conc_name[key]) / item\n\n        return biodegradation_capacity\n\n    def instant_reaction(\n        self,\n        electron_acceptors: list | np.ndarray | dict | ElectronAcceptors,\n        utilization_factor: list | np.ndarray | dict | UtilizationFactor = UtilizationFactor(\n            util_oxygen=3.14, util_nitrate=4.9, util_ferrous_iron=21.8, util_sulfate=4.7, util_methane=0.78\n        ),\n    ):\n        \"\"\"Enable and set up parameters for instant reaction model.\n\n        Instant reaction model assumes that biodegradation is an instantaneous process compared to the groundwater flow\n        velocity. The biodegradation is assumed to be governed by the availability of electron acceptors, and quantified\n        using  stoichiometric relations from the degradation reactions. Considered are concentrations of acceptors\n        Oxygen, Nitrate and Sulfate, and reduced species Ferrous Iron and Methane.\n\n        Args:\n            electron_acceptors (ElectronAcceptors): ElectronAcceptor dataclass containing electron acceptor\n                concentrations. Alternatively provided as list, numpy array or dictionary corresponding with\n                delta_oxygen, delta_nitrate, ferrous_iron, delta_sulfate and methane. For more information, see\n                documentation for ElectronAcceptors.\n            utilization_factor (UtilizationFactor, optional): UtilizationFactor dataclass containing electron acceptor\n                utilization factors. Alternatively provided as list, numpy array or dictionary corresponding with\n                information, see documentation of UtilizationFactor. By default, electron acceptor utilization factors\n                for a BTEX mixture are used, based on values by Wiedemeier et al. (1995).\n        \"\"\"\n        self._electron_acceptors, self._utilization_factor = _check_instant_reaction_acceptor_input(\n            electron_acceptors, utilization_factor\n        )\n        self._mode = \"instant_reaction\"\n        self.biodegradation_capacity = self._calculate_biodegradation_capacity()\n        self.cxyt_noBC = 0\n        self._pre_run_initialization_parameters()\n\n    def _check_model_mode_before_run(self):\n        self._pre_run_initialization_parameters()\n        if self._mode == \"linear\":\n            if self.biodegradation_capacity is not None:\n                warnings.warn(\n                    \"Instant reaction parameters are present while model mode is linear. \"\n                    \"Make sure that this is indeed the desired model.\"\n                )\n        if self._mode == \"instant_reaction\":\n            if self.biodegradation_capacity is None:\n                raise ValueError(\n                    \"Instant reaction parameters are not present. \"\n                    \"Please provide them with the 'instant_reaction' class method.\"\n                )\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.attenuation_parameters","title":"<code>attenuation_parameters</code>  <code>property</code> <code>writable</code>","text":"<p>Rename to shorthand form of attenuation_parameters inside class for ease of use.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.electron_acceptors","title":"<code>electron_acceptors</code>  <code>property</code>","text":"<p>Return dictionary of electron acceptor parameters.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.hydrological_parameters","title":"<code>hydrological_parameters</code>  <code>property</code> <code>writable</code>","text":"<p>Rename to shorthand form of hydrological_parameters inside class for ease of use.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.input_parameters","title":"<code>input_parameters</code>  <code>property</code>","text":"<p>Return the input arguments for the model in the form of a dictionary, based on current values.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.mode","title":"<code>mode</code>  <code>property</code> <code>writable</code>","text":"<p>Model mode property. Either \u2018linear\u2019 or \u2018instant_reaction\u2019.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.model_parameters","title":"<code>model_parameters</code>  <code>property</code> <code>writable</code>","text":"<p>Rename to shorthand form of model_parameters inside class for ease of use.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.relative_cxyt","title":"<code>relative_cxyt</code>  <code>property</code>","text":"<p>Compute relative concentration c(x,y,t)/c0, where c0 is the maximum source zone concentration at t=0.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.short_description","title":"<code>short_description</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Short string describing model type.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.source_parameters","title":"<code>source_parameters</code>  <code>property</code> <code>writable</code>","text":"<p>Rename to shorthand form of source_parameters inside class for ease of use.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.utilization_factor","title":"<code>utilization_factor</code>  <code>property</code>","text":"<p>Return dictionary of utilization factor property.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.__init__","title":"<code>__init__(hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose=False)</code>","text":"<p>Initialize parent class object.</p> <p>Parameters:</p> Name Type Description Default <code>hydrological_parameters (mibitrans.data.parameters.HydrologicalParameters) </code> <p>Dataclass object containing hydrological parameters from HydrologicalParameters.</p> required <code>attenuation_parameters (mibitrans.data.read.AttenuationParameters) </code> <p>Dataclass object containing adsorption, degradation and diffusion parameters from AttenuationParameters.</p> required <code>source_parameters (mibitrans.data.read.SourceParameters) </code> <p>Dataclass object containing source parameters from SourceParameters.</p> required <code>model_parameters (mibitrans.data.read.ModelParameters) </code> <p>Dataclass object containing model parameters from ModelParameters.</p> required <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> Source code in <code>mibitrans/transport/model_parent.py</code> <pre><code>def __init__(\n    self, hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose=False\n):\n    \"\"\"Initialize parent class object.\n\n    Args:\n        hydrological_parameters (mibitrans.data.parameters.HydrologicalParameters) : Dataclass object containing\n            hydrological parameters from HydrologicalParameters.\n        attenuation_parameters (mibitrans.data.read.AttenuationParameters) : Dataclass object containing adsorption,\n            degradation and diffusion parameters from AttenuationParameters.\n        source_parameters (mibitrans.data.read.SourceParameters) : Dataclass object containing source parameters\n            from SourceParameters.\n        model_parameters (mibitrans.data.read.ModelParameters) : Dataclass object containing model parameters from\n            ModelParameters.\n        verbose (bool, optional): Verbose mode. Defaults to False.\n    \"\"\"\n    # Check if input arguments are of the correct dataclass\n    for key, value in locals().items():\n        if key not in [\"self\", \"verbose\"]:\n            self._check_input_dataclasses(key, value)\n\n    self._hyd_pars = copy.copy(hydrological_parameters)\n    self._att_pars = copy.copy(attenuation_parameters)\n    self._src_pars = copy.copy(source_parameters)\n    self._mod_pars = copy.copy(model_parameters)\n    self._decay_rate = self._att_pars.decay_rate\n\n    self.verbose = verbose\n    self._mode = \"linear\"\n    self._electron_acceptors = None\n    self._utilization_factor = None\n    self.biodegradation_capacity = None\n    self.cxyt_noBC = None\n    self._pre_run_initialization_parameters()\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.instant_reaction","title":"<code>instant_reaction(electron_acceptors, utilization_factor=UtilizationFactor(util_oxygen=3.14, util_nitrate=4.9, util_ferrous_iron=21.8, util_sulfate=4.7, util_methane=0.78))</code>","text":"<p>Enable and set up parameters for instant reaction model.</p> <p>Instant reaction model assumes that biodegradation is an instantaneous process compared to the groundwater flow velocity. The biodegradation is assumed to be governed by the availability of electron acceptors, and quantified using  stoichiometric relations from the degradation reactions. Considered are concentrations of acceptors Oxygen, Nitrate and Sulfate, and reduced species Ferrous Iron and Methane.</p> <p>Parameters:</p> Name Type Description Default <code>electron_acceptors</code> <code>ElectronAcceptors</code> <p>ElectronAcceptor dataclass containing electron acceptor concentrations. Alternatively provided as list, numpy array or dictionary corresponding with delta_oxygen, delta_nitrate, ferrous_iron, delta_sulfate and methane. For more information, see documentation for ElectronAcceptors.</p> required <code>utilization_factor</code> <code>UtilizationFactor</code> <p>UtilizationFactor dataclass containing electron acceptor utilization factors. Alternatively provided as list, numpy array or dictionary corresponding with information, see documentation of UtilizationFactor. By default, electron acceptor utilization factors for a BTEX mixture are used, based on values by Wiedemeier et al. (1995).</p> <code>UtilizationFactor(util_oxygen=3.14, util_nitrate=4.9, util_ferrous_iron=21.8, util_sulfate=4.7, util_methane=0.78)</code> Source code in <code>mibitrans/transport/model_parent.py</code> <pre><code>def instant_reaction(\n    self,\n    electron_acceptors: list | np.ndarray | dict | ElectronAcceptors,\n    utilization_factor: list | np.ndarray | dict | UtilizationFactor = UtilizationFactor(\n        util_oxygen=3.14, util_nitrate=4.9, util_ferrous_iron=21.8, util_sulfate=4.7, util_methane=0.78\n    ),\n):\n    \"\"\"Enable and set up parameters for instant reaction model.\n\n    Instant reaction model assumes that biodegradation is an instantaneous process compared to the groundwater flow\n    velocity. The biodegradation is assumed to be governed by the availability of electron acceptors, and quantified\n    using  stoichiometric relations from the degradation reactions. Considered are concentrations of acceptors\n    Oxygen, Nitrate and Sulfate, and reduced species Ferrous Iron and Methane.\n\n    Args:\n        electron_acceptors (ElectronAcceptors): ElectronAcceptor dataclass containing electron acceptor\n            concentrations. Alternatively provided as list, numpy array or dictionary corresponding with\n            delta_oxygen, delta_nitrate, ferrous_iron, delta_sulfate and methane. For more information, see\n            documentation for ElectronAcceptors.\n        utilization_factor (UtilizationFactor, optional): UtilizationFactor dataclass containing electron acceptor\n            utilization factors. Alternatively provided as list, numpy array or dictionary corresponding with\n            information, see documentation of UtilizationFactor. By default, electron acceptor utilization factors\n            for a BTEX mixture are used, based on values by Wiedemeier et al. (1995).\n    \"\"\"\n    self._electron_acceptors, self._utilization_factor = _check_instant_reaction_acceptor_input(\n        electron_acceptors, utilization_factor\n    )\n    self._mode = \"instant_reaction\"\n    self.biodegradation_capacity = self._calculate_biodegradation_capacity()\n    self.cxyt_noBC = 0\n    self._pre_run_initialization_parameters()\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.run","title":"<code>run()</code>  <code>abstractmethod</code>","text":"<p>Method that runs the model and ensures that initialisation is performed.</p> Source code in <code>mibitrans/transport/model_parent.py</code> <pre><code>@abstractmethod\ndef run(self):\n    \"\"\"Method that runs the model and ensures that initialisation is performed.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.model_parent.Transport3D.sample","title":"<code>sample(x_position, y_position, t_position)</code>  <code>abstractmethod</code>","text":"<p>Method that calculates concentration at single, specified location in model domain.</p> Source code in <code>mibitrans/transport/model_parent.py</code> <pre><code>@abstractmethod\ndef sample(self, x_position, y_position, t_position):\n    \"\"\"Method that calculates concentration at single, specified location in model domain.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.models","title":"<code>models</code>","text":""},{"location":"reference/reference_transport/#mibitrans.transport.models.Anatrans","title":"<code>Anatrans</code>","text":"<p>               Bases: <code>Transport3D</code></p> <p>Model class using an analytical solution based on Bear (1979), Domenico (1987) &amp; Newell et al. (1997).</p> <p>Under the assumption that C(x,y,z,t) = C(x,t) * C(y,t) * C(z,t), the 3D ADE can be broken up in three separate differential equations which can be solved individually. For C(x,t) the solution is given in Bear (1979), C(y,t) and C(z,t) can be derived from Crank (1975). The equation used for Anatrans is the combination of these solutions, with addition of source depletion, source superposition and instant reaction model, described in Newell et al. (1997) and implemented in the BIOSCREEN screening model. The solution of Newell et al. (1997) is based of the Domenico (1987) solution, a truncated version of the equation described above, which introduces an error with a size dependent on the ratio of flow velocity and longitudinal dispersivity. Anatrans instead uses the fully untruncated version.</p> <p>Bear, J. 1979. Hydraulics of Ground Water. New York: McGraw-Hill.</p> <p>Crank, J. 1975. The mathematics of Diffusion. New York: Oxford University Press.</p> <p>Domenico, P. A. (1987). An analytical model for multidimensional transport of a decaying contaminant species. Journal of Hydrology, 91(1-2), 49-58.</p> <p>Newell, C. J., McLeod, R. K., &amp; Gonzales, J. R. (1997). BIOSCREEN natural attenuation decision support system version 1.4 revisions, Tech. rep., U.S. EPA.</p> Source code in <code>mibitrans/transport/models.py</code> <pre><code>class Anatrans(Transport3D):\n    \"\"\"Model class using an analytical solution based on Bear (1979), Domenico (1987) &amp; Newell et al. (1997).\n\n    Under the assumption that C(x,y,z,t) = C(x,t) * C(y,t) * C(z,t), the 3D ADE can be broken up in three separate\n    differential equations which can be solved individually. For C(x,t) the solution is given in Bear (1979), C(y,t) and\n    C(z,t) can be derived from Crank (1975). The equation used for Anatrans is the combination of these solutions, with\n    addition of source depletion, source superposition and instant reaction model, described in Newell et al. (1997) and\n    implemented in the BIOSCREEN screening model. The solution of Newell et al. (1997) is based of the Domenico (1987)\n    solution, a truncated version of the equation described above, which introduces an error with a size dependent on\n    the ratio of flow velocity and longitudinal dispersivity. Anatrans instead uses the fully untruncated version.\n\n    Bear, J. 1979. Hydraulics of Ground Water. New York: McGraw-Hill.\n\n    Crank, J. 1975. The mathematics of Diffusion. New York: Oxford University Press.\n\n    Domenico, P. A. (1987). An analytical model for multidimensional transport of a decaying contaminant species.\n    Journal of Hydrology, 91(1-2), 49-58.\n\n    Newell, C. J., McLeod, R. K., &amp; Gonzales, J. R. (1997). BIOSCREEN natural attenuation decision support\n    system version 1.4 revisions, Tech. rep., U.S. EPA.\n    \"\"\"\n\n    def __init__(\n        self,\n        hydrological_parameters,\n        attenuation_parameters,\n        source_parameters,\n        model_parameters,\n        verbose=False,\n    ):\n        \"\"\"Initialize model object.\n\n        Args:\n            hydrological_parameters (mibitrans.data.parameters.HydrologicalParameters) : Dataclass object containing\n                hydrological parameters from HydrologicalParameters.\n            attenuation_parameters (mibitrans.data.read.AttenuationParameters) : Dataclass object containing adsorption,\n                degradation and diffusion parameters from AttenuationParameters.\n            source_parameters (mibitrans.data.read.SourceParameters) : Dataclass object containing source parameters\n                from SourceParameters.\n            model_parameters (mibitrans.data.read.ModelParameters) : Dataclass object containing model parameters from\n                ModelParameters.\n            verbose (bool, optional): Verbose mode. Defaults to False.\n\n        Attributes:\n            mode (str) : Current model mode. Is 'linear' by default. Once instant reaction parameters are provided. Use\n                this attribute to switch between 'linear' and 'instant_reaction' models.\n            cxyt (np.ndarray) : Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]\n            relative_cxyt (np.ndarray) : Output array with concentrations in model domain, divided by the maximum source\n                zone concentration at t=0. Indexed as [t,y,x].\n            x (np.ndarray) : Discretized model x-dimension, in [m].\n            y (np.ndarray) : Discretized model y-dimension, in [y].\n            t (np.ndarray) : Discretized model t-dimension, in [days].\n            c_source (np.ndarray) : Nett source zone concentrations, accounting for source superposition, in [g/m^3].\n            vr (float) : Retarded groundwater flow velocity, in [m/d].\n            k_source (float) : Source zone decay rate, in [1/days].\n            biodegradation_capacity (float) : Maximum capacity of biodegradation given provided electron acceptor\n            concentrations, in [g/m^3].\n\n        Methods:\n            run : Run model with current parameters, returns Results object.\n            sample : Calculate concentration at any given position and point in time.\n            instant_reaction : Activate the instant reaction model by providing electron acceptor concentrations. And\n                optionally electron acceptor utilization factors. Switch between model modes by using the mode\n                attribute.\n            centerline : Plot center of contaminant plume of this model, at a specified time and y position.\n            transverse : Plot concentration distribution as a line horizontal transverse to the plume extent.\n            breakthrough : Plot contaminant breakthrough curve at given x and y position in model domain.\n            plume_2d : Plot contaminant plume as a 2D colormesh, at a specified time.\n            plume_3d : Plot contaminant plume as a 3D surface, at a specified time.\n\n        Raises:\n            TypeError : If input is not of the correct Dataclass.\n\n        \"\"\"\n        super().__init__(hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose)\n        if self._att_pars.diffusion != 0:\n            warnings.warn(\"Domenico model does not consider molecular diffusion.\", UserWarning)\n\n    @property\n    def short_description(self):\n        \"\"\"Short description of model type.\"\"\"\n        return \"Anatrans model\"\n\n    def run(self):\n        \"\"\"Calculate the concentration for all discretized x, y and t using the analytical transport model.\"\"\"\n        self._check_model_mode_before_run()\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            self.cxyt = self._calculate_concentration_for_all_xyt(self.xxx, self.yyy, self.ttt)\n        return Results(self)\n\n    def sample(self, x_position, y_position, time):\n        \"\"\"Give concentration at any given position and point in time.\n\n        Args:\n            x_position (float): x position in domain extent [m].\n            y_position (float): y position in domain extent [m].\n            time (float): time for which concentration is sampled [days].\n\n        Returns:\n            concentration (float): concentration at given position and point in time [g/m^3].\n\n        \"\"\"\n        for par, value in locals().items():\n            if par != \"self\":\n                validate_input_values(par, value)\n\n        self._pre_run_initialization_parameters()\n\n        if self.mode == \"instant_reaction\":\n            save_c_noBC = self.cxyt_noBC.copy()\n        x = np.array([x_position])\n        y = np.array([y_position])\n        t = np.array([time])\n        concentration = self._calculate_concentration_for_all_xyt(x, y, t)[0]\n        if self.mode == \"instant_reaction\":\n            self.cxyt_noBC = save_c_noBC\n        return concentration\n\n    def _equation_term_x(self, xxx, ttt, decay_sqrt):\n        return np.exp(xxx * (1 - decay_sqrt) / (self._hyd_pars.alpha_x * 2)) * erfc(\n            (xxx - self.rv * ttt * decay_sqrt) / (2 * np.sqrt(self._hyd_pars.alpha_x * self.rv * ttt))\n        )\n\n    def _equation_term_additional_x(self, xxx, ttt, decay_sqrt):\n        erfc_inner = (xxx + decay_sqrt * self.rv * ttt) / (2 * np.sqrt(self._hyd_pars.alpha_x * self.rv * ttt))\n        # Additional term is prone to overflow of exp and underflow of erfc under certain parameter combinations.\n        # To decrease cases, used erfcx. Where erfcx(a) = exp(a**2)*erfc(a) -&gt; exp(b)*erfc(a) = exp(b - a**2) * erfcx(a)\n        term = np.exp(xxx * (1 + decay_sqrt) * (1 / 2) / self._hyd_pars.alpha_x - erfc_inner**2) * erfcx(erfc_inner)\n        return term\n\n    def _equation_term_z(self, xxx):\n        inner_term = self._src_pars.depth / (2 * np.sqrt(self._hyd_pars.alpha_z * xxx))\n        return erf(inner_term) - erf(-inner_term)\n\n    def _equation_term_source_decay(self, xxx, ttt):\n        term = np.exp(-self.k_source * (ttt - xxx / self.rv))\n        # Term can be max 1; can not have 'generation' of solute ahead of advection.\n        return np.where(term &gt; 1, 1, term)\n\n    def _equation_term_y(self, i, xxx, yyy):\n        div_term = 2 * np.sqrt(self._hyd_pars.alpha_y * xxx)\n        term = erf((yyy + self.y_source[i]) / div_term) - erf((yyy - self.y_source[i]) / div_term)\n        term[np.isnan(term)] = 0\n        return term\n\n    def _calculate_concentration_for_all_xyt(self, xxx, yyy, ttt):\n        cxyt = 0\n        decay_sqrt = np.sqrt(1 + 4 * self._decay_rate * self._hyd_pars.alpha_x / self.rv)\n        x_term = self._equation_term_x(xxx, ttt, decay_sqrt)\n        additional_x = self._equation_term_additional_x(xxx, ttt, decay_sqrt)\n        z_term = self._equation_term_z(xxx)\n        source_decay = self._equation_term_source_decay(xxx, ttt)\n        for i in range(len(self.c_source)):\n            y_term = self._equation_term_y(i, xxx, yyy)\n            cxyt_step = 1 / 8 * self.c_source[i] * source_decay * (x_term + additional_x) * y_term * z_term\n            cxyt += cxyt_step\n        if self._mode == \"instant_reaction\":\n            self.cxyt_noBC = cxyt.copy()\n            cxyt -= self.biodegradation_capacity\n            cxyt = np.where(cxyt &lt; 0, 0, cxyt)\n        self.has_run = True\n        return cxyt\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.models.Anatrans.short_description","title":"<code>short_description</code>  <code>property</code>","text":"<p>Short description of model type.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.models.Anatrans.__init__","title":"<code>__init__(hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose=False)</code>","text":"<p>Initialize model object.</p> <p>Parameters:</p> Name Type Description Default <code>hydrological_parameters (mibitrans.data.parameters.HydrologicalParameters) </code> <p>Dataclass object containing hydrological parameters from HydrologicalParameters.</p> required <code>attenuation_parameters (mibitrans.data.read.AttenuationParameters) </code> <p>Dataclass object containing adsorption, degradation and diffusion parameters from AttenuationParameters.</p> required <code>source_parameters (mibitrans.data.read.SourceParameters) </code> <p>Dataclass object containing source parameters from SourceParameters.</p> required <code>model_parameters (mibitrans.data.read.ModelParameters) </code> <p>Dataclass object containing model parameters from ModelParameters.</p> required <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>mode</code> <code>str) </code> <p>Current model mode. Is \u2018linear\u2019 by default. Once instant reaction parameters are provided. Use this attribute to switch between \u2018linear\u2019 and \u2018instant_reaction\u2019 models.</p> <code>cxyt</code> <code>np.ndarray) </code> <p>Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]</p> <code>relative_cxyt</code> <code>np.ndarray) </code> <p>Output array with concentrations in model domain, divided by the maximum source zone concentration at t=0. Indexed as [t,y,x].</p> <code>x</code> <code>np.ndarray) </code> <p>Discretized model x-dimension, in [m].</p> <code>y</code> <code>np.ndarray) </code> <p>Discretized model y-dimension, in [y].</p> <code>t</code> <code>np.ndarray) </code> <p>Discretized model t-dimension, in [days].</p> <code>c_source</code> <code>np.ndarray) </code> <p>Nett source zone concentrations, accounting for source superposition, in [g/m^3].</p> <code>vr</code> <code>float) </code> <p>Retarded groundwater flow velocity, in [m/d].</p> <code>k_source</code> <code>float) </code> <p>Source zone decay rate, in [1/days].</p> <code>biodegradation_capacity</code> <code>float) </code> <p>Maximum capacity of biodegradation given provided electron acceptor</p> <p>Functions:</p> Name Description <code>run </code> <p>Run model with current parameters, returns Results object.</p> <code>sample </code> <p>Calculate concentration at any given position and point in time.</p> <code>instant_reaction </code> <p>Activate the instant reaction model by providing electron acceptor concentrations. And optionally electron acceptor utilization factors. Switch between model modes by using the mode attribute.</p> <code>centerline </code> <p>Plot center of contaminant plume of this model, at a specified time and y position.</p> <code>transverse </code> <p>Plot concentration distribution as a line horizontal transverse to the plume extent.</p> <code>breakthrough </code> <p>Plot contaminant breakthrough curve at given x and y position in model domain.</p> <code>plume_2d </code> <p>Plot contaminant plume as a 2D colormesh, at a specified time.</p> <code>plume_3d </code> <p>Plot contaminant plume as a 3D surface, at a specified time.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input is not of the correct Dataclass.</p> Source code in <code>mibitrans/transport/models.py</code> <pre><code>def __init__(\n    self,\n    hydrological_parameters,\n    attenuation_parameters,\n    source_parameters,\n    model_parameters,\n    verbose=False,\n):\n    \"\"\"Initialize model object.\n\n    Args:\n        hydrological_parameters (mibitrans.data.parameters.HydrologicalParameters) : Dataclass object containing\n            hydrological parameters from HydrologicalParameters.\n        attenuation_parameters (mibitrans.data.read.AttenuationParameters) : Dataclass object containing adsorption,\n            degradation and diffusion parameters from AttenuationParameters.\n        source_parameters (mibitrans.data.read.SourceParameters) : Dataclass object containing source parameters\n            from SourceParameters.\n        model_parameters (mibitrans.data.read.ModelParameters) : Dataclass object containing model parameters from\n            ModelParameters.\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Attributes:\n        mode (str) : Current model mode. Is 'linear' by default. Once instant reaction parameters are provided. Use\n            this attribute to switch between 'linear' and 'instant_reaction' models.\n        cxyt (np.ndarray) : Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]\n        relative_cxyt (np.ndarray) : Output array with concentrations in model domain, divided by the maximum source\n            zone concentration at t=0. Indexed as [t,y,x].\n        x (np.ndarray) : Discretized model x-dimension, in [m].\n        y (np.ndarray) : Discretized model y-dimension, in [y].\n        t (np.ndarray) : Discretized model t-dimension, in [days].\n        c_source (np.ndarray) : Nett source zone concentrations, accounting for source superposition, in [g/m^3].\n        vr (float) : Retarded groundwater flow velocity, in [m/d].\n        k_source (float) : Source zone decay rate, in [1/days].\n        biodegradation_capacity (float) : Maximum capacity of biodegradation given provided electron acceptor\n        concentrations, in [g/m^3].\n\n    Methods:\n        run : Run model with current parameters, returns Results object.\n        sample : Calculate concentration at any given position and point in time.\n        instant_reaction : Activate the instant reaction model by providing electron acceptor concentrations. And\n            optionally electron acceptor utilization factors. Switch between model modes by using the mode\n            attribute.\n        centerline : Plot center of contaminant plume of this model, at a specified time and y position.\n        transverse : Plot concentration distribution as a line horizontal transverse to the plume extent.\n        breakthrough : Plot contaminant breakthrough curve at given x and y position in model domain.\n        plume_2d : Plot contaminant plume as a 2D colormesh, at a specified time.\n        plume_3d : Plot contaminant plume as a 3D surface, at a specified time.\n\n    Raises:\n        TypeError : If input is not of the correct Dataclass.\n\n    \"\"\"\n    super().__init__(hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose)\n    if self._att_pars.diffusion != 0:\n        warnings.warn(\"Domenico model does not consider molecular diffusion.\", UserWarning)\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.models.Anatrans.run","title":"<code>run()</code>","text":"<p>Calculate the concentration for all discretized x, y and t using the analytical transport model.</p> Source code in <code>mibitrans/transport/models.py</code> <pre><code>def run(self):\n    \"\"\"Calculate the concentration for all discretized x, y and t using the analytical transport model.\"\"\"\n    self._check_model_mode_before_run()\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        self.cxyt = self._calculate_concentration_for_all_xyt(self.xxx, self.yyy, self.ttt)\n    return Results(self)\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.models.Anatrans.sample","title":"<code>sample(x_position, y_position, time)</code>","text":"<p>Give concentration at any given position and point in time.</p> <p>Parameters:</p> Name Type Description Default <code>x_position</code> <code>float</code> <p>x position in domain extent [m].</p> required <code>y_position</code> <code>float</code> <p>y position in domain extent [m].</p> required <code>time</code> <code>float</code> <p>time for which concentration is sampled [days].</p> required <p>Returns:</p> Name Type Description <code>concentration</code> <code>float</code> <p>concentration at given position and point in time [g/m^3].</p> Source code in <code>mibitrans/transport/models.py</code> <pre><code>def sample(self, x_position, y_position, time):\n    \"\"\"Give concentration at any given position and point in time.\n\n    Args:\n        x_position (float): x position in domain extent [m].\n        y_position (float): y position in domain extent [m].\n        time (float): time for which concentration is sampled [days].\n\n    Returns:\n        concentration (float): concentration at given position and point in time [g/m^3].\n\n    \"\"\"\n    for par, value in locals().items():\n        if par != \"self\":\n            validate_input_values(par, value)\n\n    self._pre_run_initialization_parameters()\n\n    if self.mode == \"instant_reaction\":\n        save_c_noBC = self.cxyt_noBC.copy()\n    x = np.array([x_position])\n    y = np.array([y_position])\n    t = np.array([time])\n    concentration = self._calculate_concentration_for_all_xyt(x, y, t)[0]\n    if self.mode == \"instant_reaction\":\n        self.cxyt_noBC = save_c_noBC\n    return concentration\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.models.Bioscreen","title":"<code>Bioscreen</code>","text":"<p>               Bases: <code>Anatrans</code></p> <p>Model class using the analytical solution implemented in the BIOSCREEN screening model, Newell et al. (1997).</p> <p>This model is an exact implementation of the transport equations implemented in the BIOSCREEN screening model of Newell et al. (1997), which is based on the Domenico (1987) analytical model. Using a truncated version of the equation used in the Anatrans model. This model is implemented as a method of comparison with the original BIOSCREEN software. And is included for legacy reasons, since it is the first model implemented in the mibitrans package, serving as a basis for the other models. However, caution should be taken when using this model, since a varying error is introduced by using the truncated analytical solution. The error is most prominent for shorter times and distances from the source, and depends on the ratio of flow velocity and longitudinal dispersivity. For modelling, the Anatrans (untruncated approximate solution) and Mibitrans (exact analytical solution) models are recommended instead.</p> <p>Domenico, P. A. (1987). An analytical model for multidimensional transport of a decaying contaminant species. Journal of Hydrology, 91(1-2), 49-58.</p> <p>Newell, C. J., McLeod, R. K., &amp; Gonzales, J. R. (1997). BIOSCREEN natural attenuation decision support system version 1.4 revisions, Tech. rep., U.S. EPA.</p> Source code in <code>mibitrans/transport/models.py</code> <pre><code>class Bioscreen(Anatrans):\n    \"\"\"Model class using the analytical solution implemented in the BIOSCREEN screening model, Newell et al. (1997).\n\n    This model is an exact implementation of the transport equations implemented in the BIOSCREEN screening model of\n    Newell et al. (1997), which is based on the Domenico (1987) analytical model. Using a truncated version of the\n    equation used in the Anatrans model. This model is implemented as a method of comparison with the original BIOSCREEN\n    software. And is included for legacy reasons, since it is the first model implemented in the mibitrans package,\n    serving as a basis for the other models. However, caution should be taken when using this model, since a varying\n    error is introduced by using the truncated analytical solution. The error is most prominent for shorter times and\n    distances from the source, and depends on the ratio of flow velocity and longitudinal dispersivity. For modelling,\n    the Anatrans (untruncated approximate solution) and Mibitrans (exact analytical solution) models are recommended\n    instead.\n\n    Domenico, P. A. (1987). An analytical model for multidimensional transport of a decaying contaminant species.\n    Journal of Hydrology, 91(1-2), 49-58.\n\n    Newell, C. J., McLeod, R. K., &amp; Gonzales, J. R. (1997). BIOSCREEN natural attenuation decision support\n    system version 1.4 revisions, Tech. rep., U.S. EPA.\n    \"\"\"\n\n    def __init__(\n        self,\n        hydrological_parameters,\n        attenuation_parameters,\n        source_parameters,\n        model_parameters,\n        verbose=False,\n    ):\n        \"\"\"Initialize model object.\n\n        Args:\n            hydrological_parameters (mibitrans.data.parameters.HydrologicalParameters) : Dataclass object containing\n                hydrological parameters from HydrologicalParameters.\n            attenuation_parameters (mibitrans.data.read.AttenuationParameters) : Dataclass object containing adsorption,\n                degradation and diffusion parameters from AttenuationParameters.\n            source_parameters (mibitrans.data.read.SourceParameters) : Dataclass object containing source parameters\n                from SourceParameters.\n            model_parameters (mibitrans.data.read.ModelParameters) : Dataclass object containing model parameters from\n                ModelParameters.\n            verbose (bool, optional): Verbose mode. Defaults to False.\n\n        Attributes:\n            mode (str) : Current model mode. Is 'linear' by default. Once instant reaction parameters are provided. Use\n                this attribute to switch between 'linear' and 'instant_reaction' models.\n            cxyt (np.ndarray) : Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]\n            relative_cxyt (np.ndarray) : Output array with concentrations in model domain, divided by the maximum source\n                zone concentration at t=0. Indexed as [t,y,x].\n            x (np.ndarray) : Discretized model x-dimension, in [m].\n            y (np.ndarray) : Discretized model y-dimension, in [y].\n            t (np.ndarray) : Discretized model t-dimension, in [days].\n            c_source (np.ndarray) : Nett source zone concentrations, accounting for source superposition, in [g/m^3].\n            vr (float) : Retarded groundwater flow velocity, in [m/d].\n            k_source (float) : Source zone decay rate, in [1/days].\n            biodegradation_capacity (float) : Maximum capacity of biodegradation given provided electron acceptor\n            concentrations, in [g/m^3].\n\n        Methods:\n            run : Run model with current parameters, returns Results object.\n            sample : Calculate concentration at any given position and point in time.\n            instant_reaction : Activate the instant reaction model by providing electron acceptor concentrations. And\n                optionally electron acceptor utilization factors. Switch between model modes by using the mode\n                attribute.\n\n        Raises:\n            TypeError : If input is not of the correct Dataclass.\n\n        \"\"\"\n        super().__init__(hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose)\n\n    @property\n    def short_description(self):\n        \"\"\"Short description of model type.\"\"\"\n        return \"Bioscreen model\"\n\n    def _calculate_concentration_for_all_xyt(self, xxx, yyy, ttt):\n        # Difference with the Anatrans solution is the lack of additional term.\n        cxyt = 0\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            decay_sqrt = np.sqrt(1 + 4 * self._decay_rate * self._hyd_pars.alpha_x / self.rv)\n            x_term = self._equation_term_x(xxx, ttt, decay_sqrt)\n            z_term = self._equation_term_z(xxx)\n            source_decay = self._equation_term_source_decay(xxx, ttt)\n            for i in range(len(self.c_source)):\n                y_term = self._equation_term_y(i, xxx, yyy)\n                cxyt_step = 1 / 8 * self.c_source[i] * source_decay * x_term * y_term * z_term\n                cxyt += cxyt_step\n        if self._mode == \"instant_reaction\":\n            self.cxyt_noBC = cxyt.copy()\n            cxyt -= self.biodegradation_capacity\n            cxyt = np.where(cxyt &lt; 0, 0, cxyt)\n        self.has_run = True\n        return cxyt\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.models.Bioscreen.short_description","title":"<code>short_description</code>  <code>property</code>","text":"<p>Short description of model type.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.models.Bioscreen.__init__","title":"<code>__init__(hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose=False)</code>","text":"<p>Initialize model object.</p> <p>Parameters:</p> Name Type Description Default <code>hydrological_parameters (mibitrans.data.parameters.HydrologicalParameters) </code> <p>Dataclass object containing hydrological parameters from HydrologicalParameters.</p> required <code>attenuation_parameters (mibitrans.data.read.AttenuationParameters) </code> <p>Dataclass object containing adsorption, degradation and diffusion parameters from AttenuationParameters.</p> required <code>source_parameters (mibitrans.data.read.SourceParameters) </code> <p>Dataclass object containing source parameters from SourceParameters.</p> required <code>model_parameters (mibitrans.data.read.ModelParameters) </code> <p>Dataclass object containing model parameters from ModelParameters.</p> required <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>mode</code> <code>str) </code> <p>Current model mode. Is \u2018linear\u2019 by default. Once instant reaction parameters are provided. Use this attribute to switch between \u2018linear\u2019 and \u2018instant_reaction\u2019 models.</p> <code>cxyt</code> <code>np.ndarray) </code> <p>Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]</p> <code>relative_cxyt</code> <code>np.ndarray) </code> <p>Output array with concentrations in model domain, divided by the maximum source zone concentration at t=0. Indexed as [t,y,x].</p> <code>x</code> <code>np.ndarray) </code> <p>Discretized model x-dimension, in [m].</p> <code>y</code> <code>np.ndarray) </code> <p>Discretized model y-dimension, in [y].</p> <code>t</code> <code>np.ndarray) </code> <p>Discretized model t-dimension, in [days].</p> <code>c_source</code> <code>np.ndarray) </code> <p>Nett source zone concentrations, accounting for source superposition, in [g/m^3].</p> <code>vr</code> <code>float) </code> <p>Retarded groundwater flow velocity, in [m/d].</p> <code>k_source</code> <code>float) </code> <p>Source zone decay rate, in [1/days].</p> <code>biodegradation_capacity</code> <code>float) </code> <p>Maximum capacity of biodegradation given provided electron acceptor</p> <p>Functions:</p> Name Description <code>run </code> <p>Run model with current parameters, returns Results object.</p> <code>sample </code> <p>Calculate concentration at any given position and point in time.</p> <code>instant_reaction </code> <p>Activate the instant reaction model by providing electron acceptor concentrations. And optionally electron acceptor utilization factors. Switch between model modes by using the mode attribute.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input is not of the correct Dataclass.</p> Source code in <code>mibitrans/transport/models.py</code> <pre><code>def __init__(\n    self,\n    hydrological_parameters,\n    attenuation_parameters,\n    source_parameters,\n    model_parameters,\n    verbose=False,\n):\n    \"\"\"Initialize model object.\n\n    Args:\n        hydrological_parameters (mibitrans.data.parameters.HydrologicalParameters) : Dataclass object containing\n            hydrological parameters from HydrologicalParameters.\n        attenuation_parameters (mibitrans.data.read.AttenuationParameters) : Dataclass object containing adsorption,\n            degradation and diffusion parameters from AttenuationParameters.\n        source_parameters (mibitrans.data.read.SourceParameters) : Dataclass object containing source parameters\n            from SourceParameters.\n        model_parameters (mibitrans.data.read.ModelParameters) : Dataclass object containing model parameters from\n            ModelParameters.\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Attributes:\n        mode (str) : Current model mode. Is 'linear' by default. Once instant reaction parameters are provided. Use\n            this attribute to switch between 'linear' and 'instant_reaction' models.\n        cxyt (np.ndarray) : Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]\n        relative_cxyt (np.ndarray) : Output array with concentrations in model domain, divided by the maximum source\n            zone concentration at t=0. Indexed as [t,y,x].\n        x (np.ndarray) : Discretized model x-dimension, in [m].\n        y (np.ndarray) : Discretized model y-dimension, in [y].\n        t (np.ndarray) : Discretized model t-dimension, in [days].\n        c_source (np.ndarray) : Nett source zone concentrations, accounting for source superposition, in [g/m^3].\n        vr (float) : Retarded groundwater flow velocity, in [m/d].\n        k_source (float) : Source zone decay rate, in [1/days].\n        biodegradation_capacity (float) : Maximum capacity of biodegradation given provided electron acceptor\n        concentrations, in [g/m^3].\n\n    Methods:\n        run : Run model with current parameters, returns Results object.\n        sample : Calculate concentration at any given position and point in time.\n        instant_reaction : Activate the instant reaction model by providing electron acceptor concentrations. And\n            optionally electron acceptor utilization factors. Switch between model modes by using the mode\n            attribute.\n\n    Raises:\n        TypeError : If input is not of the correct Dataclass.\n\n    \"\"\"\n    super().__init__(hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose)\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.models.Mibitrans","title":"<code>Mibitrans</code>","text":"<p>               Bases: <code>Transport3D</code></p> <p>Model class using an exact analytical solution as described in Karanovic (2007), based on Wexler (1992).</p> <p>Karanovic (2007) implemented the Wexler (1992) exact analytical solution in the Excel based BIOSCREEN-AT, and added source depletion, akin to that implemented in its predecessor BIOSCREEN by Newell et al. (1997). The Mibitrans model allows for the same method as used in BIOSCREEN-AT, but expands it by allowing multiple source zones (by means of superposition) and including the instant reaction model. These were present in the original BIOSCREEN, but not reimplemented in BIOSCREEN-AT. Using a single source zone in this model, and not using the instant reaction option will make the Mibitrans solution resolve to the equation described in Karanovic (2007). Which in turn resolves to the Wexler (1992) solution if source depletion is disabled.</p> <p>Karanovic, M., Neville, C. J., &amp; Andrews, C. B. (2007). BIOSCREEN\u2010AT: BIOSCREEN with an exact analytical solution. Groundwater, 45(2), 242-245.</p> <p>Newell, C. J., McLeod, R. K., &amp; Gonzales, J. R. (1997). BIOSCREEN natural attenuation decision support system version 1.4 revisions, Tech. rep., U.S. EPA.</p> <p>Wexler, E. J. (1992). Analytical solutions for one-, two-, and three-dimensional solute transport in ground-water systems with uniform flow. US Government Printing Office.</p> Source code in <code>mibitrans/transport/models.py</code> <pre><code>class Mibitrans(Transport3D):\n    \"\"\"Model class using an exact analytical solution as described in Karanovic (2007), based on Wexler (1992).\n\n    Karanovic (2007) implemented the Wexler (1992) exact analytical solution in the Excel based BIOSCREEN-AT, and added\n    source depletion, akin to that implemented in its predecessor BIOSCREEN by Newell et al. (1997). The Mibitrans model\n    allows for the same method as used in BIOSCREEN-AT, but expands it by allowing multiple source zones (by means of\n    superposition) and including the instant reaction model. These were present in the original BIOSCREEN, but not\n    reimplemented in BIOSCREEN-AT. Using a single source zone in this model, and not using the instant reaction option\n    will make the Mibitrans solution resolve to the equation described in Karanovic (2007). Which in turn resolves to\n    the Wexler (1992) solution if source depletion is disabled.\n\n    Karanovic, M., Neville, C. J., &amp; Andrews, C. B. (2007). BIOSCREEN\u2010AT: BIOSCREEN with an exact analytical solution.\n    Groundwater, 45(2), 242-245.\n\n    Newell, C. J., McLeod, R. K., &amp; Gonzales, J. R. (1997). BIOSCREEN natural attenuation decision support\n    system version 1.4 revisions, Tech. rep., U.S. EPA.\n\n    Wexler, E. J. (1992). Analytical solutions for one-, two-, and three-dimensional solute transport in ground-water\n    systems with uniform flow. US Government Printing Office.\n    \"\"\"\n\n    def __init__(\n        self,\n        hydrological_parameters,\n        attenuation_parameters,\n        source_parameters,\n        model_parameters,\n        verbose=False,\n    ):\n        \"\"\"Initialize model object.\n\n        Args:\n            hydrological_parameters (mibitrans.data.parameters.HydrologicalParameters) : Dataclass object containing\n                hydrological parameters from HydrologicalParameters.\n            attenuation_parameters (mibitrans.data.read.AttenuationParameters) : Dataclass object containing adsorption,\n                degradation and diffusion parameters from AttenuationParameters.\n            source_parameters (mibitrans.data.read.SourceParameters) : Dataclass object containing source parameters\n                from SourceParameters.\n            model_parameters (mibitrans.data.read.ModelParameters) : Dataclass object containing model parameters from\n                ModelParameters.\n            verbose (bool, optional): Verbose mode. Defaults to False.\n\n        Attributes:\n            mode (str) : Current model mode. Is 'linear' by default. Once instant reaction parameters are provided. Use\n                this attribute to switch between 'linear' and 'instant_reaction' models.\n            cxyt (np.ndarray) : Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]\n            relative_cxyt (np.ndarray) : Output array with concentrations in model domain, divided by the maximum source\n                zone concentration at t=0. Indexed as [t,y,x].\n            x (np.ndarray) : Discretized model x-dimension, in [m].\n            y (np.ndarray) : Discretized model y-dimension, in [y].\n            t (np.ndarray) : Discretized model t-dimension, in [days].\n            c_source (np.ndarray) : Nett source zone concentrations, accounting for source superposition, in [g/m^3].\n            vr (float) : Retarded groundwater flow velocity, in [m/d].\n            k_source (float) : Source zone decay rate, in [1/days].\n            biodegradation_capacity (float) : Maximum capacity of biodegradation given provided electron acceptor\n            concentrations, in [g/m^3].\n\n        Methods:\n            run : Run model with current parameters, returns Results object.\n            sample : Calculate concentration at any given position and point in time.\n            instant_reaction : Activate the instant reaction model by providing electron acceptor concentrations. And\n                optionally electron acceptor utilization factors. Switch between model modes by using the mode\n                attribute.\n\n        Raises:\n            TypeError : If input is not of the correct Dataclass.\n\n        \"\"\"\n        super().__init__(hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose)\n\n    @property\n    def short_description(self):\n        \"\"\"Return short description of model type.\"\"\"\n        if self.biodegradation_capacity:\n            return \"Mibitrans Instant Reaction\"\n        else:\n            return \"Mibitrans Linear\"\n\n    def run(self):\n        \"\"\"Calculate the concentration for all discretized x, y and t using the analytical transport model.\"\"\"\n        self._check_model_mode_before_run()\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            self.cxyt = self._calculate_concentration_for_all_xyt()\n        return Results(self)\n\n    def sample(self, x_position, y_position, time):\n        \"\"\"Give concentration at any given position and point in time.\n\n        Args:\n            x_position (float): x position in domain extent [m].\n            y_position (float): y position in domain extent [m].\n            time (float): time for which concentration is sampled [days].\n\n        Returns:\n            concentration (float): concentration at given position and point in time [g/m^3].\n\n        \"\"\"\n        # Different sample method than parent class, as field-wide calculations use array indices\n        for par, value in locals().items():\n            if par != \"self\":\n                validate_input_values(par, value)\n\n        self._pre_run_initialization_parameters()\n\n        def integrand(t, sz):\n            div_term = 2 * np.sqrt(self.disp_y * t**4)\n            inner_term = self._src_pars.depth / (2 * np.sqrt(self.disp_z * t**4))\n            integrand_results = (\n                1\n                / (t**3)\n                * (\n                    np.exp(\n                        (-self.k_source - self._decay_rate) * t**4\n                        - (x_position - self.rv * t**4) ** 2 / (4 * self.disp_x * t**4)\n                    )\n                    * (\n                        erfc((y_position - self.y_source[sz]) / div_term)\n                        - erfc((y_position + self.y_source[sz]) / div_term)\n                    )\n                    * (erfc(-inner_term) - erfc(inner_term))\n                )\n            )\n            return integrand_results\n\n        conc_array = np.zeros(len(self.c_source))\n        error_array = np.zeros(len(self.c_source))\n        time = time ** (1 / 4)\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            for sz in range(len(self.c_source)):\n                integral_term, error = quad(integrand, 0, time, limit=10000, args=(sz,))\n                source_term = (\n                    self.c_source[sz] * x_position / (8 * np.sqrt(np.pi * self.disp_x)) * np.exp(-self.k_source * time)\n                )\n                conc_array[sz] = 4 * integral_term * source_term\n                error_array[sz] = error\n            concentration = np.sum(conc_array)\n            if self._mode == \"instant_reaction\":\n                concentration -= self.biodegradation_capacity\n                if concentration &lt; 0:\n                    concentration = 0\n        return concentration\n\n    def _pre_run_initialization_parameters(self):\n        super()._pre_run_initialization_parameters()\n        self.disp_x = self._hyd_pars.alpha_x * self.rv + self._att_pars.diffusion\n        self.disp_y = self._hyd_pars.alpha_y * self.rv + self._att_pars.diffusion\n        self.disp_z = self._hyd_pars.alpha_z * self.rv + self._att_pars.diffusion\n        # self.integral_term = np.zeros(self.ttt.shape)\n        # Stores integral error for each time step and source zone\n        self.error_size = np.zeros((len(self._src_pars.source_zone_boundary), len(self.t)))\n\n    def _calculate_concentration_for_all_xyt(self):\n        cxyt = self.cxyt.copy()\n        for sz in range(len(self.c_source)):\n            integral_sum = self._equation_term_integral(sz)\n            source_term = self._equation_term_source(sz)\n            cxyt[:, :, 1:] += integral_sum[:, :, 1:] * source_term\n            # If x=0, equation resolves to c=0, therefore, x=0 needs to be evaluated separately\n            cxyt[:, :, 0] += self._equation_term_source_x_is_zero(sz)[:, :, 0]\n        if self._mode == \"instant_reaction\":\n            self.cxyt_noBC = cxyt.copy()\n            cxyt -= self.biodegradation_capacity\n            cxyt = np.where(cxyt &lt; 0, 0, cxyt)\n        return cxyt\n\n    def _equation_term_integral(self, sz):\n        integral_term = np.zeros(self.cxyt.shape)\n        for j in range(len(self.t)):\n            if self.verbose:\n                print(\"integrating for source zone \", sz, \" and t =\", self.t[j], \"days\")\n            if j == 0:\n                lower_bound = 0\n            else:\n                lower_bound = self.t[j - 1]\n            upper_bound = self.t[j]\n            integral_term[j, :, 1:], self.error_size[sz, j] = quad_vec(\n                self._equation_integrand, lower_bound, upper_bound, limit=10000 // len(self.t), args=(sz,)\n            )\n        integral_sum = np.cumsum(integral_term, axis=0)\n        return integral_sum\n\n    def _equation_integrand(self, t, sz):\n        term = 1 / (t ** (3 / 2)) * self._equation_term_x(t) * self._equation_term_y(t, sz) * self._equation_term_z(t)\n        term[np.isnan(term)] = 0\n        return term\n\n    def _equation_term_x(self, t):\n        term = np.exp(\n            (-self.k_source - self._decay_rate) * t - (self.xxx[:, :, 1:] - self.rv * t) ** 2 / (4 * self.disp_x * t)\n        )\n        term[np.isnan(term)] = 0\n        return term\n\n    def _equation_term_y(self, t, sz):\n        div_term = 2 * np.sqrt(self.disp_y * t)\n        term = erfc((self.yyy - self.y_source[sz]) / div_term) - erfc((self.yyy + self.y_source[sz]) / div_term)\n        term[np.isnan(term)] = 0\n        return term\n\n    def _equation_term_z(self, t):\n        if t == 0 or self.disp_z == 0:\n            inner_term = 2\n        else:\n            inner_term = self._src_pars.depth / (2 * np.sqrt(self.disp_z * t))\n        return erfc(-inner_term) - erfc(inner_term)\n\n    def _equation_term_source(self, sz):\n        return (\n            self.c_source[sz]\n            * self.xxx[:, :, 1:]\n            / (8 * np.sqrt(np.pi * self.disp_x))\n            * np.exp(-self.k_source * self.ttt)\n        )\n\n    def _equation_term_source_x_is_zero(self, sz):\n        # Select y-positions of current source zone\n        zone_location = np.where(abs(self.yyy) &lt;= self.y_source[sz], 1, 0)\n        return self.c_source[sz] * zone_location * np.exp(-self.k_source * self.ttt)\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.models.Mibitrans.short_description","title":"<code>short_description</code>  <code>property</code>","text":"<p>Return short description of model type.</p>"},{"location":"reference/reference_transport/#mibitrans.transport.models.Mibitrans.__init__","title":"<code>__init__(hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose=False)</code>","text":"<p>Initialize model object.</p> <p>Parameters:</p> Name Type Description Default <code>hydrological_parameters (mibitrans.data.parameters.HydrologicalParameters) </code> <p>Dataclass object containing hydrological parameters from HydrologicalParameters.</p> required <code>attenuation_parameters (mibitrans.data.read.AttenuationParameters) </code> <p>Dataclass object containing adsorption, degradation and diffusion parameters from AttenuationParameters.</p> required <code>source_parameters (mibitrans.data.read.SourceParameters) </code> <p>Dataclass object containing source parameters from SourceParameters.</p> required <code>model_parameters (mibitrans.data.read.ModelParameters) </code> <p>Dataclass object containing model parameters from ModelParameters.</p> required <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>mode</code> <code>str) </code> <p>Current model mode. Is \u2018linear\u2019 by default. Once instant reaction parameters are provided. Use this attribute to switch between \u2018linear\u2019 and \u2018instant_reaction\u2019 models.</p> <code>cxyt</code> <code>np.ndarray) </code> <p>Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]</p> <code>relative_cxyt</code> <code>np.ndarray) </code> <p>Output array with concentrations in model domain, divided by the maximum source zone concentration at t=0. Indexed as [t,y,x].</p> <code>x</code> <code>np.ndarray) </code> <p>Discretized model x-dimension, in [m].</p> <code>y</code> <code>np.ndarray) </code> <p>Discretized model y-dimension, in [y].</p> <code>t</code> <code>np.ndarray) </code> <p>Discretized model t-dimension, in [days].</p> <code>c_source</code> <code>np.ndarray) </code> <p>Nett source zone concentrations, accounting for source superposition, in [g/m^3].</p> <code>vr</code> <code>float) </code> <p>Retarded groundwater flow velocity, in [m/d].</p> <code>k_source</code> <code>float) </code> <p>Source zone decay rate, in [1/days].</p> <code>biodegradation_capacity</code> <code>float) </code> <p>Maximum capacity of biodegradation given provided electron acceptor</p> <p>Functions:</p> Name Description <code>run </code> <p>Run model with current parameters, returns Results object.</p> <code>sample </code> <p>Calculate concentration at any given position and point in time.</p> <code>instant_reaction </code> <p>Activate the instant reaction model by providing electron acceptor concentrations. And optionally electron acceptor utilization factors. Switch between model modes by using the mode attribute.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input is not of the correct Dataclass.</p> Source code in <code>mibitrans/transport/models.py</code> <pre><code>def __init__(\n    self,\n    hydrological_parameters,\n    attenuation_parameters,\n    source_parameters,\n    model_parameters,\n    verbose=False,\n):\n    \"\"\"Initialize model object.\n\n    Args:\n        hydrological_parameters (mibitrans.data.parameters.HydrologicalParameters) : Dataclass object containing\n            hydrological parameters from HydrologicalParameters.\n        attenuation_parameters (mibitrans.data.read.AttenuationParameters) : Dataclass object containing adsorption,\n            degradation and diffusion parameters from AttenuationParameters.\n        source_parameters (mibitrans.data.read.SourceParameters) : Dataclass object containing source parameters\n            from SourceParameters.\n        model_parameters (mibitrans.data.read.ModelParameters) : Dataclass object containing model parameters from\n            ModelParameters.\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Attributes:\n        mode (str) : Current model mode. Is 'linear' by default. Once instant reaction parameters are provided. Use\n            this attribute to switch between 'linear' and 'instant_reaction' models.\n        cxyt (np.ndarray) : Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]\n        relative_cxyt (np.ndarray) : Output array with concentrations in model domain, divided by the maximum source\n            zone concentration at t=0. Indexed as [t,y,x].\n        x (np.ndarray) : Discretized model x-dimension, in [m].\n        y (np.ndarray) : Discretized model y-dimension, in [y].\n        t (np.ndarray) : Discretized model t-dimension, in [days].\n        c_source (np.ndarray) : Nett source zone concentrations, accounting for source superposition, in [g/m^3].\n        vr (float) : Retarded groundwater flow velocity, in [m/d].\n        k_source (float) : Source zone decay rate, in [1/days].\n        biodegradation_capacity (float) : Maximum capacity of biodegradation given provided electron acceptor\n        concentrations, in [g/m^3].\n\n    Methods:\n        run : Run model with current parameters, returns Results object.\n        sample : Calculate concentration at any given position and point in time.\n        instant_reaction : Activate the instant reaction model by providing electron acceptor concentrations. And\n            optionally electron acceptor utilization factors. Switch between model modes by using the mode\n            attribute.\n\n    Raises:\n        TypeError : If input is not of the correct Dataclass.\n\n    \"\"\"\n    super().__init__(hydrological_parameters, attenuation_parameters, source_parameters, model_parameters, verbose)\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.models.Mibitrans.run","title":"<code>run()</code>","text":"<p>Calculate the concentration for all discretized x, y and t using the analytical transport model.</p> Source code in <code>mibitrans/transport/models.py</code> <pre><code>def run(self):\n    \"\"\"Calculate the concentration for all discretized x, y and t using the analytical transport model.\"\"\"\n    self._check_model_mode_before_run()\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        self.cxyt = self._calculate_concentration_for_all_xyt()\n    return Results(self)\n</code></pre>"},{"location":"reference/reference_transport/#mibitrans.transport.models.Mibitrans.sample","title":"<code>sample(x_position, y_position, time)</code>","text":"<p>Give concentration at any given position and point in time.</p> <p>Parameters:</p> Name Type Description Default <code>x_position</code> <code>float</code> <p>x position in domain extent [m].</p> required <code>y_position</code> <code>float</code> <p>y position in domain extent [m].</p> required <code>time</code> <code>float</code> <p>time for which concentration is sampled [days].</p> required <p>Returns:</p> Name Type Description <code>concentration</code> <code>float</code> <p>concentration at given position and point in time [g/m^3].</p> Source code in <code>mibitrans/transport/models.py</code> <pre><code>def sample(self, x_position, y_position, time):\n    \"\"\"Give concentration at any given position and point in time.\n\n    Args:\n        x_position (float): x position in domain extent [m].\n        y_position (float): y position in domain extent [m].\n        time (float): time for which concentration is sampled [days].\n\n    Returns:\n        concentration (float): concentration at given position and point in time [g/m^3].\n\n    \"\"\"\n    # Different sample method than parent class, as field-wide calculations use array indices\n    for par, value in locals().items():\n        if par != \"self\":\n            validate_input_values(par, value)\n\n    self._pre_run_initialization_parameters()\n\n    def integrand(t, sz):\n        div_term = 2 * np.sqrt(self.disp_y * t**4)\n        inner_term = self._src_pars.depth / (2 * np.sqrt(self.disp_z * t**4))\n        integrand_results = (\n            1\n            / (t**3)\n            * (\n                np.exp(\n                    (-self.k_source - self._decay_rate) * t**4\n                    - (x_position - self.rv * t**4) ** 2 / (4 * self.disp_x * t**4)\n                )\n                * (\n                    erfc((y_position - self.y_source[sz]) / div_term)\n                    - erfc((y_position + self.y_source[sz]) / div_term)\n                )\n                * (erfc(-inner_term) - erfc(inner_term))\n            )\n        )\n        return integrand_results\n\n    conc_array = np.zeros(len(self.c_source))\n    error_array = np.zeros(len(self.c_source))\n    time = time ** (1 / 4)\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        for sz in range(len(self.c_source)):\n            integral_term, error = quad(integrand, 0, time, limit=10000, args=(sz,))\n            source_term = (\n                self.c_source[sz] * x_position / (8 * np.sqrt(np.pi * self.disp_x)) * np.exp(-self.k_source * time)\n            )\n            conc_array[sz] = 4 * integral_term * source_term\n            error_array[sz] = error\n        concentration = np.sum(conc_array)\n        if self._mode == \"instant_reaction\":\n            concentration -= self.biodegradation_capacity\n            if concentration &lt; 0:\n                concentration = 0\n    return concentration\n</code></pre>"},{"location":"reference/reference_visualize/","title":"<code>mibitrans.visualize</code> API reference","text":""},{"location":"reference/reference_visualize/#mibitrans.visualize.animation","title":"<code>animation</code>","text":""},{"location":"reference/reference_visualize/#mibitrans.visualize.animation.animate_1d","title":"<code>animate_1d(x_axis_parameter, y_axis_parameter, time_parameter, y_names=None, y_colors=None, linestyle=None)</code>","text":"<p>Animate any type and number of input 1D plottables.</p> Source code in <code>mibitrans/visualize/animation.py</code> <pre><code>def animate_1d(\n    x_axis_parameter: np.ndarray, y_axis_parameter, time_parameter, y_names=None, y_colors=None, linestyle=None\n):\n    \"\"\"Animate any type and number of input 1D plottables.\"\"\"\n    if not isinstance(y_axis_parameter, list):\n        y_axis_parameter = [y_axis_parameter]\n    fig, ax = plt.subplots()\n    plot_bin = []\n    max_conc = 0\n    for i, y in enumerate(y_axis_parameter):\n        line = ax.plot(x_axis_parameter, y[0, :], color=y_colors[i], label=y_names[i], linestyle=linestyle[i])[0]\n        if np.max(y) &gt; max_conc:\n            max_conc = np.max(y)\n        plot_bin.append(line)\n    ax.set_ylim(bottom=0, top=max_conc + max_conc / 10)\n    ax.set_xlabel(\"Distance from source [m]\")\n    ax.set_ylabel(\"Concentration [g/m3]\")\n    ax.legend()\n    n_frames = len(time_parameter)\n\n    def update(frame):\n        \"\"\"Update plot with values for the next time step in the animation.\"\"\"\n        for i, y in enumerate(y_axis_parameter):\n            plot_bin[i].set_xdata(x_axis_parameter)\n            plot_bin[i].set_ydata(y[frame, :])\n        ax.set_title(f\"Concentration distribution at t={time_parameter[frame]} days\")\n        return plot_bin\n\n    ani = animation.FuncAnimation(fig=fig, func=update, frames=n_frames)\n    return ani\n</code></pre>"},{"location":"reference/reference_visualize/#mibitrans.visualize.plot_line","title":"<code>plot_line</code>","text":"<p>Author: Jorrit Bakker.</p> <p>Module plotting a 3D matrix of contaminant plume concentrations as a line.</p>"},{"location":"reference/reference_visualize/#mibitrans.visualize.plot_line.allowed_model_types","title":"<code>allowed_model_types()</code>","text":"<p>Return object of parent class that is allowed for input/output.</p> Source code in <code>mibitrans/visualize/plot_line.py</code> <pre><code>def allowed_model_types():\n    \"\"\"Return object of parent class that is allowed for input/output.\"\"\"\n    return mibitrans.transport.model_parent.Results\n</code></pre>"},{"location":"reference/reference_visualize/#mibitrans.visualize.plot_line.breakthrough","title":"<code>breakthrough(model, x_position, y_position=0, relative_concentration=False, legend_names=None, animate=False, **kwargs)</code>","text":"<p>Plot contaminant breakthrough curve at given x and y position in model domain.</p> <p>Parameters:</p> Name Type Description Default <code>model </code> <p>Model object from mibitrans.transport, or list of model objects.</p> required <code>x_position </code> <p>x-position along the plume (longitudinal direction).</p> required <code>y_position </code> <p>y-position across the plume (transverse horizontal direction). By default, at the center of the plume (at y=0).</p> required <code>relative_concentration (bool, optional) </code> <p>If set to True, will plot concentrations relative to maximum source zone concentrations at t=0. By default, absolute concentrations are shown.</p> required <code>legend_names</code> <code>str | list</code> <p>List of legend names as strings, in the same order as given models. By default, no legend is shown.</p> <code>None</code> <code>animate</code> <code>bool</code> <p>If True, animation of contaminant plume until given time is shown. If multiple models are given as input, dt should be the same for each one to ensure accurate animation. Default is False.</p> <code>False</code> <code>**kwargs </code> <p>Arguments to be passed to plt.plot().</p> required Source code in <code>mibitrans/visualize/plot_line.py</code> <pre><code>def breakthrough(\n    model, x_position, y_position=0, relative_concentration=False, legend_names=None, animate=False, **kwargs\n):\n    \"\"\"Plot contaminant breakthrough curve at given x and y position in model domain.\n\n    Args:\n        model : Model object from mibitrans.transport, or list of model objects.\n        x_position : x-position along the plume (longitudinal direction).\n        y_position : y-position across the plume (transverse horizontal direction).\n            By default, at the center of the plume (at y=0).\n        relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum source\n            zone concentrations at t=0. By default, absolute concentrations are shown.\n        legend_names (str | list, optional): List of legend names as strings, in the same order as given models.\n            By default, no legend is shown.\n        animate (bool, optional): If True, animation of contaminant plume until given time is shown. If multiple models\n            are given as input, dt should be the same for each one to ensure accurate animation. Default is False.\n        **kwargs : Arguments to be passed to plt.plot().\n    \"\"\"\n    if not isinstance(model, list):\n        model = [model]\n    if not isinstance(legend_names, list) and legend_names is not None:\n        legend_names = [legend_names]\n\n    plot_array_list = []\n    # Checks for list model input: dt should be equal, time should be smaller than the smallest end time, y_position\n    # should be inside narrowest domain boundaries\n    for mod in model:\n        check_model_type(mod, allowed_model_types())\n        x_pos = check_x_in_domain(mod, x_position)\n        y_pos = check_y_in_domain(mod, y_position)\n        if relative_concentration:\n            plot_array_list.append(mod.relative_cxyt[:, y_pos, x_pos])\n            y_label = relative_conc_ylabel\n        else:\n            plot_array_list.append(mod.cxyt[:, y_pos, x_pos])\n            y_label = absolute_conc_ylabel\n\n    # Non animated plot\n    if not animate:\n        for i, mod in enumerate(model):\n            if legend_names is not None:\n                plt.plot(mod.t, plot_array_list[i], label=legend_names[i], **kwargs)\n            else:\n                plt.plot(mod.t, plot_array_list[i], **kwargs)\n\n        plt.ylim(bottom=0)\n        plt.xlabel(\"Time [days]\")\n        plt.ylabel(y_label)\n        plot_title = _plot_title_generator(\n            \"Breakthrough\", model[0], x_position=x_position, y_position=y_position, multiple=len(model) &gt; 1\n        )\n        plt.title(plot_title)\n        if legend_names is not None:\n            plt.legend()\n\n    # Animated plot\n    else:\n        fig, ax = plt.subplots()\n        plot_bin = []\n        max_conc = 0\n        max_time = 0\n        for i, mod in enumerate(model):\n            if legend_names is not None:\n                line = ax.plot(mod.t[0], plot_array_list[i][0], label=legend_names[i])[0]\n            else:\n                line = ax.plot(mod.t[0], plot_array_list[i][0], **kwargs)[0]\n\n            # As plot extent is decided by first initiation of plot, ensure that axis concentration and time limits\n            # are corresponding with their maximum values\n            if mod.t[-1] &gt; max_time:\n                max_time = mod.t[-1]\n            if np.max(plot_array_list[i]) &gt; max_conc:\n                max_conc = np.max(plot_array_list[i])\n            plot_bin.append(line)\n        ax.set_xlim(right=max_time)\n        ax.set_ylim(bottom=0, top=max_conc + max_conc / 10)\n        ax.set_xlabel(\"Time [days]\")\n        ax.set_ylabel(y_label)\n        if legend_names is not None:\n            ax.legend()\n\n        def update(frame):\n            for i, mod in enumerate(model):\n                plot_bin[i].set_xdata(mod.t[:frame])\n                plot_bin[i].set_ydata(plot_array_list[i][:frame])\n                ax.set_title(f\"Breakthrough curve at t={mod.t[frame]} days\")\n            return plot_bin\n\n        ani = animation.FuncAnimation(fig=fig, func=update, frames=len(model[0].t))\n        return ani\n</code></pre>"},{"location":"reference/reference_visualize/#mibitrans.visualize.plot_line.centerline","title":"<code>centerline(model, y_position=0, time=None, relative_concentration=False, legend_names=None, animate=False, **kwargs)</code>","text":"<p>Plot center of contaminant plume of one or multiple models as a line, at a specified time and y position.</p> <p>Parameters:</p> Name Type Description Default <code>model </code> <p>Model object from mibitrans.transport, or list of model objects.</p> required <code>y_position</code> <code>float</code> <p>y-position across the plume (transverse horizontal direction) for the plot. By default, the center of the plume at y=0 is plotted.</p> <code>0</code> <code>time</code> <code>float</code> <p>Point of time for the plot. Will show the closest time step to given value. By default, last point in time is plotted.</p> <code>None</code> <code>relative_concentration (bool, optional) </code> <p>If set to True, will plot concentrations relative to maximum source zone concentrations at t=0. By default, absolute concentrations are shown.</p> required <code>legend_names</code> <code>str | list</code> <p>List of legend names as strings, in the same order as given models. By default, no legend is shown.</p> <code>None</code> <code>animate</code> <code>bool</code> <p>If True, animation of contaminant plume until given time is shown. If multiple models are given as input, dt should be the same for each one to ensure accurate animation. Default is False.</p> <code>False</code> <code>**kwargs </code> <p>Arguments to be passed to plt.plot().</p> required Source code in <code>mibitrans/visualize/plot_line.py</code> <pre><code>def centerline(\n    model, y_position=0, time=None, relative_concentration=False, legend_names=None, animate=False, **kwargs\n):\n    \"\"\"Plot center of contaminant plume of one or multiple models as a line, at a specified time and y position.\n\n    Args:\n        model : Model object from mibitrans.transport, or list of model objects.\n        y_position (float, optional): y-position across the plume (transverse horizontal direction) for the plot.\n            By default, the center of the plume at y=0 is plotted.\n        time (float, optional): Point of time for the plot. Will show the closest time step to given value.\n            By default, last point in time is plotted.\n        relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum source\n            zone concentrations at t=0. By default, absolute concentrations are shown.\n        legend_names (str | list, optional): List of legend names as strings, in the same order as given models.\n            By default, no legend is shown.\n        animate (bool, optional): If True, animation of contaminant plume until given time is shown. If multiple models\n            are given as input, dt should be the same for each one to ensure accurate animation. Default is False.\n        **kwargs : Arguments to be passed to plt.plot().\n\n    \"\"\"\n    if not isinstance(model, list):\n        model = [model]\n    if not isinstance(legend_names, list) and legend_names is not None:\n        legend_names = [legend_names]\n\n    plot_array_list = []\n    # Checks for list model input: dt should be equal, time should be smaller than the smallest end time, y_position\n    # should be inside narrowest domain boundaries\n    for mod in model:\n        check_model_type(mod, allowed_model_types())\n        y_pos = check_y_in_domain(mod, y_position)\n        t_pos = check_time_in_domain(mod, time)\n\n        if relative_concentration:\n            if animate:\n                plot_array_list.append(mod.relative_cxyt[:, y_pos, :])\n            else:\n                plot_array_list.append(mod.relative_cxyt[t_pos, y_pos, :])\n            y_label = relative_conc_ylabel\n        else:\n            if animate:\n                plot_array_list.append(mod.cxyt[:, y_pos, :])\n            else:\n                plot_array_list.append(mod.cxyt[t_pos, y_pos, :])\n            y_label = absolute_conc_ylabel\n\n    # Non-animated plot\n    if not animate:\n        for i, mod in enumerate(model):\n            if legend_names is not None:\n                plt.plot(mod.x, plot_array_list[i], label=legend_names[i], **kwargs)\n            else:\n                plt.plot(mod.x, plot_array_list[i], **kwargs)\n\n        plt.ylim(bottom=0)\n        plt.xlabel(\"Distance from source [m]\")\n        plt.ylabel(y_label)\n\n        plot_title = _plot_title_generator(\n            \"Centerline\", model[0], time=model[0].t[t_pos], y_position=y_position, multiple=len(model) &gt; 1\n        )\n        plt.title(plot_title)\n        if legend_names is not None:\n            plt.legend()\n\n    # Animated plot\n    else:\n        fig, ax = plt.subplots()\n        plot_bin = []\n        for i, mod in enumerate(model):\n            if legend_names is not None:\n                line = ax.plot(mod.x, plot_array_list[i][0, :], label=legend_names[i], **kwargs)[0]\n            else:\n                line = ax.plot(mod.x, plot_array_list[i][0, :], **kwargs)[0]\n            plot_bin.append(line)\n        ax.set_ylim(bottom=0)\n        ax.set_xlabel(\"Distance from source [m]\")\n        ax.set_ylabel(y_label)\n\n        if legend_names is not None:\n            ax.legend()\n\n        def update(frame):\n            for i, mod in enumerate(model):\n                plot_bin[i].set_xdata(mod.x)\n                plot_bin[i].set_ydata(plot_array_list[i][frame, :])\n                ax.set_title(f\"Concentration distribution at t={mod.t[frame]} days\")\n            return plot_bin\n\n        ani = animation.FuncAnimation(fig=fig, func=update, frames=t_pos + 1)\n        return ani\n</code></pre>"},{"location":"reference/reference_visualize/#mibitrans.visualize.plot_line.transverse","title":"<code>transverse(model, x_position, time=None, relative_concentration=False, legend_names=None, animate=False, **kwargs)</code>","text":"<p>Plot concentration distribution as a line horizontal transverse to the plume extent.</p> <p>Parameters:</p> Name Type Description Default <code>model </code> <p>Model object from mibitrans.transport, or list of model objects.</p> required <code>x_position </code> <p>x-position along the plume (longitudinal direction) for the plot.</p> required <code>time</code> <code>float</code> <p>Point of time for the plot. Will show the closest time step to given value. By default, last point in time is plotted.</p> <code>None</code> <code>relative_concentration (bool, optional) </code> <p>If set to True, will plot concentrations relative to maximum source zone concentrations at t=0. By default, absolute concentrations are shown.</p> required <code>legend_names</code> <code>str | list</code> <p>List of legend names as strings, in the same order as given models. By default, no legend is shown.</p> <code>None</code> <code>animate</code> <code>bool</code> <p>If True, animation of contaminant plume until given time is shown. If multiple models are given as input, dt should be the same for each one to ensure accurate animation. Default is False.</p> <code>False</code> <code>**kwargs </code> <p>Arguments to be passed to plt.plot().</p> required Source code in <code>mibitrans/visualize/plot_line.py</code> <pre><code>def transverse(model, x_position, time=None, relative_concentration=False, legend_names=None, animate=False, **kwargs):\n    \"\"\"Plot concentration distribution as a line horizontal transverse to the plume extent.\n\n    Args:\n        model : Model object from mibitrans.transport, or list of model objects.\n        x_position : x-position along the plume (longitudinal direction) for the plot.\n        time (float): Point of time for the plot. Will show the closest time step to given value.\n            By default, last point in time is plotted.\n        relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum source\n            zone concentrations at t=0. By default, absolute concentrations are shown.\n        legend_names (str | list, optional): List of legend names as strings, in the same order as given models.\n            By default, no legend is shown.\n        animate (bool, optional): If True, animation of contaminant plume until given time is shown. If multiple models\n            are given as input, dt should be the same for each one to ensure accurate animation. Default is False.\n        **kwargs : Arguments to be passed to plt.plot().\n    \"\"\"\n    if not isinstance(model, list):\n        model = [model]\n    if not isinstance(legend_names, list) and legend_names is not None:\n        legend_names = [legend_names]\n\n    plot_array_list = []\n    # Checks for list model input: dt should be equal, time should be smaller than the smallest end time, y_position\n    # should be inside narrowest domain boundaries\n    for mod in model:\n        check_model_type(mod, allowed_model_types())\n        x_pos = check_x_in_domain(mod, x_position)\n        t_pos = check_time_in_domain(mod, time)\n\n        if relative_concentration:\n            if animate:\n                plot_array_list.append(mod.relative_cxyt[:, :, x_pos])\n            else:\n                plot_array_list.append(mod.relative_cxyt[t_pos, :, x_pos])\n            y_label = relative_conc_ylabel\n        else:\n            if animate:\n                plot_array_list.append(mod.cxyt[:, :, x_pos])\n            else:\n                plot_array_list.append(mod.cxyt[t_pos, :, x_pos])\n            y_label = absolute_conc_ylabel\n\n    if not animate:\n        for i, mod in enumerate(model):\n            if legend_names is not None:\n                plt.plot(mod.y, plot_array_list[i], label=legend_names[i], **kwargs)\n            else:\n                plt.plot(mod.y, plot_array_list[i], **kwargs)\n\n        plt.ylim(bottom=0)\n        plt.xlabel(\"y-position [m]\")\n        plt.ylabel(y_label)\n        plot_title = _plot_title_generator(\n            \"Transverse\", model[0], time=model[0].t[t_pos], x_position=x_position, multiple=len(model) &gt; 1\n        )\n        plt.title(plot_title)\n        if legend_names is not None:\n            plt.legend()\n    else:\n        fig, ax = plt.subplots()\n        plot_bin = []\n        max_conc = 0\n        for i, mod in enumerate(model):\n            if legend_names is not None:\n                line = ax.plot(mod.y, plot_array_list[i][0, :], label=legend_names[i])[0]\n            else:\n                line = ax.plot(mod.y, plot_array_list[i][0, :], **kwargs)[0]\n            if np.max(plot_array_list[i]) &gt; max_conc:\n                max_conc = np.max(plot_array_list[i])\n            plot_bin.append(line)\n        ax.set_ylim(bottom=0, top=max_conc + max_conc / 10)\n\n        ax.set_xlabel(\"y-position [m]\")\n        ax.set_ylabel(y_label)\n\n        if legend_names is not None:\n            ax.legend()\n\n        def update(frame):\n            for i, mod in enumerate(model):\n                plot_bin[i].set_xdata(mod.y)\n                plot_bin[i].set_ydata(plot_array_list[i][frame, :])\n                ax.set_title(f\"Concentration distribution at t={mod.t[frame]} days\")\n            return plot_bin\n\n        ani = animation.FuncAnimation(fig=fig, func=update, frames=t_pos + 1)\n        return ani\n</code></pre>"},{"location":"reference/reference_visualize/#mibitrans.visualize.plot_surface","title":"<code>plot_surface</code>","text":""},{"location":"reference/reference_visualize/#mibitrans.visualize.plot_surface.plume_2d","title":"<code>plume_2d(model, time=None, relative_concentration=False, animate=False, **kwargs)</code>","text":"<p>Plot contaminant plume as a 2D colormesh, at a specified time.</p> <p>Parameters:</p> Name Type Description Default <code>model </code> <p>Model object from mibitrans.transport.</p> required <code>time</code> <code>float</code> <p>Point of time for the plot. Will show the closest time step to given value. By default, last point in time is plotted.</p> <code>None</code> <code>relative_concentration (bool, optional) </code> <p>If set to True, will plot concentrations relative to maximum source zone concentrations at t=0. By default, absolute concentrations are shown.</p> required <code>animate</code> <code>bool</code> <p>If True, animation of contaminant plume until given time is shown. Default is False.</p> <code>False</code> <code>**kwargs </code> <p>Arguments to be passed to plt.pcolormesh().</p> required <p>Returns a matrix plot of the input plume as object.</p> Source code in <code>mibitrans/visualize/plot_surface.py</code> <pre><code>def plume_2d(model, time=None, relative_concentration=False, animate=False, **kwargs):\n    \"\"\"Plot contaminant plume as a 2D colormesh, at a specified time.\n\n    Args:\n        model : Model object from mibitrans.transport.\n        time (float): Point of time for the plot. Will show the closest time step to given value.\n            By default, last point in time is plotted.\n        relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum source\n            zone concentrations at t=0. By default, absolute concentrations are shown.\n        animate (bool, optional): If True, animation of contaminant plume until given time is shown. Default is\n            False.\n        **kwargs : Arguments to be passed to plt.pcolormesh().\n\n    Returns a matrix plot of the input plume as object.\n    \"\"\"\n    check_model_type(model, allowed_model_types())\n    t_pos = check_time_in_domain(model, time)\n    if relative_concentration:\n        model_concentration = model.relative_cxyt\n        z_label = relative_conc_zlabel\n    else:\n        model_concentration = model.cxyt\n        z_label = absolute_conc_zlabel\n    # Non animated plot\n    if not animate:\n        plt.pcolormesh(model.x, model.y, model_concentration[t_pos, :, :], **kwargs)\n        plt.xlabel(\"Distance from source (m)\")\n        plt.ylabel(\"Distance from plume center (m)\")\n        plt.colorbar(label=z_label)\n        plot_title = _plot_title_generator(\"Plume\", model, time=model.t[t_pos])\n        plt.title(plot_title)\n\n    # Animated plot\n    else:\n        fig, ax = plt.subplots()\n        mesh = ax.pcolormesh(\n            model.x, model.y, model_concentration[0, :, :], vmin=0, vmax=np.max(model_concentration), **kwargs\n        )\n        cbar = fig.colorbar(mesh, ax=ax)\n        cbar.set_label(z_label)\n        ax.set_xlabel(\"Distance from source (m)\")\n        ax.set_ylabel(\"Distance from plume center (m)\")\n\n        def update(frame):\n            mesh.set_array(model_concentration[frame, :, :])\n            ax.set_title(f\"Concentration distribution at t={model.t[frame]} days\")\n            return mesh\n\n        ani = animation.FuncAnimation(fig=fig, func=update, frames=t_pos + 1)\n        return ani\n</code></pre>"},{"location":"reference/reference_visualize/#mibitrans.visualize.plot_surface.plume_3d","title":"<code>plume_3d(model, time=None, relative_concentration=False, animate=False, **kwargs)</code>","text":"<p>Plot contaminant plume as a 3D surface, at a specified time.</p> <p>Parameters:</p> Name Type Description Default <code>model </code> <p>Model object from mibitrans.transport.</p> required <code>time</code> <code>float</code> <p>Point of time for the plot. Will show the closest time step to given value. By default, last point in time is plotted.</p> <code>None</code> <code>relative_concentration (bool, optional) </code> <p>If set to True, will plot concentrations relative to maximum source zone concentrations at t=0. By default, absolute concentrations are shown.</p> required <code>animate</code> <code>bool</code> <p>If True, animation of contaminant plume until given time is shown. Default is False.</p> <code>False</code> <code>**kwargs </code> <p>Arguments to be passed to plt.plot_surface().</p> required <p>Returns:</p> Type Description <p>ax (matplotlib.axes._axes.Axes) : Returns matplotlib axes object of plume plot.</p> Source code in <code>mibitrans/visualize/plot_surface.py</code> <pre><code>def plume_3d(model, time=None, relative_concentration=False, animate=False, **kwargs):\n    \"\"\"Plot contaminant plume as a 3D surface, at a specified time.\n\n    Args:\n        model : Model object from mibitrans.transport.\n        time (float): Point of time for the plot. Will show the closest time step to given value.\n            By default, last point in time is plotted.\n        relative_concentration (bool, optional) : If set to True, will plot concentrations relative to maximum source\n            zone concentrations at t=0. By default, absolute concentrations are shown.\n        animate (bool, optional): If True, animation of contaminant plume until given time is shown. Default is\n            False.\n        **kwargs : Arguments to be passed to plt.plot_surface().\n\n    Returns:\n        ax (matplotlib.axes._axes.Axes) : Returns matplotlib axes object of plume plot.\n    \"\"\"\n    check_model_type(model, allowed_model_types())\n    t_pos = check_time_in_domain(model, time)\n    if relative_concentration:\n        model_concentration = model.relative_cxyt\n        z_label = relative_conc_zlabel\n    else:\n        model_concentration = model.cxyt\n        z_label = absolute_conc_zlabel\n\n    # Non animated plot\n    xxx = np.tile(model.x, (len(model.t), len(model.y), 1))\n    yyy = np.tile(model.y[:, None], (len(model.t), 1, len(model.x)))\n    if not animate:\n        fig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\n        ax.plot_surface(xxx[t_pos, :, :], yyy[t_pos, :, :], model_concentration[t_pos, :, :], **kwargs)\n        ax.view_init(elev=30, azim=310)\n        ax.set_xlabel(\"Distance from source (m)\")\n        ax.set_ylabel(\"Distance from plume center (m)\")\n        ax.set_zlabel(z_label)\n        plot_title = _plot_title_generator(\"Plume\", model, time=model.t[t_pos])\n        ax.set_title(plot_title)\n        return ax\n\n    # Animated plot\n    else:\n        if \"cmap\" not in kwargs and \"color\" not in kwargs:\n            kwargs[\"color\"] = \"tab:blue\"\n        model_max = np.max(model_concentration)\n        fig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\n        surface = ax.plot_surface(\n            xxx[0, :, :],\n            yyy[0, :, :],\n            model_concentration[0, :, :],\n            vmin=0,\n            vmax=model_max,\n            **kwargs,\n        )\n        ax.set_xlabel(\"Distance from source (m)\")\n        ax.set_ylabel(\"Distance from plume center (m)\")\n        ax.set_zlabel(z_label)\n        ax.set_zlim(0, model_max)\n\n        # plot_surface creates a static surface; need to create new plot every time step\n        def update(frame):\n            # nonlocal needed in order for the previous plot to be removed before new one is plotted\n            nonlocal surface\n            surface.remove()\n            surface = ax.plot_surface(\n                xxx[frame, :, :],\n                yyy[frame, :, :],\n                model_concentration[frame, :, :],\n                vmin=0,\n                vmax=model_max,\n                **kwargs,\n            )\n            ax.set_title(f\"Concentration distribution at t={model.t[frame]} days\")\n            return surface\n\n        ani = animation.FuncAnimation(fig=fig, func=update, frames=t_pos + 1)\n        return ani\n</code></pre>"},{"location":"reference/reference_visualize/#mibitrans.visualize.show_conditions","title":"<code>show_conditions</code>","text":"<p>Author: Jorrit Bakker.</p> <p>Module including various methods to visualize (input) parameter conditions, intended to only be called internally.</p>"},{"location":"reference/reference_visualize/#mibitrans.visualize.show_conditions.model_grid","title":"<code>model_grid(model_parameters)</code>","text":"<p>Visualize the model grid.</p> Source code in <code>mibitrans/visualize/show_conditions.py</code> <pre><code>def model_grid(model_parameters):\n    \"\"\"Visualize the model grid.\"\"\"\n    return None\n</code></pre>"},{"location":"reference/reference_visualize/#mibitrans.visualize.show_conditions.source_zone","title":"<code>source_zone(source_parameters)</code>","text":"<p>Visualize source zone conditions.</p> Source code in <code>mibitrans/visualize/show_conditions.py</code> <pre><code>def source_zone(source_parameters):\n    \"\"\"Visualize source zone conditions.\"\"\"\n    source_y = source_parameters.source_zone_boundary\n    source_c = source_parameters.source_zone_concentration\n\n    y_discretization = np.linspace(-source_y[-1] - source_y[-1] / 10, source_y[-1] + source_y[-1] / 10, 10000)\n    c_values = np.zeros(len(y_discretization))\n    for i, y in enumerate(source_y[::-1]):\n        c_values = np.where((y_discretization &lt;= y) &amp; (y_discretization &gt;= -y), source_c[-(i + 1)], c_values)\n\n    indexer = np.linspace(1, 0.3, len(source_y))\n    colormap = matplotlib.colormaps[\"YlGnBu\"]\n\n    plt.figure(dpi=300)\n\n    for i, y in enumerate(source_y):\n        if i == 0:\n            plt.fill_betweenx(\n                y=y_discretization,\n                x1=c_values,\n                where=(y_discretization &lt;= y) &amp; (y_discretization &gt;= -y),\n                color=colormap(indexer[i]),\n                zorder=len(source_y) + 2,\n            )\n        else:\n            plt.fill_betweenx(\n                y=y_discretization,\n                x1=c_values,\n                # Boolean array for domain of source zone i\n                where=((y_discretization &lt;= y) &amp; (y_discretization &gt; source_y[i - 1]))\n                | ((y_discretization &gt;= -y) &amp; (y_discretization &lt; -source_y[i - 1])),\n                color=colormap(indexer[i]),\n                zorder=len(source_y) + 2 - i,\n            )\n\n    plt.xlabel(r\"Source zone concentration $g/m^3$\")\n    plt.ylabel(\"Source zone y-coordinate\")\n    plt.title(\"Concentration distribution in the source zone\")\n</code></pre>"}]}