{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documention for <code>mibitrans</code> python package","text":""},{"location":"#how-to-use-mibitrans","title":"How to use mibitrans","text":"<p>A collection of analytical and semi-semianalytical solutions for hydrogeological transport phenomena</p>"},{"location":"#installation","title":"Installation","text":"<p>To install mibitrans from GitHub repository, do:</p> <pre><code>git clone git@github.com:MiBiPreT/mibitrans.git\ncd mibitrans\npython -m pip install .\n</code></pre>"},{"location":"getting-started/development/","title":"<code>mibitrans</code> developer documentation","text":""},{"location":"getting-started/development/#development-install","title":"Development install","text":"<pre><code># Create a virtual environment, e.g. with\npython -m venv env\n\n# activate virtual environment\nsource env/bin/activate\n\n# make sure to have a recent version of pip and setuptools\npython -m pip install --upgrade pip setuptools\n\n# (from the project root directory)\n# install mibitrans as an editable package\npython -m pip install --no-cache-dir --editable .\n# install development dependencies\npython -m pip install --no-cache-dir --editable .[dev]\n</code></pre> <p>Afterwards check that the install directory is present in the <code>PATH</code> environment variable.</p>"},{"location":"getting-started/development/#running-the-tests","title":"Running the tests","text":"<p>There are two ways to run tests.</p> <p>The first way requires an activated virtual environment with the development tools installed:</p> <pre><code>pytest -v\n</code></pre> <p>The second is to use <code>tox</code>, which can be installed separately (e.g. with <code>pip install tox</code>), i.e. not necessarily inside the virtual environment you use for installing <code>mibitrans</code>, but then builds the necessary virtual environments itself by simply running:</p> <pre><code>tox\n</code></pre> <p>Testing with <code>tox</code> allows for keeping the testing environment separate from your development environment. The development environment will typically accumulate (old) packages during development that interfere with testing; this problem is avoided by testing with <code>tox</code>.</p>"},{"location":"getting-started/development/#test-coverage","title":"Test coverage","text":"<p>In addition to just running the tests to see if they pass, they can be used for coverage statistics, i.e. to determine how much of the package\u2019s code is actually executed during tests. In an activated virtual environment with the development tools installed, inside the package directory, run:</p> <pre><code>coverage run\n</code></pre> <p>This runs tests and stores the result in a <code>.coverage</code> file. To see the results on the command line, run</p> <pre><code>coverage report\n</code></pre> <p><code>coverage</code> can also generate output in HTML and other formats; see <code>coverage help</code> for more information.</p>"},{"location":"getting-started/development/#running-linters-locally","title":"Running linters locally","text":"<p>For linting and sorting imports we will use ruff. Running the linters requires an  activated virtual environment with the development tools installed.</p> <pre><code># linter\nruff check .\n\n# linter with automatic fixing\nruff check . --fix\n</code></pre> <p>To fix readability of your code style you can use yapf.</p> <p>You can enable automatic linting with <code>ruff</code> on commit by enabling the git hook from <code>.githooks/pre-commit</code>, like so:</p> <pre><code>git config --local core.hooksPath .githooks\n</code></pre>"},{"location":"getting-started/development/#testing-docs-locally","title":"Testing docs locally","text":"<p>To build the documentation locally, first make sure <code>mkdocs</code> and its dependencies are installed: <pre><code>python -m pip install .[doc]\n</code></pre></p> <p>Then you can build the documentation and serve it locally with <pre><code>mkdocs serve\n</code></pre></p> <p>This will return a URL (e.g. <code>http://127.0.0.1:8000/mibitrans/</code>) where the docs site can be viewed.</p>"},{"location":"getting-started/development/#versioning","title":"Versioning","text":"<p>Bumping the version across all files is done with bump-my-version, e.g.</p> <pre><code>bump-my-version bump major  # bumps from e.g. 0.3.2 to 1.0.0\nbump-my-version bump minor  # bumps from e.g. 0.3.2 to 0.4.0\nbump-my-version bump patch  # bumps from e.g. 0.3.2 to 0.3.3\n</code></pre>"},{"location":"getting-started/development/#making-a-release","title":"Making a release","text":"<p>This section describes how to make a release in 3 parts:</p> <ol> <li>preparation</li> <li>making a release on PyPI</li> <li>making a release on GitHub</li> </ol>"},{"location":"getting-started/development/#13-preparation","title":"(1/3) Preparation","text":"<ol> <li>Verify that the information in CITATION.cff is correct.</li> <li>Make sure the version has been updated.</li> <li>Run the unit tests with <code>pytest -v</code></li> </ol>"},{"location":"getting-started/development/#23-pypi","title":"(2/3) PyPI","text":"<p>In a new terminal:</p> <pre><code># OPTIONAL: prepare a new directory with fresh git clone to ensure the release\n# has the state of origin/main branch\ncd $(mktemp -d mibitrans.XXXXXX)\ngit clone git@github.com:MiBiPreT/mibitrans .\n\n# make sure to have a recent version of pip and the publishing dependencies\npython -m pip install --upgrade pip\npython -m pip install .[publishing]\n\n# create the source distribution and the wheel\npython -m build\n\n# upload to test pypi instance (requires credentials)\npython -m twine upload --repository testpypi dist/*\n</code></pre> <p>Visit https://test.pypi.org/</p> <p>and verify that your package was uploaded successfully. Keep the terminal open, we\u2019ll need it later.</p> <p>In a new terminal, without an activated virtual environment or an env directory:</p> <pre><code>cd $(mktemp -d mibitrans-test.XXXXXX)\n\n# prepare a clean virtual environment and activate it\npython -m venv env\nsource env/bin/activate\n\n# make sure to have a recent version of pip and setuptools\npython -m pip install --upgrade pip\n\n# install from test pypi instance:\npython -m pip -v install --no-cache-dir \\\n--index-url https://test.pypi.org/simple/ \\\n--extra-index-url https://pypi.org/simple mibitrans\n</code></pre> <p>Check that the package works as it should when installed from pypitest.</p> <p>Then upload to pypi.org with:</p> <pre><code># Back to the first terminal,\n# FINAL STEP: upload to PyPI (requires credentials)\npython -m twine upload dist/*\n</code></pre>"},{"location":"getting-started/development/#33-github","title":"(3/3) GitHub","text":"<p>Also make a release on GitHub. If your repository uses the GitHub-Zenodo integration this will also trigger Zenodo into making a snapshot of your repository and sticking a DOI on it.</p> <p>Github provides detailed documentation on how to generate a release. Here you can also automatically generate the release notes which can serve as a changelog based on the merged pull requests since the previous release. </p>"},{"location":"reference/reference/","title":"<code>mibitrans</code> API reference","text":"<p>Documentation about mibitrans.</p>"},{"location":"reference/reference/#mibitrans.analysis","title":"<code>analysis</code>","text":""},{"location":"reference/reference/#mibitrans.analysis.mass_balance","title":"<code>mass_balance</code>","text":"<p>Author: Jorrit Bakker.</p> <p>Module calculating the mass balance based on base parameters.</p>"},{"location":"reference/reference/#mibitrans.analysis.mass_balance.mass_balance","title":"<code>mass_balance(model, time=None)</code>","text":"<p>Calculate contaminant mass balance across model compartments.</p> <p>Parameters:</p> Name Type Description Default <code>model (mibitrans.transport.domenico.Domenico) </code> <p>Domenico transport model object.</p> required <code>time (float) </code> <p>Time at which to calculate mass balance. Default is the last time step.</p> required <p>Returns:</p> Name Type Description <code>mass_balance_dict</code> <code>dict</code> <p>Dictionary containing the mass balance elements of the given model.</p> Source code in <code>mibitrans/analysis/mass_balance.py</code> <pre><code>def mass_balance(model, time=None) -&gt; dict:\n    \"\"\"Calculate contaminant mass balance across model compartments.\n\n    Args:\n        model (mibitrans.transport.domenico.Domenico) : Domenico transport model object.\n        time (float) : Time at which to calculate mass balance. Default is the last time step.\n\n    Returns:\n        mass_balance_dict : Dictionary containing the mass balance elements of the given model.\n    \"\"\"\n    _check_model_type(model, Domenico)\n    time_pos = _time_check(model, time)\n    mass_balance_dict = {}\n\n    mass_balance_dict[\"time\"] = model.t[time_pos]\n\n    if hasattr(model, \"deg_pars\"):\n        no_decay_model = NoDecay(model.hyd_pars, model.ads_pars, model.src_pars, model.mod_pars)\n        if hasattr(model, \"biodegradation_capacity\"):\n            mode = \"instant_reaction\"\n        else:\n            mode = \"linear_decay\"\n    else:\n        mode = \"no_decay\"\n        no_decay_model = model\n\n    # Total source mass at t=0\n    M_source_0 = model.src_pars.total_mass\n    mass_balance_dict[\"source_mass_0\"] = M_source_0\n\n    # Total source mass at t=t, for the no decay model\n    M_source_t = M_source_0 * np.exp(-no_decay_model.k_source * model.t[time_pos])\n    mass_balance_dict[\"source_mass_t\"] = M_source_t\n\n    # Change in source mass at t=t, due to source decay by transport\n    M_source_delta = M_source_0 - M_source_t\n    mass_balance_dict[\"source_mass_change\"] = M_source_delta\n\n    # Volume of single cell, as dx * dy * source thickness\n    cellsize = abs(model.x[0] - model.x[1]) * abs(model.y[0] - model.y[1]) * model.src_pars.depth\n\n    # Plume mass of no decay model; concentration is converted to mass by multiplying by cellsize and pore space.\n    plume_mass_nodecay = np.sum(no_decay_model.cxyt[time_pos, :, 1:] * cellsize * model.hyd_pars.porosity)\n    mass_balance_dict[\"plume_mass_no_decay\"] = plume_mass_nodecay\n\n    # Difference between current plume mass and change in source mass must have been transported outside of model\n    # extent for no decay scenarios; preservation of mass.\n    if M_source_delta - plume_mass_nodecay &lt; 0:\n        transport_outside_extent_nodecay = 0\n        mass_balance_dict[\"transport_outside_extent\"] = transport_outside_extent_nodecay\n    else:\n        transport_outside_extent_nodecay = M_source_delta - plume_mass_nodecay\n        mass_balance_dict[\"transport_outside_extent_nodecay\"] = transport_outside_extent_nodecay\n\n    if mode == \"linear_decay\":\n        # Plume mass of linear decay model.\n        plume_mass_lindecay = np.sum(model.cxyt[time_pos, :, 1:] * cellsize * model.hyd_pars.porosity)\n        mass_balance_dict[\"plume_mass_linear_decay\"] = plume_mass_lindecay\n\n        # Calculate transport out of model extent linear decay as fraction of transport out of model for no decay\n        # model, scaled by ratio between no decay and linear decay plume mass.\n        transport_outside_extent_lindecay = transport_outside_extent_nodecay * plume_mass_lindecay / plume_mass_nodecay\n        mass_balance_dict[\"transport_outside_extent_lineardecay\"] = transport_outside_extent_lindecay\n\n        # Contaminant mass degraded by linear decay is diffrence plume mass no and linear decay plus difference in\n        # mass transported outside model extent by no and linear decay.\n        degraded_mass = (\n            plume_mass_nodecay\n            - plume_mass_lindecay\n            + transport_outside_extent_nodecay\n            - transport_outside_extent_lindecay\n        )\n        mass_balance_dict[\"plume_mass_degraded_linear\"] = degraded_mass\n\n    elif mode == \"instant_reaction\":\n        # Total source mass at t=t, for the instant reaction model\n        M_source_t_inst = M_source_0 * np.exp(-model.k_source * model.t[time_pos])\n        mass_balance_dict[\"source_mass_instant_t\"] = M_source_t_inst\n\n        # Change in source mass at t=t due to source decay by transport and by biodegradation\n        M_source_delta = M_source_0 - M_source_t_inst\n        mass_balance_dict[\"source_mass_instant_change\"] = M_source_delta\n\n        # Plume mass without biodegradation according to the instant degradation model\n        plume_mass_inst_nodecay = np.sum(model.cxyt_noBC[time_pos, :, 1:] * cellsize * model.hyd_pars.porosity)\n        mass_balance_dict[\"plume_mass_no_decay_instant_reaction\"] = plume_mass_inst_nodecay\n\n        # Plume mass with biodegradation according to the instant degradation model\n        plume_mass_inst = np.sum(model.cxyt[time_pos, :, 1:] * cellsize * model.hyd_pars.porosity)\n        mass_balance_dict[\"plume_mass_instant_reaction\"] = plume_mass_inst\n\n        # Assumption: all mass difference between instant degradation model with biodegradation and\n        # instant degradation model without biodegradation is caused by degradation.\n        degraded_mass = plume_mass_inst_nodecay - plume_mass_inst\n        mass_balance_dict[\"plume_mass_degraded_instant\"] = degraded_mass\n\n        # Weight fraction of electron acceptor used for degradation and degraded contaminant\n        mass_fraction_electron_acceptor = calculate_utilization(model)\n\n        # Change in total mass of each electron acceptor\n        electron_acceptor_mass_change = mass_fraction_electron_acceptor * degraded_mass\n        mass_balance_dict[\"electron_acceptor_mass_change\"] = electron_acceptor_mass_change\n\n    return mass_balance_dict\n</code></pre>"},{"location":"reference/reference/#mibitrans.analysis.parameter_calculations","title":"<code>parameter_calculations</code>","text":"<p>Author: Jorrit Bakker.</p> <p>Module containing various methods that takes a dictionary of parameters as input and calculates the proper values that can be used in transport equations.</p>"},{"location":"reference/reference/#mibitrans.analysis.parameter_calculations.calculate_utilization","title":"<code>calculate_utilization(model)</code>","text":"<p>Function that calculates relative use of electron acceptors in biodegradation of BTEX.</p> Source code in <code>mibitrans/analysis/parameter_calculations.py</code> <pre><code>def calculate_utilization(model):\n    \"\"\"Function that calculates relative use of electron acceptors in biodegradation of BTEX.\"\"\"\n    util_factor = model.deg_pars.utilization_factor.dictionary\n    biodeg_array = np.zeros(len(list(util_factor.keys())))\n    util_array = np.zeros(len(biodeg_array))\n\n    for i, (key, value) in enumerate(util_factor.items()):\n        biodeg_array[i] = getattr(model.deg_pars, util_to_conc_name[key]) / value\n        util_array[i] = value\n\n    biodegradation_capacity = np.sum(biodeg_array)\n    fraction_total = biodeg_array / biodegradation_capacity\n    mass_fraction = fraction_total * util_array\n\n    return mass_fraction\n</code></pre>"},{"location":"reference/reference/#mibitrans.data","title":"<code>data</code>","text":""},{"location":"reference/reference/#mibitrans.data.check_input","title":"<code>check_input</code>","text":"<p>Author: Jorrit Bakker.</p> <p>Module evaluating if a dictionary contains all required (correct) parameters for analysis</p>"},{"location":"reference/reference/#mibitrans.data.check_input.validate_input_values","title":"<code>validate_input_values(parameter, value)</code>","text":"<p>Validate if input parameter is of correct type and in correct domain.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>def validate_input_values(parameter, value):\n    \"\"\"Validate if input parameter is of correct type and in correct domain.\"\"\"\n    match parameter:\n        # Any input for verbose argument is fine.\n        case \"verbose\":\n            error = None\n        # Specific check for retardation, which has domain &gt;= 1\n        case \"retardation\":\n            error = _check_float_retardation(parameter, value)\n        # Specific check for total mass, which can be a positive float, or a specific string\n        case \"total_mass\":\n            error = _check_total_mass(parameter, value)\n        # Specific check for electron acceptor utilization factor, which should be UtilizationFactor dataclass\n        case \"utilization_factor\":\n            error = _check_dataclass(parameter, value, mibitrans.data.parameter_information.UtilizationFactor)\n        # Parameters which have domain [0,1]\n        case \"porosity\" | \"fraction_organic_carbon\":\n            error = _check_float_fraction(parameter, value)\n        # Parameters which are input as single values, lists or numpy arrays\n        case \"source_zone_boundary\" | \"source_zone_concentration\":\n            error = _check_array_float_positive(parameter, value)\n        # All other parameters are checked as floats on positive domain\n        case _:\n            error = _check_float_positive(parameter, value)\n\n    if error and (value is not None):\n        raise error\n</code></pre>"},{"location":"reference/reference/#mibitrans.data.check_input.validate_source_zones","title":"<code>validate_source_zones(boundary, concentration)</code>","text":"<p>Validate and adapt input of source_zone_boundary and source_zone_concentration arrays.</p> Source code in <code>mibitrans/data/check_input.py</code> <pre><code>def validate_source_zones(boundary, concentration):\n    \"\"\"Validate and adapt input of source_zone_boundary and source_zone_concentration arrays.\"\"\"\n    # Ensure boundary and concentration are numpy arrays\n    if isinstance(boundary, (float, int, np.floating, np.integer)):\n        boundary = np.array([boundary])\n    else:\n        boundary = np.array(boundary)\n\n    if isinstance(concentration, (float, int, np.floating, np.integer)):\n        concentration = np.array([concentration])\n    else:\n        concentration = np.array(concentration)\n\n    # Each given source zone boundary should have a given concentration, and vice versa\n    if boundary.shape != concentration.shape:\n        raise ValueError(\n            f\"Length of source zone boundary ({len(boundary)}) and source zone concentration \"\n            f\"({len(concentration)}) do not match. Make sure they are of equal length.\"\n        )\n\n    # Reorder source zone locations if they are not given in order from close to far from source zone center\n    if len(boundary) &gt; 1:\n        if not all(boundary[:-1] &lt;= boundary[1:]):\n            sort_location = np.argsort(boundary)\n            boundary.sort()\n            concentration = concentration[sort_location]\n            warnings.warn(\n                \"Source zone boundary locations should be ordered by distance from source zone center. \"\n                \"Zone boundaries and concentrations have consequently been reordered as follows:\"\n                f\"Source zone boundaries: {boundary}\"\n                f\"Source zone concentrations: {concentration}\"\n            )\n        # Superposition method only works if the zone closer to the center has higher concentration than outer zones\n        if not all(concentration[:-1] &gt; concentration[1:]):\n            raise ValueError(\n                \"Source zone concentrations should be in descending order; no source zone can have a concentration \"\n                \"higher than the concentration of a zone closer to source center, due to the superposition method.\"\n            )\n    return boundary, concentration\n</code></pre>"},{"location":"reference/reference/#mibitrans.data.parameter_information","title":"<code>parameter_information</code>","text":"<p>Author: Jorrit Bakker.</p> <p>File containing various dictionaries used for evaluation of names, value types and units of input data.</p>"},{"location":"reference/reference/#mibitrans.data.parameter_information.UtilizationFactor","title":"<code>UtilizationFactor</code>  <code>dataclass</code>","text":"<p>Make UtilizationFactor object.</p> <p>Parameters:</p> Name Type Description Default <code>util_oxygen (float) </code> <p>utilization factor of oxygen, as mass of oxygen consumed per mass of biodegraded contaminant [g/g].</p> required <code>util_nitrate (float) </code> <p>utilization factor of nitrate, as mass of nitrate consumed per mass of biodegraded contaminant [g/g].</p> required <code>util_ferrous_iron (float) </code> <p>utilization factor of ferrous iron, as mass of ferrous iron generated per mass of biodegraded contaminant [g/g].</p> required <code>util_sulfate (float) </code> <p>utilization factor of sulfate, as mass of sulfate consumed per mass of biodegraded contaminant [g/g].</p> required <code>util_methane (float) </code> <p>utilization factor of methane, as mass of methane generated per mass of biodegraded contaminant [g/g].</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If input parameters are incomplete or outside the valid domain.</p> <code>TypeError</code> <p>If input parameters of incorrect datatype.</p> Source code in <code>mibitrans/data/parameter_information.py</code> <pre><code>@dataclass\nclass UtilizationFactor:\n    \"\"\"Make UtilizationFactor object.\n\n    Args:\n        util_oxygen (float) : utilization factor of oxygen, as mass of oxygen consumed\n            per mass of biodegraded contaminant [g/g].\n        util_nitrate (float) : utilization factor of nitrate, as mass of nitrate consumed\n            per mass of biodegraded contaminant [g/g].\n        util_ferrous_iron (float) : utilization factor of ferrous iron, as mass of ferrous iron generated\n            per mass of biodegraded contaminant [g/g].\n        util_sulfate (float) : utilization factor of sulfate, as mass of sulfate consumed\n            per mass of biodegraded contaminant [g/g].\n        util_methane (float) : utilization factor of methane, as mass of methane generated\n            per mass of biodegraded contaminant [g/g].\n\n    Raises:\n        ValueError : If input parameters are incomplete or outside the valid domain.\n        TypeError : If input parameters of incorrect datatype.\n\n    \"\"\"\n\n    util_oxygen: float\n    util_nitrate: float\n    util_ferrous_iron: float\n    util_sulfate: float\n    util_methane: float\n\n    def __setattr__(self, parameter, value):\n        \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n        if parameter != \"dictionary\":\n            validate_input_values(parameter, value)\n        super().__setattr__(parameter, value)\n\n    def __post_init__(self):\n        \"\"\"Initialize utilization factors as dictionary.\"\"\"\n        self.dictionary = dict(\n            util_oxygen=self.util_oxygen,\n            util_nitrate=self.util_nitrate,\n            util_ferrous_iron=self.util_ferrous_iron,\n            util_sulfate=self.util_sulfate,\n            util_methane=self.util_methane,\n        )\n</code></pre>"},{"location":"reference/reference/#mibitrans.data.parameter_information.UtilizationFactor.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initialize utilization factors as dictionary.</p> Source code in <code>mibitrans/data/parameter_information.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Initialize utilization factors as dictionary.\"\"\"\n    self.dictionary = dict(\n        util_oxygen=self.util_oxygen,\n        util_nitrate=self.util_nitrate,\n        util_ferrous_iron=self.util_ferrous_iron,\n        util_sulfate=self.util_sulfate,\n        util_methane=self.util_methane,\n    )\n</code></pre>"},{"location":"reference/reference/#mibitrans.data.parameter_information.UtilizationFactor.__setattr__","title":"<code>__setattr__(parameter, value)</code>","text":"<p>Override parent method to validate input when attribute is set.</p> Source code in <code>mibitrans/data/parameter_information.py</code> <pre><code>def __setattr__(self, parameter, value):\n    \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n    if parameter != \"dictionary\":\n        validate_input_values(parameter, value)\n    super().__setattr__(parameter, value)\n</code></pre>"},{"location":"reference/reference/#mibitrans.data.read","title":"<code>read</code>","text":"<p>Author: Jorrit Bakker.</p> <p>Module handling data input in the form of a dictionary.</p>"},{"location":"reference/reference/#mibitrans.data.read.AdsorptionParameters","title":"<code>AdsorptionParameters</code>  <code>dataclass</code>","text":"<p>Dataclass handling adsorption parameters.</p> <p>Parameters:</p> Name Type Description Default <code>retardation (float) </code> <p>Retardation factor for transported contaminant [-]. Optional if bulk_density, partition_coefficient and fraction_organic_carbon are specified.</p> required <code>bulk_density (float) </code> <p>Soil bulk density, in [g/m^3]. Optional if retardation is specified.</p> required <code>partition_coefficient (float) </code> <p>Partition coefficient of the transported contaminant to soil organic matter, in [m^3/g]. Optional if retardation is specified.</p> required <code>fraction_organic_carbon (float) </code> <p>Fraction of organic material in the soil [-]. Optional if retardation is specified.</p> required <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> <p>Methods:</p> Name Description <code>calculate_retardation </code> <p>Calculate retardation factor from bulk density, partition coefficient and fraction organic carbon when given porosity [-]</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input parameters are incomplete or outside the valid domain.</p> <code>TypeError</code> <p>If input parameters of incorrect datatype.</p> Source code in <code>mibitrans/data/read.py</code> <pre><code>@dataclass\nclass AdsorptionParameters:\n    \"\"\"Dataclass handling adsorption parameters.\n\n    Args:\n        retardation (float) : Retardation factor for transported contaminant [-]. Optional if bulk_density,\n            partition_coefficient and fraction_organic_carbon are specified.\n        bulk_density (float) : Soil bulk density, in [g/m^3]. Optional if retardation is specified.\n        partition_coefficient (float) : Partition coefficient of the transported contaminant to soil organic matter,\n            in [m^3/g]. Optional if retardation is specified.\n        fraction_organic_carbon (float) : Fraction of organic material in the soil [-].\n            Optional if retardation is specified.\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Methods:\n        calculate_retardation : Calculate retardation factor from bulk density, partition coefficient and\n            fraction organic carbon when given porosity [-]\n\n    Raises:\n        ValueError : If input parameters are incomplete or outside the valid domain.\n        TypeError : If input parameters of incorrect datatype.\n\n    \"\"\"\n\n    retardation: float = None\n    bulk_density: float = None\n    partition_coefficient: float = None\n    fraction_organic_carbon: float = None\n    verbose: bool = False\n\n    def __setattr__(self, parameter, value):\n        \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n        validate_input_values(parameter, value)\n        super().__setattr__(parameter, value)\n\n    def __post_init__(self):\n        \"\"\"Check argument presence, types and domain.\"\"\"\n        self._validate_input_presence()\n\n        if self.verbose:\n            print(\"All adsorption input arguments are present and valid.\")\n\n    def calculate_retardation(self, porosity: float):\n        \"\"\"Calculate retardation factor from soil adsorption parametrers and porosity.\"\"\"\n        self.retardation = (\n            1 + (self.bulk_density / porosity) * self.partition_coefficient * self.fraction_organic_carbon\n        )\n        if self.verbose:\n            print(f\"Retardation factor has been calculated to be {self.retardation}.\")\n\n    def _validate_input_presence(self):\n        if self.retardation is None and (\n            self.bulk_density is None or self.partition_coefficient is None or self.fraction_organic_carbon is None\n        ):\n            raise ValueError(\n                \"AdsorptionParameters missing required arguments: either retardation or \"\n                \"(bulk_density, partition_coefficient and fraction_organic_carbon).\"\n            )\n</code></pre>"},{"location":"reference/reference/#mibitrans.data.read.AdsorptionParameters.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Check argument presence, types and domain.</p> Source code in <code>mibitrans/data/read.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Check argument presence, types and domain.\"\"\"\n    self._validate_input_presence()\n\n    if self.verbose:\n        print(\"All adsorption input arguments are present and valid.\")\n</code></pre>"},{"location":"reference/reference/#mibitrans.data.read.AdsorptionParameters.__setattr__","title":"<code>__setattr__(parameter, value)</code>","text":"<p>Override parent method to validate input when attribute is set.</p> Source code in <code>mibitrans/data/read.py</code> <pre><code>def __setattr__(self, parameter, value):\n    \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n    validate_input_values(parameter, value)\n    super().__setattr__(parameter, value)\n</code></pre>"},{"location":"reference/reference/#mibitrans.data.read.AdsorptionParameters.calculate_retardation","title":"<code>calculate_retardation(porosity)</code>","text":"<p>Calculate retardation factor from soil adsorption parametrers and porosity.</p> Source code in <code>mibitrans/data/read.py</code> <pre><code>def calculate_retardation(self, porosity: float):\n    \"\"\"Calculate retardation factor from soil adsorption parametrers and porosity.\"\"\"\n    self.retardation = (\n        1 + (self.bulk_density / porosity) * self.partition_coefficient * self.fraction_organic_carbon\n    )\n    if self.verbose:\n        print(f\"Retardation factor has been calculated to be {self.retardation}.\")\n</code></pre>"},{"location":"reference/reference/#mibitrans.data.read.DegradationParameters","title":"<code>DegradationParameters</code>  <code>dataclass</code>","text":"<p>Dataclass handling degradation parameters.</p> <p>Parameters:</p> Name Type Description Default <code>decay_rate (float) </code> <p>First order (linear) decay coefficient in [1/day]. Only required for linear decay models. Optional if half_life is specified.</p> required <code>half_life (float) </code> <p>Contaminant half life for 1st order (linear) decay, in [days]. Only required for linear decay models. Optional if half_life is specified.</p> required <code>delta_oxygen (float) </code> <p>Difference between background oxygen and plume oxygen concentrations, in [g/m^3]. Only required for instant reaction models.</p> required <code>delta_nitrate (float) </code> <p>Difference between background nitrate and contaminant plume nitrate concentrations, in [g/m^3]. Only required for instant reaction models.</p> required <code>ferrous_iron (float) </code> <p>Ferrous iron concentration in contaminant plume, in [g/m^3]. Only required for instant reaction models.</p> required <code>delta_sulfate (float) </code> <p>Difference between background sulfate and plume sulfate concentrations, in [g/m^3]. Only required for instant reaction models.</p> required <code>methane (float) </code> <p>Methane concentration in contaminant plume, in [g/m^3]. Only required for instant reaction models.</p> required <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> <p>Methods:</p> Name Description <code>utilization_factor </code> <p>Customize electron acceptor utilization factors. By default, electron acceptor utilization factors for a BTEX mixture are used, based on values by Wiedemeier et al. (1995), see electron_acceptor_utilization in mibitrans.data.parameter_information.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input parameters are incomplete or outside the valid domain.</p> <code>TypeError</code> <p>If input parameters of incorrect datatype.</p> Source code in <code>mibitrans/data/read.py</code> <pre><code>@dataclass\nclass DegradationParameters:\n    \"\"\"Dataclass handling degradation parameters.\n\n    Args:\n        decay_rate (float) : First order (linear) decay coefficient in [1/day]. Only required for linear decay models.\n            Optional if half_life is specified.\n        half_life (float) : Contaminant half life for 1st order (linear) decay, in [days]. Only required for\n            linear decay models. Optional if half_life is specified.\n        delta_oxygen (float) : Difference between background oxygen and plume oxygen concentrations, in [g/m^3].\n            Only required for instant reaction models.\n        delta_nitrate (float) : Difference between background nitrate and contaminant plume nitrate concentrations,\n            in [g/m^3]. Only required for instant reaction models.\n        ferrous_iron (float) : Ferrous iron concentration in contaminant plume, in [g/m^3]. Only required for\n            instant reaction models.\n        delta_sulfate (float) : Difference between background sulfate and plume sulfate concentrations, in [g/m^3].\n            Only required for instant reaction models.\n        methane (float) : Methane concentration in contaminant plume, in [g/m^3]. Only required for\n            instant reaction models.\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Methods:\n        utilization_factor : Customize electron acceptor utilization factors. By default, electron acceptor utilization\n            factors for a BTEX mixture are used, based on values by Wiedemeier et al. (1995), see\n            electron_acceptor_utilization in mibitrans.data.parameter_information.\n\n    Raises:\n        ValueError : If input parameters are incomplete or outside the valid domain.\n        TypeError : If input parameters of incorrect datatype.\n\n    \"\"\"\n\n    decay_rate: float = None\n    half_life: float = None\n    delta_oxygen: float = None\n    delta_nitrate: float = None\n    ferrous_iron: float = None\n    delta_sulfate: float = None\n    methane: float = None\n    verbose: bool = False\n\n    def __setattr__(self, parameter, value):\n        \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n        validate_input_values(parameter, value)\n        super().__setattr__(parameter, value)\n\n    def __post_init__(self):\n        \"\"\"Check argument presence, types and domain.\"\"\"\n        self._validate_input_presence()\n        if self.half_life:\n            decay_rate = np.log(2) / self.half_life\n            if self.verbose:\n                print(f\"Decay rate has been calculate to be {decay_rate} days.\")\n            if self.decay_rate and (self.decay_rate != decay_rate):\n                warnings.warn(\n                    \"Both contaminant decay rate constant and half life are defined, but are not equal. \"\n                    \"Only value for decay rate constant will be used in calculations.\",\n                    UserWarning,\n                )\n            else:\n                self.decay_rate = decay_rate\n\n        self.utilization_factor = self.set_utilization_factor()\n        if self.verbose:\n            print(\n                f\"Utilization factors has been set to {self.utilization_factor.dictionary}. \"\n                \"To adapt them, use set_utilization_factor() method of DegradationParameters.\"\n            )\n\n    def set_utilization_factor(\n        self,\n        util_oxygen: float = 3.14,\n        util_nitrate: float = 4.9,\n        util_ferrous_iron: float = 21.8,\n        util_sulfate: float = 4.7,\n        util_methane: float = 0.78,\n    ):\n        \"\"\"Change utilization factors for each electron donor/acceptor species.\n\n        Args:\n            util_oxygen (float, optional) : utilization factor of oxygen, as mass of oxygen consumed\n                per mass of biodegraded contaminant [g/g]. Default is 3.14\n            util_nitrate (float, optional) : utilization factor of nitrate, as mass of nitrate consumed\n                per mass of biodegraded contaminant [g/g]. Default is 4.9\n            util_ferrous_iron (float, optional) : utilization factor of ferrous iron, as mass of ferrous iron generated\n                per mass of biodegraded contaminant [g/g]. Default is 21.8\n            util_sulfate (float, optional) : utilization factor of sulfate, as mass of sulfate consumed\n                per mass of biodegraded contaminant [g/g]. Default is 4.7\n            util_methane (float, optional) : utilization factor of methane, as mass of methane generated\n                per mass of biodegraded contaminant [g/g]. Default is 0.78\n\n        Raises:\n            ValueError : If input parameters are incomplete or outside the valid domain.\n            TypeError : If input parameters of incorrect datatype.\n\n        \"\"\"\n        if self.verbose:\n            print(\"Setting utilization factors...\")\n        return UtilizationFactor(util_oxygen, util_nitrate, util_ferrous_iron, util_sulfate, util_methane)\n\n    def _validate_input_presence(self):\n        if (self.decay_rate is None and self.half_life is None) and (\n            self.delta_oxygen is None\n            or self.delta_nitrate is None\n            or self.ferrous_iron is None\n            or self.delta_sulfate is None\n            or self.methane is None\n        ):\n            raise ValueError(\n                \"DegradationParameters missing missing required arguments: either decay rate or half life,\"\n                \"or electron acceptor/donor concentrations.\"\n            )\n\n    def _require_electron_acceptor(self):\n        missing_ea = []\n        if self.delta_oxygen is None:\n            missing_ea.append(\"delta_oxygen\")\n        if self.delta_nitrate is None:\n            missing_ea.append(\"delta_nitrate\")\n        if self.ferrous_iron is None:\n            missing_ea.append(\"ferrous_iron\")\n        if self.delta_sulfate is None:\n            missing_ea.append(\"delta_sulfate\")\n        if self.methane is None:\n            missing_ea.append(\"methane\")\n\n        if len(missing_ea) &gt; 0:\n            raise ValueError(f\"Instant reaction model requires concentrations of {missing_ea}.\")\n\n    def _require_linear_decay(self):\n        if self.decay_rate is None and self.half_life is None:\n            raise ValueError(\"Linear reaction model requires decay rate or half life.\")\n</code></pre>"},{"location":"reference/reference/#mibitrans.data.read.DegradationParameters.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Check argument presence, types and domain.</p> Source code in <code>mibitrans/data/read.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Check argument presence, types and domain.\"\"\"\n    self._validate_input_presence()\n    if self.half_life:\n        decay_rate = np.log(2) / self.half_life\n        if self.verbose:\n            print(f\"Decay rate has been calculate to be {decay_rate} days.\")\n        if self.decay_rate and (self.decay_rate != decay_rate):\n            warnings.warn(\n                \"Both contaminant decay rate constant and half life are defined, but are not equal. \"\n                \"Only value for decay rate constant will be used in calculations.\",\n                UserWarning,\n            )\n        else:\n            self.decay_rate = decay_rate\n\n    self.utilization_factor = self.set_utilization_factor()\n    if self.verbose:\n        print(\n            f\"Utilization factors has been set to {self.utilization_factor.dictionary}. \"\n            \"To adapt them, use set_utilization_factor() method of DegradationParameters.\"\n        )\n</code></pre>"},{"location":"reference/reference/#mibitrans.data.read.DegradationParameters.__setattr__","title":"<code>__setattr__(parameter, value)</code>","text":"<p>Override parent method to validate input when attribute is set.</p> Source code in <code>mibitrans/data/read.py</code> <pre><code>def __setattr__(self, parameter, value):\n    \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n    validate_input_values(parameter, value)\n    super().__setattr__(parameter, value)\n</code></pre>"},{"location":"reference/reference/#mibitrans.data.read.DegradationParameters.set_utilization_factor","title":"<code>set_utilization_factor(util_oxygen=3.14, util_nitrate=4.9, util_ferrous_iron=21.8, util_sulfate=4.7, util_methane=0.78)</code>","text":"<p>Change utilization factors for each electron donor/acceptor species.</p> <p>Parameters:</p> Name Type Description Default <code>util_oxygen (float, optional) </code> <p>utilization factor of oxygen, as mass of oxygen consumed per mass of biodegraded contaminant [g/g]. Default is 3.14</p> required <code>util_nitrate (float, optional) </code> <p>utilization factor of nitrate, as mass of nitrate consumed per mass of biodegraded contaminant [g/g]. Default is 4.9</p> required <code>util_ferrous_iron (float, optional) </code> <p>utilization factor of ferrous iron, as mass of ferrous iron generated per mass of biodegraded contaminant [g/g]. Default is 21.8</p> required <code>util_sulfate (float, optional) </code> <p>utilization factor of sulfate, as mass of sulfate consumed per mass of biodegraded contaminant [g/g]. Default is 4.7</p> required <code>util_methane (float, optional) </code> <p>utilization factor of methane, as mass of methane generated per mass of biodegraded contaminant [g/g]. Default is 0.78</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If input parameters are incomplete or outside the valid domain.</p> <code>TypeError</code> <p>If input parameters of incorrect datatype.</p> Source code in <code>mibitrans/data/read.py</code> <pre><code>def set_utilization_factor(\n    self,\n    util_oxygen: float = 3.14,\n    util_nitrate: float = 4.9,\n    util_ferrous_iron: float = 21.8,\n    util_sulfate: float = 4.7,\n    util_methane: float = 0.78,\n):\n    \"\"\"Change utilization factors for each electron donor/acceptor species.\n\n    Args:\n        util_oxygen (float, optional) : utilization factor of oxygen, as mass of oxygen consumed\n            per mass of biodegraded contaminant [g/g]. Default is 3.14\n        util_nitrate (float, optional) : utilization factor of nitrate, as mass of nitrate consumed\n            per mass of biodegraded contaminant [g/g]. Default is 4.9\n        util_ferrous_iron (float, optional) : utilization factor of ferrous iron, as mass of ferrous iron generated\n            per mass of biodegraded contaminant [g/g]. Default is 21.8\n        util_sulfate (float, optional) : utilization factor of sulfate, as mass of sulfate consumed\n            per mass of biodegraded contaminant [g/g]. Default is 4.7\n        util_methane (float, optional) : utilization factor of methane, as mass of methane generated\n            per mass of biodegraded contaminant [g/g]. Default is 0.78\n\n    Raises:\n        ValueError : If input parameters are incomplete or outside the valid domain.\n        TypeError : If input parameters of incorrect datatype.\n\n    \"\"\"\n    if self.verbose:\n        print(\"Setting utilization factors...\")\n    return UtilizationFactor(util_oxygen, util_nitrate, util_ferrous_iron, util_sulfate, util_methane)\n</code></pre>"},{"location":"reference/reference/#mibitrans.data.read.HydrologicalParameters","title":"<code>HydrologicalParameters</code>  <code>dataclass</code>","text":"<p>Dataclass handling input of hydrological parameters.</p> <p>Parameters:</p> Name Type Description Default <code>velocity (float) </code> <p>Flow velocity in the direction of the groundwater gradient, in [m/d]. Optional if h_gradient and h_conductivity are specified.</p> required <code>h_gradient (float) </code> <p>Hydraulic gradient of the groundwater, in [m/m]. Optional if velocity is specified.</p> required <code>h_conductivity (float) </code> <p>Hydraulic conductivity of the aquifer, in [m/d]. Optional if velocity is specified.</p> required <code>porosity (float) </code> <p>Effective soil porosity [-]</p> required <code>alpha_x (float) </code> <p>The dispersivity in the x (longitudinal) direction in [m]</p> required <code>alpha_y (float) </code> <p>The dispersivity in the y (transverse-horizontal) direction in [m]</p> required <code>alpha_z (float, optional) </code> <p>The dispersivity in the z (transverse-vertical) direction in [m]. Defaults to 1e-10</p> required <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input parameters are incomplete or outside the valid domain.</p> <code>TypeError</code> <p>If input parameters of incorrect datatype.</p> Source code in <code>mibitrans/data/read.py</code> <pre><code>@dataclass\nclass HydrologicalParameters:\n    \"\"\"Dataclass handling input of hydrological parameters.\n\n    Args:\n        velocity (float) : Flow velocity in the direction of the groundwater gradient, in [m/d]. Optional if h_gradient\n            and h_conductivity are specified.\n        h_gradient (float) : Hydraulic gradient of the groundwater, in [m/m]. Optional if velocity is specified.\n        h_conductivity (float) : Hydraulic conductivity of the aquifer, in [m/d]. Optional if velocity is specified.\n        porosity (float) : Effective soil porosity [-]\n        alpha_x (float) : The dispersivity in the x (longitudinal) direction in [m]\n        alpha_y (float) : The dispersivity in the y (transverse-horizontal) direction in [m]\n        alpha_z (float, optional) : The dispersivity in the z (transverse-vertical) direction in [m]. Defaults to 1e-10\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Raises:\n        ValueError : If input parameters are incomplete or outside the valid domain.\n        TypeError : If input parameters of incorrect datatype.\n    \"\"\"\n\n    velocity: float = None\n    h_gradient: float = None\n    h_conductivity: float = None\n    porosity: float = None\n    alpha_x: float = None\n    alpha_y: float = None\n    alpha_z: float = 1e-10\n    verbose: bool = False\n\n    def __setattr__(self, parameter, value):\n        \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n        validate_input_values(parameter, value)\n        super().__setattr__(parameter, value)\n\n    def __post_init__(self):\n        \"\"\"Check argument presence, types and domain. Calculate velocity if not given.\"\"\"\n        self._validate_input_presence()\n\n        # Velocity is calculated from hydraulic gradient and conductivity when both are given.\n        if self.h_gradient and self.h_conductivity:\n            # Giving h_gradient &amp; h_conductivity more specific than giving velocity. Input velocity will be overridden.\n            if self.velocity is not None:\n                warnings.warn(\n                    \"Both velocity and h_gradient &amp; h_conductivity are defined. Value for velocity will be overridden.\",\n                    UserWarning,\n                )\n            self.velocity = self.h_gradient * self.h_conductivity / self.porosity\n            if self.verbose:\n                print(f\"Groundwater flow velocity has been calculated to be {self.velocity} m/d.\")\n\n    def _validate_input_presence(self):\n        missing_arguments = []\n        if self.porosity is None:\n            missing_arguments.append(\"porosity\")\n        if self.alpha_x is None:\n            missing_arguments.append(\"alpha_x\")\n        if self.alpha_y is None:\n            missing_arguments.append(\"alpha_y\")\n\n        if len(missing_arguments) &gt; 0:\n            raise ValueError(f\"HydrologicalParameters missing {len(missing_arguments)} arguments: {missing_arguments}.\")\n\n        if self.velocity is None and (self.h_gradient is None or self.h_conductivity is None):\n            raise ValueError(\n                \"HydrologicalParameters missing required arguments: either velocity or both h_gradient and\"\n                \"h_conductivity.\"\n            )\n\n        if self.verbose:\n            print(\"All required hydrological input arguments are present.\")\n</code></pre>"},{"location":"reference/reference/#mibitrans.data.read.HydrologicalParameters.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Check argument presence, types and domain. Calculate velocity if not given.</p> Source code in <code>mibitrans/data/read.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Check argument presence, types and domain. Calculate velocity if not given.\"\"\"\n    self._validate_input_presence()\n\n    # Velocity is calculated from hydraulic gradient and conductivity when both are given.\n    if self.h_gradient and self.h_conductivity:\n        # Giving h_gradient &amp; h_conductivity more specific than giving velocity. Input velocity will be overridden.\n        if self.velocity is not None:\n            warnings.warn(\n                \"Both velocity and h_gradient &amp; h_conductivity are defined. Value for velocity will be overridden.\",\n                UserWarning,\n            )\n        self.velocity = self.h_gradient * self.h_conductivity / self.porosity\n        if self.verbose:\n            print(f\"Groundwater flow velocity has been calculated to be {self.velocity} m/d.\")\n</code></pre>"},{"location":"reference/reference/#mibitrans.data.read.HydrologicalParameters.__setattr__","title":"<code>__setattr__(parameter, value)</code>","text":"<p>Override parent method to validate input when attribute is set.</p> Source code in <code>mibitrans/data/read.py</code> <pre><code>def __setattr__(self, parameter, value):\n    \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n    validate_input_values(parameter, value)\n    super().__setattr__(parameter, value)\n</code></pre>"},{"location":"reference/reference/#mibitrans.data.read.ModelParameters","title":"<code>ModelParameters</code>  <code>dataclass</code>","text":"<p>Dataclass handling model discretization parameters.</p> <p>Parameters:</p> Name Type Description Default <code>model_length (float) </code> <p>Model extent in the longitudinal (x) direction in [m].</p> required <code>model_width (float) </code> <p>Model extent in the transverse horizontal (y) direction in [m].</p> required <code>model_time (float) </code> <p>Model duration in [days].</p> required <code>dx (float) </code> <p>Model grid discretization step size in the longitudinal (x) direction, in [m].</p> required <code>dy (float) </code> <p>Model grid discretization step size in the transverse horizontal (y) direction, in [m].</p> required <code>dt (float) </code> <p>Model time discretization step size, in [days]</p> required <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input parameters are incomplete or outside the valid domain.</p> <code>ValueError</code> <p>If model dimensions are smaller than their given step size.</p> <code>TypeError</code> <p>If input parameters of incorrect datatype.</p> Source code in <code>mibitrans/data/read.py</code> <pre><code>@dataclass\nclass ModelParameters:\n    \"\"\"Dataclass handling model discretization parameters.\n\n    Args:\n        model_length (float) : Model extent in the longitudinal (x) direction in [m].\n        model_width (float) : Model extent in the transverse horizontal (y) direction in [m].\n        model_time (float) : Model duration in [days].\n        dx (float) : Model grid discretization step size in the longitudinal (x) direction, in [m].\n        dy (float) : Model grid discretization step size in the transverse horizontal (y) direction, in [m].\n        dt (float) : Model time discretization step size, in [days]\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Raises:\n        ValueError : If input parameters are incomplete or outside the valid domain.\n        ValueError : If model dimensions are smaller than their given step size.\n        TypeError : If input parameters of incorrect datatype.\n\n    \"\"\"\n\n    model_length: float = None\n    model_width: float = None\n    model_time: float = None\n    dx: float = None\n    dy: float = None\n    dt: float = None\n    verbose: bool = False\n\n    def __setattr__(self, parameter, value):\n        \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n        validate_input_values(parameter, value)\n        super().__setattr__(parameter, value)\n        self._validate_stepsize(parameter)\n\n    def _validate_stepsize(self, parameter):\n        \"\"\"Validate if model step size is not larger than the corresponding model dimension.\"\"\"\n        match parameter:\n            case \"dx\" | \"model_length\":\n                if self.dx is not None and self.model_length is not None:\n                    if self.dx &gt; self.model_length:\n                        raise ValueError(\n                            f\"Model x-direction step size ({self.dx}) \"\n                            f\"is greater than the model length ({self.model_length}).\"\n                        )\n            case \"dy\" | \"model_width\":\n                if self.dy is not None and self.model_width is not None:\n                    if self.dy &gt; self.model_width:\n                        raise ValueError(\n                            f\"Model y-direction step size ({self.dy}) \"\n                            f\"is greater than the model width ({self.model_width}).\"\n                        )\n            case \"dt\" | \"model_time\":\n                if self.dt is not None and self.model_time is not None:\n                    if self.dt &gt; self.model_time:\n                        raise ValueError(\n                            f\"Model time step size ({self.dt}) \"\n                            f\"is greater than the total model time ({self.model_time}).\"\n                        )\n</code></pre>"},{"location":"reference/reference/#mibitrans.data.read.ModelParameters.__setattr__","title":"<code>__setattr__(parameter, value)</code>","text":"<p>Override parent method to validate input when attribute is set.</p> Source code in <code>mibitrans/data/read.py</code> <pre><code>def __setattr__(self, parameter, value):\n    \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n    validate_input_values(parameter, value)\n    super().__setattr__(parameter, value)\n    self._validate_stepsize(parameter)\n</code></pre>"},{"location":"reference/reference/#mibitrans.data.read.SourceParameters","title":"<code>SourceParameters</code>  <code>dataclass</code>","text":"<p>Dataclass handling source parameters. Specifying concentrations and extent of source zone.</p> <p>Parameters:</p> Name Type Description Default <code>source_zone_boundary (np.ndarray) </code> <p>Outer boundary of each source zone, in transverse horizontal direction (y-coordiante) [m]. y=0 is at the middle of the contaminant source. Input as numpy array of length equal to the amount of source zone. Last value in the array is the limit of the source. For a source with a single source zone, only one value is required. Source is symmetrical in the x-axis.</p> required <code>source_zone_concentration (np.ndarray) </code> <p>Contaminant concentration in each source zone [g/m^3]. Input as numpy array in the same order and of the same length as specified in source_zone_boundary.</p> required <code>depth (float) </code> <p>Depth (transeverse vertical or z-dimension) of the source zone in [m].</p> required <code>total_mass (float | str) </code> <p>Mass of contaminant present in source zone, either expressed in [g], or set to \u2018infinite\u2019. The latter meaning that the source mass and therefore, the source zone concentrations do not diminish over time.</p> required <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input parameters are incomplete or outside the valid domain.</p> <code>TypeError</code> <p>If input parameters of incorrect datatype.</p> Source code in <code>mibitrans/data/read.py</code> <pre><code>@dataclass\nclass SourceParameters:\n    \"\"\"Dataclass handling source parameters. Specifying concentrations and extent of source zone.\n\n    Args:\n        source_zone_boundary (np.ndarray) : Outer boundary of each source zone, in transverse horizontal direction\n            (y-coordiante) [m]. y=0 is at the middle of the contaminant source. Input as numpy array of length equal\n            to the amount of source zone. Last value in the array is the limit of the source. For a source with a single\n            source zone, only one value is required. Source is symmetrical in the x-axis.\n        source_zone_concentration (np.ndarray) : Contaminant concentration in each source zone [g/m^3]. Input as numpy\n            array in the same order and of the same length as specified in source_zone_boundary.\n        depth (float) : Depth (transeverse vertical or z-dimension) of the source zone in [m].\n        total_mass (float | str) : Mass of contaminant present in source zone, either expressed in [g],\n            or set to 'infinite'. The latter meaning that the source mass and therefore, the source zone concentrations\n            do not diminish over time.\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Raises:\n        ValueError : If input parameters are incomplete or outside the valid domain.\n        TypeError : If input parameters of incorrect datatype.\n    \"\"\"\n\n    source_zone_boundary: np.ndarray = None\n    source_zone_concentration: np.ndarray = None\n    depth: float = None\n    total_mass: float | str = \"infinite\"\n    verbose: bool = False\n\n    def __setattr__(self, parameter, value):\n        \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n        validate_input_values(parameter, value)\n        super().__setattr__(parameter, value)\n        # When setting source zone boundary or concentration, and both present, check validity in respect to each other.\n        if parameter in [\"source_zone_boundary\", \"source_zone_concentration\"] and (\n            self.source_zone_boundary is not None and self.source_zone_concentration is not None\n        ):\n            boundary, concentration = validate_source_zones(self.source_zone_boundary, self.source_zone_concentration)\n            super().__setattr__(\"source_zone_boundary\", boundary)\n            super().__setattr__(\"source_zone_concentration\", concentration)\n\n    def __post_init__(self):\n        \"\"\"Check argument presence, types and domain.\"\"\"\n        self._validate_input_presence()\n\n        # Make sure naming for infinite source mass is consistent from this point onward\n        if isinstance(self.total_mass, str):\n            self.total_mass = \"infinite\"\n\n    def interpolate(self, n_zones, method):\n        \"\"\"Rediscretize source to n zones. Either through linear interpolation or using a normal distribution.\"\"\"\n        warnings.warn(\"This functionality is not implemented yet. Try again later.\")\n        return None\n\n    def _validate_input_presence(self):\n        # Check if all required arguments are present\n        missing_arguments = []\n        if self.source_zone_boundary is None:\n            missing_arguments.append(\"source_zone_boundary\")\n        if self.source_zone_concentration is None:\n            missing_arguments.append(\"source_zone_concentration\")\n        if self.depth is None:\n            missing_arguments.append(\"depth\")\n\n        if len(missing_arguments) &gt; 0:\n            raise ValueError(f\"SourceParameters missing {len(missing_arguments)} arguments: {missing_arguments}.\")\n</code></pre>"},{"location":"reference/reference/#mibitrans.data.read.SourceParameters.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Check argument presence, types and domain.</p> Source code in <code>mibitrans/data/read.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Check argument presence, types and domain.\"\"\"\n    self._validate_input_presence()\n\n    # Make sure naming for infinite source mass is consistent from this point onward\n    if isinstance(self.total_mass, str):\n        self.total_mass = \"infinite\"\n</code></pre>"},{"location":"reference/reference/#mibitrans.data.read.SourceParameters.__setattr__","title":"<code>__setattr__(parameter, value)</code>","text":"<p>Override parent method to validate input when attribute is set.</p> Source code in <code>mibitrans/data/read.py</code> <pre><code>def __setattr__(self, parameter, value):\n    \"\"\"Override parent method to validate input when attribute is set.\"\"\"\n    validate_input_values(parameter, value)\n    super().__setattr__(parameter, value)\n    # When setting source zone boundary or concentration, and both present, check validity in respect to each other.\n    if parameter in [\"source_zone_boundary\", \"source_zone_concentration\"] and (\n        self.source_zone_boundary is not None and self.source_zone_concentration is not None\n    ):\n        boundary, concentration = validate_source_zones(self.source_zone_boundary, self.source_zone_concentration)\n        super().__setattr__(\"source_zone_boundary\", boundary)\n        super().__setattr__(\"source_zone_concentration\", concentration)\n</code></pre>"},{"location":"reference/reference/#mibitrans.data.read.SourceParameters.interpolate","title":"<code>interpolate(n_zones, method)</code>","text":"<p>Rediscretize source to n zones. Either through linear interpolation or using a normal distribution.</p> Source code in <code>mibitrans/data/read.py</code> <pre><code>def interpolate(self, n_zones, method):\n    \"\"\"Rediscretize source to n zones. Either through linear interpolation or using a normal distribution.\"\"\"\n    warnings.warn(\"This functionality is not implemented yet. Try again later.\")\n    return None\n</code></pre>"},{"location":"reference/reference/#mibitrans.transport","title":"<code>transport</code>","text":""},{"location":"reference/reference/#mibitrans.transport.domenico","title":"<code>domenico</code>","text":"<p>Author: Jorrit Bakker.</p> <p>Module calculating the solution to the Domenico (1987) analytical model adapted in BIOSCREEN, for different scenarios.</p> <p>Domenico, P. A. (1987). An analytical model for multidimensional transport of a decaying contaminant species. Journal of Hydrology, 91(1-2), 49-58.</p>"},{"location":"reference/reference/#mibitrans.transport.domenico.Domenico","title":"<code>Domenico</code>","text":"<p>Parent class that for all analytical solutions using on the Domenico (1987) analytical model.</p> <p>Domenico, P. A. (1987). An analytical model for multidimensional transport of a decaying contaminant species. Journal of Hydrology, 91(1-2), 49-58.</p> Source code in <code>mibitrans/transport/domenico.py</code> <pre><code>class Domenico:\n    \"\"\"Parent class that for all analytical solutions using on the Domenico (1987) analytical model.\n\n    Domenico, P. A. (1987). An analytical model for multidimensional transport of a decaying contaminant species.\n    Journal of Hydrology, 91(1-2), 49-58.\n    \"\"\"\n\n    def __init__(\n        self, hydrological_parameters, adsorption_parameters, source_parameters, model_parameters, verbose=False\n    ):\n        \"\"\"Initialize parent class object.\n\n        Args:\n        hydrological_parameters (mibitrans.data.read.HydrologicalParameters) : Dataclass object containing hydrological\n            parameters from HydrologicalParameters.\n        adsorption_parameters (mibitrans.data.read.AdsorptionParameters) : Dataclass object containing adsorption\n            parameters from AdsorptionParameters.\n        source_parameters (mibitrans.data.read.SourceParameters) : Dataclass object containing source parameters\n            from SourceParameters.\n        model_parameters (mibitrans.data.read.ModelParameters) : Dataclass object containing model parameters from\n            ModelParameters.\n        verbose (bool, optional): Verbose mode. Defaults to False.\n        \"\"\"\n        self.hyd_pars = hydrological_parameters\n        self.ads_pars = adsorption_parameters\n        self.src_pars = source_parameters\n        self.mod_pars = model_parameters\n        self.verbose = verbose\n\n        # Check if input arguments are of the correct dataclass\n        for key in self.__dict__.keys():\n            if key != \"verbose\":\n                self._check_input_dataclasses(key)\n\n        # One-dimensional model domain arrays\n        self.x = np.arange(0, self.mod_pars.model_length + self.mod_pars.dx, self.mod_pars.dx)\n        self.y = self._calculate_y()\n        self.t = np.arange(self.mod_pars.dt, self.mod_pars.model_time + self.mod_pars.dt, self.mod_pars.dt)\n\n        # Three-dimensional model domain arrays\n        self.xxx = np.tile(self.x, (len(self.t), len(self.y), 1))\n        self.yyy = np.tile(self.y[:, None], (len(self.t), 1, len(self.x)))\n        self.ttt = np.tile(self.t[:, None, None], (1, len(self.y), len(self.x)))\n        # cxyt is concentration output array\n        self.cxyt = np.zeros(self.xxx.shape)\n\n        # Calculate retardation if not already specified in adsorption_parameters\n        if self.ads_pars.retardation is None:\n            self.ads_pars.calculate_retardation(self.hyd_pars.porosity)\n        # Calculate retarded velocity\n        self.rv = self.hyd_pars.velocity / self.ads_pars.retardation\n\n        self.k_source = self.calculate_source_decay()\n        self.y_source = self.src_pars.source_zone_boundary\n        # Subtract outer source zones from inner source zones\n        self.c_source = self.src_pars.source_zone_concentration.copy()\n        self.c_source[:-1] = self.c_source[:-1] - self.c_source[1:]\n\n    def _check_input_dataclasses(self, expected_class):\n        \"\"\"Check if input parameters are the correct dataclasses. Raise an error if not.\"\"\"\n        dataclass_dict = {\n            \"hyd_pars\": mibitrans.data.read.HydrologicalParameters,\n            \"ads_pars\": mibitrans.data.read.AdsorptionParameters,\n            \"deg_pars\": mibitrans.data.read.DegradationParameters,\n            \"src_pars\": mibitrans.data.read.SourceParameters,\n            \"mod_pars\": mibitrans.data.read.ModelParameters,\n        }\n\n        rename_dict = {\n            \"hyd_pars\": \"hydrological_parameters\",\n            \"ads_pars\": \"adsorption_parameters\",\n            \"deg_pars\": \"degradation_parameters\",\n            \"src_pars\": \"source_parameters\",\n            \"mod_pars\": \"model_parameters\",\n        }\n\n        if not isinstance(self.__dict__[expected_class], dataclass_dict[expected_class]):\n            raise TypeError(\n                f\"Input argument {rename_dict[expected_class]} should be {dataclass_dict[expected_class]}, \"\n                f\"but is {type(self.__dict__[expected_class])} instead.\"\n            )\n\n    # Could be moved to general file with functions, since every solution will use this\n    def _calculate_y(self):\n        \"\"\"Calculate y-direction discretization.\"\"\"\n        if self.mod_pars.model_width &gt;= 2 * self.src_pars.source_zone_boundary[-1]:\n            y = np.arange(\n                -self.mod_pars.model_width / 2, self.mod_pars.model_width / 2 + self.mod_pars.dy, self.mod_pars.dy\n            )\n        else:\n            y = np.arange(\n                -self.src_pars.source_zone_boundary[-1],\n                self.src_pars.source_zone_boundary[-1] + self.mod_pars.dy,\n                self.mod_pars.dy,\n            )\n            warnings.warn(\n                \"Source zone boundary is larger than model width. Model width adjusted to fit entire source zone.\"\n            )\n        return y\n\n    def calculate_source_decay(self, biodegradation_capacity=0):\n        \"\"\"Calculate source decay, for instant_reaction, biodegradation_capacity is requried.\"\"\"\n        if isinstance(self.src_pars.total_mass, (float, int)):\n            y_src = np.zeros(len(self.src_pars.source_zone_boundary) + 1)\n            y_src[1:] = self.src_pars.source_zone_boundary\n            c_src = self.src_pars.source_zone_concentration\n            Q = self.hyd_pars.velocity * self.hyd_pars.porosity * self.src_pars.depth * np.max(y_src) * 2\n\n            weighted_conc = np.zeros(len(self.src_pars.source_zone_boundary))\n            for i in range(len(self.src_pars.source_zone_boundary)):\n                weighted_conc[i] = (y_src[i + 1] - y_src[i]) * c_src[i]\n\n            c0_avg = biodegradation_capacity + np.sum(weighted_conc) / np.max(y_src)\n            k_source = Q * c0_avg / self.src_pars.total_mass\n        # If source mass is not a float, it is an infinite source, therefore, no source decay takes place.\n        else:\n            k_source = 0\n\n        return k_source\n\n    def _eq_x_term(self, decay_sqrt=1):\n        return erfc(\n            (self.xxx - self.hyd_pars.velocity * self.ttt * decay_sqrt)\n            / (2 * np.sqrt(self.hyd_pars.alpha_x * self.hyd_pars.velocity * self.ttt))\n        )\n\n    def _eq_additional_x(self):\n        return np.exp(self.xxx * self.hyd_pars.velocity / (self.hyd_pars.alpha_x * self.hyd_pars.velocity)) * (\n            erfc(\n                self.xxx\n                + self.hyd_pars.velocity\n                * self.ttt\n                / (2 * np.sqrt(self.hyd_pars.alpha_x * self.hyd_pars.velocity * self.ttt))\n            )\n        )\n\n    def _eq_z_term(self):\n        inner_term = self.src_pars.depth / (2 * np.sqrt(self.hyd_pars.alpha_z * self.xxx))\n        return erf(inner_term) - erf(-inner_term)\n\n    def _eq_source_decay(self):\n        term = np.exp(-self.k_source * (self.ttt - self.xxx / self.hyd_pars.velocity))\n        # Term can be max 1; can not have 'generation' of solute ahead of advection.\n        return np.where(term &gt; 1, 1, term)\n\n    def _eq_y_term(self, i):\n        div_term = 2 * np.sqrt(self.hyd_pars.alpha_y * self.xxx)\n        term = erf((self.yyy + self.y_source[i]) / div_term) - erf((self.yyy - self.y_source[i]) / div_term)\n        term[np.isnan(term)] = 0\n        return term\n</code></pre>"},{"location":"reference/reference/#mibitrans.transport.domenico.Domenico.__init__","title":"<code>__init__(hydrological_parameters, adsorption_parameters, source_parameters, model_parameters, verbose=False)</code>","text":"<p>Initialize parent class object.</p> <p>hydrological_parameters (mibitrans.data.read.HydrologicalParameters) : Dataclass object containing hydrological     parameters from HydrologicalParameters. adsorption_parameters (mibitrans.data.read.AdsorptionParameters) : Dataclass object containing adsorption     parameters from AdsorptionParameters. source_parameters (mibitrans.data.read.SourceParameters) : Dataclass object containing source parameters     from SourceParameters. model_parameters (mibitrans.data.read.ModelParameters) : Dataclass object containing model parameters from     ModelParameters. verbose (bool, optional): Verbose mode. Defaults to False.</p> Source code in <code>mibitrans/transport/domenico.py</code> <pre><code>def __init__(\n    self, hydrological_parameters, adsorption_parameters, source_parameters, model_parameters, verbose=False\n):\n    \"\"\"Initialize parent class object.\n\n    Args:\n    hydrological_parameters (mibitrans.data.read.HydrologicalParameters) : Dataclass object containing hydrological\n        parameters from HydrologicalParameters.\n    adsorption_parameters (mibitrans.data.read.AdsorptionParameters) : Dataclass object containing adsorption\n        parameters from AdsorptionParameters.\n    source_parameters (mibitrans.data.read.SourceParameters) : Dataclass object containing source parameters\n        from SourceParameters.\n    model_parameters (mibitrans.data.read.ModelParameters) : Dataclass object containing model parameters from\n        ModelParameters.\n    verbose (bool, optional): Verbose mode. Defaults to False.\n    \"\"\"\n    self.hyd_pars = hydrological_parameters\n    self.ads_pars = adsorption_parameters\n    self.src_pars = source_parameters\n    self.mod_pars = model_parameters\n    self.verbose = verbose\n\n    # Check if input arguments are of the correct dataclass\n    for key in self.__dict__.keys():\n        if key != \"verbose\":\n            self._check_input_dataclasses(key)\n\n    # One-dimensional model domain arrays\n    self.x = np.arange(0, self.mod_pars.model_length + self.mod_pars.dx, self.mod_pars.dx)\n    self.y = self._calculate_y()\n    self.t = np.arange(self.mod_pars.dt, self.mod_pars.model_time + self.mod_pars.dt, self.mod_pars.dt)\n\n    # Three-dimensional model domain arrays\n    self.xxx = np.tile(self.x, (len(self.t), len(self.y), 1))\n    self.yyy = np.tile(self.y[:, None], (len(self.t), 1, len(self.x)))\n    self.ttt = np.tile(self.t[:, None, None], (1, len(self.y), len(self.x)))\n    # cxyt is concentration output array\n    self.cxyt = np.zeros(self.xxx.shape)\n\n    # Calculate retardation if not already specified in adsorption_parameters\n    if self.ads_pars.retardation is None:\n        self.ads_pars.calculate_retardation(self.hyd_pars.porosity)\n    # Calculate retarded velocity\n    self.rv = self.hyd_pars.velocity / self.ads_pars.retardation\n\n    self.k_source = self.calculate_source_decay()\n    self.y_source = self.src_pars.source_zone_boundary\n    # Subtract outer source zones from inner source zones\n    self.c_source = self.src_pars.source_zone_concentration.copy()\n    self.c_source[:-1] = self.c_source[:-1] - self.c_source[1:]\n</code></pre>"},{"location":"reference/reference/#mibitrans.transport.domenico.Domenico.calculate_source_decay","title":"<code>calculate_source_decay(biodegradation_capacity=0)</code>","text":"<p>Calculate source decay, for instant_reaction, biodegradation_capacity is requried.</p> Source code in <code>mibitrans/transport/domenico.py</code> <pre><code>def calculate_source_decay(self, biodegradation_capacity=0):\n    \"\"\"Calculate source decay, for instant_reaction, biodegradation_capacity is requried.\"\"\"\n    if isinstance(self.src_pars.total_mass, (float, int)):\n        y_src = np.zeros(len(self.src_pars.source_zone_boundary) + 1)\n        y_src[1:] = self.src_pars.source_zone_boundary\n        c_src = self.src_pars.source_zone_concentration\n        Q = self.hyd_pars.velocity * self.hyd_pars.porosity * self.src_pars.depth * np.max(y_src) * 2\n\n        weighted_conc = np.zeros(len(self.src_pars.source_zone_boundary))\n        for i in range(len(self.src_pars.source_zone_boundary)):\n            weighted_conc[i] = (y_src[i + 1] - y_src[i]) * c_src[i]\n\n        c0_avg = biodegradation_capacity + np.sum(weighted_conc) / np.max(y_src)\n        k_source = Q * c0_avg / self.src_pars.total_mass\n    # If source mass is not a float, it is an infinite source, therefore, no source decay takes place.\n    else:\n        k_source = 0\n\n    return k_source\n</code></pre>"},{"location":"reference/reference/#mibitrans.transport.domenico.InstantReaction","title":"<code>InstantReaction</code>","text":"<p>               Bases: <code>Domenico</code></p> <p>Calculate contaminant transport using the Domenico (1987) analytical model instant reaction biodegradation .</p> Source code in <code>mibitrans/transport/domenico.py</code> <pre><code>class InstantReaction(Domenico):\n    \"\"\"Calculate contaminant transport using the Domenico (1987) analytical model instant reaction biodegradation .\"\"\"\n\n    def __init__(\n        self,\n        hydrological_parameters,\n        adsorption_parameters,\n        degradation_parameters,\n        source_parameters,\n        model_parameters,\n        verbose=False,\n    ):\n        \"\"\"Initialize object and run model.\n\n        Args:\n        hydrological_parameters (mibitrans.data.read.HydrologicalParameters) : Dataclass object containing hydrological\n            parameters from HydrologicalParameters.\n        adsorption_parameters (mibitrans.data.read.AdsorptionParameters) : Dataclass object containing adsorption\n            parameters from AdsorptionParameters.\n        degradation_parameters (mibitrans.data.read.DegradationParameters) : Dataclass object containing degradation\n            parameters from DegradationParameters.\n        source_parameters (mibitrans.data.read.SourceParameters) : Dataclass object containing source parameters from\n            SourceParameters.\n        model_parameters (mibitrans.data.read.ModelParameters) : Dataclass object containing model parameters from\n            ModelParameters.\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n        Attributes:\n            cxyt (np.ndarray) : Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]\n            x (np.ndarray) : Discretized model x-dimension, in [m].\n            y (np.ndarray) : Discretized model y-dimension, in [y].\n            t (np.ndarray) : Discretized model t-dimension, in [days].\n            c_source (np.ndarray) : Nett source zone concentrations, accounting for source superposition, in [g/m^3].\n            vr (float) : Retarded groundwater flow velocity, in [m/d].\n            k_source (float) : Source zone decay rate, in [1/days]\n            biodegradation_capacity (float) : Maximum capacity of contaminant degradation based on electron\n            acceptor/donor concentrations, in [g/m^3].\n            cxyt_noBC (np.ndarray) : Concentration array in same shape as cxyt, before subtracting\n                biodegration_capacity.\n\n        Raises:\n            TypeError : If input is not of the correct Dataclass.\n\n        \"\"\"\n        super().__init__(hydrological_parameters, adsorption_parameters, source_parameters, model_parameters, verbose)\n        self.deg_pars = degradation_parameters\n        self._check_input_dataclasses(\"deg_pars\")\n        self.deg_pars._require_electron_acceptor()\n        self.biodegradation_capacity = self._calculate_biodegradation_capacity()\n        self.k_source = self.calculate_source_decay(self.biodegradation_capacity)\n        # Source decay calculation uses self.c_source, therefore, addition of biodegradation_capacity to\n        # outer source zone after calculation of k_source\n        self.c_source[-1] += self.biodegradation_capacity\n        self.cxyt_noBC = 0\n        self._calculate()\n\n    def _calculate_biodegradation_capacity(self):\n        biodegradation_capacity = 0\n        utilization_factor = getattr(self.deg_pars, \"utilization_factor\").dictionary\n        for key, item in utilization_factor.items():\n            biodegradation_capacity += getattr(self.deg_pars, util_to_conc_name[key]) / item\n\n        return biodegradation_capacity\n\n    def _calculate(self):\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            x_term = self._eq_x_term()\n            additional_x = self._eq_additional_x()\n            z_term = self._eq_z_term()\n            source_decay = self._eq_source_decay()\n\n            for i in range(len(self.c_source)):\n                y_term = self._eq_y_term(i)\n                cxyt = 1 / 8 * self.c_source[i] * source_decay * (x_term + additional_x) * y_term * z_term\n                self.cxyt += cxyt\n\n            self.cxyt_noBC = self.cxyt.copy()\n            self.cxyt -= self.biodegradation_capacity\n            self.cxyt = np.where(self.cxyt &lt; 0, 0, self.cxyt)\n</code></pre>"},{"location":"reference/reference/#mibitrans.transport.domenico.InstantReaction.__init__","title":"<code>__init__(hydrological_parameters, adsorption_parameters, degradation_parameters, source_parameters, model_parameters, verbose=False)</code>","text":"<p>Initialize object and run model.</p> <p>hydrological_parameters (mibitrans.data.read.HydrologicalParameters) : Dataclass object containing hydrological     parameters from HydrologicalParameters. adsorption_parameters (mibitrans.data.read.AdsorptionParameters) : Dataclass object containing adsorption     parameters from AdsorptionParameters. degradation_parameters (mibitrans.data.read.DegradationParameters) : Dataclass object containing degradation     parameters from DegradationParameters. source_parameters (mibitrans.data.read.SourceParameters) : Dataclass object containing source parameters from     SourceParameters. model_parameters (mibitrans.data.read.ModelParameters) : Dataclass object containing model parameters from     ModelParameters. verbose (bool, optional): Verbose mode. Defaults to False.</p> <p>Attributes:</p> Name Type Description <code>cxyt</code> <code>np.ndarray) </code> <p>Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]</p> <code>x</code> <code>np.ndarray) </code> <p>Discretized model x-dimension, in [m].</p> <code>y</code> <code>np.ndarray) </code> <p>Discretized model y-dimension, in [y].</p> <code>t</code> <code>np.ndarray) </code> <p>Discretized model t-dimension, in [days].</p> <code>c_source</code> <code>np.ndarray) </code> <p>Nett source zone concentrations, accounting for source superposition, in [g/m^3].</p> <code>vr</code> <code>float) </code> <p>Retarded groundwater flow velocity, in [m/d].</p> <code>k_source</code> <code>float) </code> <p>Source zone decay rate, in [1/days]</p> <code>biodegradation_capacity</code> <code>float) </code> <p>Maximum capacity of contaminant degradation based on electron</p> <code>cxyt_noBC</code> <code>np.ndarray) </code> <p>Concentration array in same shape as cxyt, before subtracting biodegration_capacity.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input is not of the correct Dataclass.</p> Source code in <code>mibitrans/transport/domenico.py</code> <pre><code>def __init__(\n    self,\n    hydrological_parameters,\n    adsorption_parameters,\n    degradation_parameters,\n    source_parameters,\n    model_parameters,\n    verbose=False,\n):\n    \"\"\"Initialize object and run model.\n\n    Args:\n    hydrological_parameters (mibitrans.data.read.HydrologicalParameters) : Dataclass object containing hydrological\n        parameters from HydrologicalParameters.\n    adsorption_parameters (mibitrans.data.read.AdsorptionParameters) : Dataclass object containing adsorption\n        parameters from AdsorptionParameters.\n    degradation_parameters (mibitrans.data.read.DegradationParameters) : Dataclass object containing degradation\n        parameters from DegradationParameters.\n    source_parameters (mibitrans.data.read.SourceParameters) : Dataclass object containing source parameters from\n        SourceParameters.\n    model_parameters (mibitrans.data.read.ModelParameters) : Dataclass object containing model parameters from\n        ModelParameters.\n    verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Attributes:\n        cxyt (np.ndarray) : Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]\n        x (np.ndarray) : Discretized model x-dimension, in [m].\n        y (np.ndarray) : Discretized model y-dimension, in [y].\n        t (np.ndarray) : Discretized model t-dimension, in [days].\n        c_source (np.ndarray) : Nett source zone concentrations, accounting for source superposition, in [g/m^3].\n        vr (float) : Retarded groundwater flow velocity, in [m/d].\n        k_source (float) : Source zone decay rate, in [1/days]\n        biodegradation_capacity (float) : Maximum capacity of contaminant degradation based on electron\n        acceptor/donor concentrations, in [g/m^3].\n        cxyt_noBC (np.ndarray) : Concentration array in same shape as cxyt, before subtracting\n            biodegration_capacity.\n\n    Raises:\n        TypeError : If input is not of the correct Dataclass.\n\n    \"\"\"\n    super().__init__(hydrological_parameters, adsorption_parameters, source_parameters, model_parameters, verbose)\n    self.deg_pars = degradation_parameters\n    self._check_input_dataclasses(\"deg_pars\")\n    self.deg_pars._require_electron_acceptor()\n    self.biodegradation_capacity = self._calculate_biodegradation_capacity()\n    self.k_source = self.calculate_source_decay(self.biodegradation_capacity)\n    # Source decay calculation uses self.c_source, therefore, addition of biodegradation_capacity to\n    # outer source zone after calculation of k_source\n    self.c_source[-1] += self.biodegradation_capacity\n    self.cxyt_noBC = 0\n    self._calculate()\n</code></pre>"},{"location":"reference/reference/#mibitrans.transport.domenico.LinearDecay","title":"<code>LinearDecay</code>","text":"<p>               Bases: <code>Domenico</code></p> <p>Calculate contaminant transport using the Domenico (1987) analytical model with a linear decay isotherm.</p> Source code in <code>mibitrans/transport/domenico.py</code> <pre><code>class LinearDecay(Domenico):\n    \"\"\"Calculate contaminant transport using the Domenico (1987) analytical model with a linear decay isotherm.\"\"\"\n\n    def __init__(\n        self,\n        hydrological_parameters,\n        adsorption_parameters,\n        degradation_parameters,\n        source_parameters,\n        model_parameters,\n        verbose=False,\n    ):\n        \"\"\"Initialize object and run model.\n\n        Args:\n            hydrological_parameters (mibitrans.data.read.HydrologicalParameters) : Dataclass object containing\n                hydrological parameters from HydrologicalParameters.\n            adsorption_parameters (mibitrans.data.read.AdsorptionParameters) : Dataclass object containing adsorption\n                parameters from AdsorptionParameters.\n            degradation_parameters (mibitrans.data.read.DegradationParameters) : Dataclass object containing degradation\n                parameters from DegradationParameters.\n            source_parameters (mibitrans.data.read.SourceParameters) : Dataclass object containing source parameters\n                from SourceParameters.\n            model_parameters (mibitrans.data.read.ModelParameters) : Dataclass object containing model parameters from\n                ModelParameters.\n            verbose (bool, optional): Verbose mode. Defaults to False.\n\n        Attributes:\n            cxyt (np.ndarray) : Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]\n            x (np.ndarray) : Discretized model x-dimension, in [m].\n            y (np.ndarray) : Discretized model y-dimension, in [y].\n            t (np.ndarray) : Discretized model t-dimension, in [days].\n            c_source (np.ndarray) : Nett source zone concentrations, accounting for source superposition, in [g/m^3].\n            vr (float) : Retarded groundwater flow velocity, in [m/d].\n            k_source (float) : Source zone decay rate, in [1/days]\n\n        Raises:\n            TypeError : If input is not of the correct Dataclass.\n\n        \"\"\"\n        super().__init__(hydrological_parameters, adsorption_parameters, source_parameters, model_parameters, verbose)\n        self.deg_pars = degradation_parameters\n        self._check_input_dataclasses(\"deg_pars\")\n        self.deg_pars._require_linear_decay()\n        self._calculate()\n\n    def _calculate(self):\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            decay_sqrt = np.sqrt(1 + 4 * self.deg_pars.decay_rate * self.hyd_pars.alpha_x / self.hyd_pars.velocity)\n            decay_term = np.exp(self.xxx * (1 - decay_sqrt) / (self.hyd_pars.alpha_x * 2))\n            x_term = self._eq_x_term(decay_sqrt)\n            z_term = self._eq_z_term()\n            source_decay = self._eq_source_decay()\n            for i in range(len(self.c_source)):\n                y_term = self._eq_y_term(i)\n                cxyt = 1 / 8 * self.c_source[i] * source_decay * decay_term * x_term * y_term * z_term\n                self.cxyt += cxyt\n</code></pre>"},{"location":"reference/reference/#mibitrans.transport.domenico.LinearDecay.__init__","title":"<code>__init__(hydrological_parameters, adsorption_parameters, degradation_parameters, source_parameters, model_parameters, verbose=False)</code>","text":"<p>Initialize object and run model.</p> <p>Parameters:</p> Name Type Description Default <code>hydrological_parameters (mibitrans.data.read.HydrologicalParameters) </code> <p>Dataclass object containing hydrological parameters from HydrologicalParameters.</p> required <code>adsorption_parameters (mibitrans.data.read.AdsorptionParameters) </code> <p>Dataclass object containing adsorption parameters from AdsorptionParameters.</p> required <code>degradation_parameters (mibitrans.data.read.DegradationParameters) </code> <p>Dataclass object containing degradation parameters from DegradationParameters.</p> required <code>source_parameters (mibitrans.data.read.SourceParameters) </code> <p>Dataclass object containing source parameters from SourceParameters.</p> required <code>model_parameters (mibitrans.data.read.ModelParameters) </code> <p>Dataclass object containing model parameters from ModelParameters.</p> required <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>cxyt</code> <code>np.ndarray) </code> <p>Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]</p> <code>x</code> <code>np.ndarray) </code> <p>Discretized model x-dimension, in [m].</p> <code>y</code> <code>np.ndarray) </code> <p>Discretized model y-dimension, in [y].</p> <code>t</code> <code>np.ndarray) </code> <p>Discretized model t-dimension, in [days].</p> <code>c_source</code> <code>np.ndarray) </code> <p>Nett source zone concentrations, accounting for source superposition, in [g/m^3].</p> <code>vr</code> <code>float) </code> <p>Retarded groundwater flow velocity, in [m/d].</p> <code>k_source</code> <code>float) </code> <p>Source zone decay rate, in [1/days]</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input is not of the correct Dataclass.</p> Source code in <code>mibitrans/transport/domenico.py</code> <pre><code>def __init__(\n    self,\n    hydrological_parameters,\n    adsorption_parameters,\n    degradation_parameters,\n    source_parameters,\n    model_parameters,\n    verbose=False,\n):\n    \"\"\"Initialize object and run model.\n\n    Args:\n        hydrological_parameters (mibitrans.data.read.HydrologicalParameters) : Dataclass object containing\n            hydrological parameters from HydrologicalParameters.\n        adsorption_parameters (mibitrans.data.read.AdsorptionParameters) : Dataclass object containing adsorption\n            parameters from AdsorptionParameters.\n        degradation_parameters (mibitrans.data.read.DegradationParameters) : Dataclass object containing degradation\n            parameters from DegradationParameters.\n        source_parameters (mibitrans.data.read.SourceParameters) : Dataclass object containing source parameters\n            from SourceParameters.\n        model_parameters (mibitrans.data.read.ModelParameters) : Dataclass object containing model parameters from\n            ModelParameters.\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Attributes:\n        cxyt (np.ndarray) : Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]\n        x (np.ndarray) : Discretized model x-dimension, in [m].\n        y (np.ndarray) : Discretized model y-dimension, in [y].\n        t (np.ndarray) : Discretized model t-dimension, in [days].\n        c_source (np.ndarray) : Nett source zone concentrations, accounting for source superposition, in [g/m^3].\n        vr (float) : Retarded groundwater flow velocity, in [m/d].\n        k_source (float) : Source zone decay rate, in [1/days]\n\n    Raises:\n        TypeError : If input is not of the correct Dataclass.\n\n    \"\"\"\n    super().__init__(hydrological_parameters, adsorption_parameters, source_parameters, model_parameters, verbose)\n    self.deg_pars = degradation_parameters\n    self._check_input_dataclasses(\"deg_pars\")\n    self.deg_pars._require_linear_decay()\n    self._calculate()\n</code></pre>"},{"location":"reference/reference/#mibitrans.transport.domenico.NoDecay","title":"<code>NoDecay</code>","text":"<p>               Bases: <code>Domenico</code></p> <p>Calculate contaminant transport using the Domenico (1987) analytical model without degradation.</p> Source code in <code>mibitrans/transport/domenico.py</code> <pre><code>class NoDecay(Domenico):\n    \"\"\"Calculate contaminant transport using the Domenico (1987) analytical model without degradation.\"\"\"\n\n    def __init__(\n        self, hydrological_parameters, adsorption_parameters, source_parameters, model_parameters, verbose=False\n    ):\n        \"\"\"Initialize object and run model.\n\n        Args:\n            hydrological_parameters (mibitrans.data.read.HydrologicalParameters) : Dataclass object containing\n            hydrological parameters from HydrologicalParameters.\n            adsorption_parameters (mibitrans.data.read.AdsorptionParameters) : Dataclass object containing adsorption\n                parameters from AdsorptionParameters.\n            source_parameters (mibitrans.data.read.SourceParameters) : Dataclass object containing source parameters\n                from SourceParameters.\n            model_parameters (mibitrans.data.read.ModelParameters) : Dataclass object containing model parameters from\n                ModelParameters.\n            verbose (bool, optional): Verbose mode. Defaults to False.\n\n        Attributes:\n            cxyt (np.ndarray) : Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]\n            x (np.ndarray) : Discretized model x-dimension, in [m].\n            y (np.ndarray) : Discretized model y-dimension, in [y].\n            t (np.ndarray) : Discretized model t-dimension, in [days].\n            c_source (np.ndarray) : Nett source zone concentrations, accounting for source superposition, in [g/m^3].\n            vr (float) : Retarded groundwater flow velocity, in [m/d].\n            k_source (float) : Source zone decay rate, in [1/days]\n\n        Raises:\n            TypeError : If input is not of the correct Dataclass.\n\n        \"\"\"\n        super().__init__(hydrological_parameters, adsorption_parameters, source_parameters, model_parameters, verbose)\n\n        self._calculate()\n\n    def _calculate(self):\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            x_term = self._eq_x_term()\n            additional_x = self._eq_additional_x()\n            z_term = self._eq_z_term()\n            source_decay = self._eq_source_decay()\n            for i in range(len(self.c_source)):\n                y_term = self._eq_y_term(i)\n                cxyt = 1 / 8 * self.c_source[i] * source_decay * (x_term + additional_x) * y_term * z_term\n                self.cxyt += cxyt\n</code></pre>"},{"location":"reference/reference/#mibitrans.transport.domenico.NoDecay.__init__","title":"<code>__init__(hydrological_parameters, adsorption_parameters, source_parameters, model_parameters, verbose=False)</code>","text":"<p>Initialize object and run model.</p> <p>Parameters:</p> Name Type Description Default <code>hydrological_parameters (mibitrans.data.read.HydrologicalParameters) </code> <p>Dataclass object containing</p> required <code>adsorption_parameters (mibitrans.data.read.AdsorptionParameters) </code> <p>Dataclass object containing adsorption parameters from AdsorptionParameters.</p> required <code>source_parameters (mibitrans.data.read.SourceParameters) </code> <p>Dataclass object containing source parameters from SourceParameters.</p> required <code>model_parameters (mibitrans.data.read.ModelParameters) </code> <p>Dataclass object containing model parameters from ModelParameters.</p> required <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>cxyt</code> <code>np.ndarray) </code> <p>Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]</p> <code>x</code> <code>np.ndarray) </code> <p>Discretized model x-dimension, in [m].</p> <code>y</code> <code>np.ndarray) </code> <p>Discretized model y-dimension, in [y].</p> <code>t</code> <code>np.ndarray) </code> <p>Discretized model t-dimension, in [days].</p> <code>c_source</code> <code>np.ndarray) </code> <p>Nett source zone concentrations, accounting for source superposition, in [g/m^3].</p> <code>vr</code> <code>float) </code> <p>Retarded groundwater flow velocity, in [m/d].</p> <code>k_source</code> <code>float) </code> <p>Source zone decay rate, in [1/days]</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input is not of the correct Dataclass.</p> Source code in <code>mibitrans/transport/domenico.py</code> <pre><code>def __init__(\n    self, hydrological_parameters, adsorption_parameters, source_parameters, model_parameters, verbose=False\n):\n    \"\"\"Initialize object and run model.\n\n    Args:\n        hydrological_parameters (mibitrans.data.read.HydrologicalParameters) : Dataclass object containing\n        hydrological parameters from HydrologicalParameters.\n        adsorption_parameters (mibitrans.data.read.AdsorptionParameters) : Dataclass object containing adsorption\n            parameters from AdsorptionParameters.\n        source_parameters (mibitrans.data.read.SourceParameters) : Dataclass object containing source parameters\n            from SourceParameters.\n        model_parameters (mibitrans.data.read.ModelParameters) : Dataclass object containing model parameters from\n            ModelParameters.\n        verbose (bool, optional): Verbose mode. Defaults to False.\n\n    Attributes:\n        cxyt (np.ndarray) : Output array containing concentrations in model domain, in [g/m^3]. Indexed as [t,y,x]\n        x (np.ndarray) : Discretized model x-dimension, in [m].\n        y (np.ndarray) : Discretized model y-dimension, in [y].\n        t (np.ndarray) : Discretized model t-dimension, in [days].\n        c_source (np.ndarray) : Nett source zone concentrations, accounting for source superposition, in [g/m^3].\n        vr (float) : Retarded groundwater flow velocity, in [m/d].\n        k_source (float) : Source zone decay rate, in [1/days]\n\n    Raises:\n        TypeError : If input is not of the correct Dataclass.\n\n    \"\"\"\n    super().__init__(hydrological_parameters, adsorption_parameters, source_parameters, model_parameters, verbose)\n\n    self._calculate()\n</code></pre>"},{"location":"reference/reference/#mibitrans.visualize","title":"<code>visualize</code>","text":""},{"location":"reference/reference/#mibitrans.visualize.plot_line","title":"<code>plot_line</code>","text":"<p>Author: Jorrit Bakker.</p> <p>Module plotting a 3D matrix of contaminant plume concentrations as a line.</p>"},{"location":"reference/reference/#mibitrans.visualize.plot_line.centerline","title":"<code>centerline(model, time=None, y_position=0, **kwargs)</code>","text":"<p>Plot center of contaminant plume as a line, at a specified time and, optionally, y position.</p> <p>Parameters:</p> Name Type Description Default <code>model </code> <p>Model object from mibitrans.transport.</p> required <code>time</code> <code>float</code> <p>Point of time for the plot. By default, last point in time is plotted.</p> <code>None</code> <code>y_position </code> <p>y-position across the plume (transverse horizontal direction) for the plot. By default, the center of the plume at y=0 is plotted.</p> required <code>**kwargs </code> <p>Arguments to be passed to plt.plot().</p> required <p>Returns a line plot of the input plume as object.</p> Source code in <code>mibitrans/visualize/plot_line.py</code> <pre><code>def centerline(model, time=None, y_position=0, **kwargs):\n    \"\"\"Plot center of contaminant plume as a line, at a specified time and, optionally, y position.\n\n    Args:\n        model : Model object from mibitrans.transport.\n        time (float): Point of time for the plot. By default, last point in time is plotted.\n        y_position : y-position across the plume (transverse horizontal direction) for the plot.\n            By default, the center of the plume at y=0 is plotted.\n        **kwargs : Arguments to be passed to plt.plot().\n\n    Returns a line plot of the input plume as object.\n    \"\"\"\n    _check_model_type(model, Domenico)\n    t_pos = _time_check(model, time)\n    y_pos = _y_check(model, y_position)\n    plot_array = model.cxyt[t_pos, y_pos, :]\n\n    plt.plot(model.x, plot_array, **kwargs)\n\n    plt.ylim((0, np.max(plot_array) + 1 / 10 * np.max(plot_array)))\n    plt.xlabel(\"Distance from source [m]\")\n    plt.ylabel(r\"Concentration [g/$m^{3}$]\")\n    plt.grid(True)\n</code></pre>"},{"location":"reference/reference/#mibitrans.visualize.plot_surface","title":"<code>plot_surface</code>","text":""},{"location":"reference/reference/#mibitrans.visualize.plot_surface.plume_2d","title":"<code>plume_2d(model, time=None, **kwargs)</code>","text":"<p>Plot contaminant plume as a 2D colormesh, at a specified time.</p> <p>Parameters:</p> Name Type Description Default <code>model </code> <p>Model object from mibitrans.transport.</p> required <code>time</code> <code>float</code> <p>Point of time for the plot. By default, last point in time is plotted.</p> <code>None</code> <code>**kwargs </code> <p>Arguments to be passed to plt.pcolormesh().</p> required <p>Returns a matrix plot of the input plume as object.</p> Source code in <code>mibitrans/visualize/plot_surface.py</code> <pre><code>def plume_2d(model, time=None, **kwargs):\n    \"\"\"Plot contaminant plume as a 2D colormesh, at a specified time.\n\n    Args:\n        model : Model object from mibitrans.transport.\n        time (float): Point of time for the plot. By default, last point in time is plotted.\n        **kwargs : Arguments to be passed to plt.pcolormesh().\n\n    Returns a matrix plot of the input plume as object.\n    \"\"\"\n    _check_model_type(model, Domenico)\n    t_pos = _time_check(model, time)\n    plt.pcolormesh(model.x, model.y, model.cxyt[t_pos, :, :], **kwargs)\n\n    plt.xlabel(\"Distance from source (m)\")\n    plt.ylabel(\"Distance from plume center (m)\")\n    plt.colorbar(label=r\"Concentration (g/$m^{3}$)\")\n</code></pre>"},{"location":"reference/reference/#mibitrans.visualize.plot_surface.plume_3d","title":"<code>plume_3d(model, time=None, **kwargs)</code>","text":"<p>Plot contaminant plume as a 3D surface, at a specified time.</p> <p>Parameters:</p> Name Type Description Default <code>model </code> <p>Model object from mibitrans.transport.</p> required <code>time</code> <code>float</code> <p>Point of time for the plot. By default, last point in time is plotted.</p> <code>None</code> <code>**kwargs </code> <p>Arguments to be passed to plt.plot_surface().</p> required <p>Returns:</p> Type Description <p>ax (matplotlib.axes._axes.Axes) : Returns matplotlib axes object of plume plot.</p> Source code in <code>mibitrans/visualize/plot_surface.py</code> <pre><code>def plume_3d(model, time=None, **kwargs):\n    \"\"\"Plot contaminant plume as a 3D surface, at a specified time.\n\n    Args:\n        model : Model object from mibitrans.transport.\n        time (float): Point of time for the plot. By default, last point in time is plotted.\n        **kwargs : Arguments to be passed to plt.plot_surface().\n\n    Returns:\n        ax (matplotlib.axes._axes.Axes) : Returns matplotlib axes object of plume plot.\n    \"\"\"\n    _check_model_type(model, Domenico)\n    t_pos = _time_check(model, time)\n\n    fig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\n    ax.plot_surface(model.xxx[t_pos, :, :], model.yyy[t_pos, :, :], model.cxyt[t_pos, :, :], **kwargs)\n\n    ax.view_init(elev=30, azim=310)\n    ax.set_xlabel(\"Distance from source (m)\")\n    ax.set_ylabel(\"Distance from plume center (m)\")\n    ax.set_zlabel(r\"Concentration [$g/m^{3}$]\")\n\n    return ax\n</code></pre>"},{"location":"reference/reference/#mibitrans.visualize.show_mass_balance","title":"<code>show_mass_balance</code>","text":"<p>Author: Jorrit Bakker.</p> <p>Module calculating methods for mass balance visualization.</p>"},{"location":"reference/reference/#mibitrans.visualize.show_mass_balance.generate_mass_balance_tables","title":"<code>generate_mass_balance_tables(mass_dict)</code>","text":"<p>Generate mass balance tables for relevant model components based on input dictionary.</p> Args <p>mass_dict (dict) : Dictionary with mass balance with the structure as generated by the mass_balance module.</p> Source code in <code>mibitrans/visualize/show_mass_balance.py</code> <pre><code>def generate_mass_balance_tables(mass_dict):\n    \"\"\"Generate mass balance tables for relevant model components based on input dictionary.\n\n    Args :\n        mass_dict (dict) : Dictionary with mass balance with the structure as generated by the mass_balance module.\n\n    \"\"\"\n    # Check if input is indeed a dictionary\n    _check_dictionary(mass_dict)\n\n    # Generate table object with object headers. Seperate tables for each component for clarity\n    # table_source will contain the source decay masses from no decay and linear decay model mode.\n    table_source = PrettyTable([\"Source decay\", \"Mass (g)\"])\n    # table_nodecay will contain the plume masses for no decay model mode.\n    table_nodecay = PrettyTable([\"No decay\", \"Mass (g)\"])\n    # table_lindecay will contain the plume masses for linear decay model mode.\n    table_lindecay = PrettyTable([\"Linear decay\", \"Mass (g)\"])\n    # table_instant will contain the plume and source masses for instant reaction model mode.\n    table_instant = PrettyTable([\"Instant reaction\", \"Mass (g)\"])\n    # table_electron will contain the change in electron acceptor and byproduct masses for instant reaction model mode.\n    table_electron = PrettyTable([\"Electron acceptors/byproducts\", \"O2\", \"NO3-\", \"Fe2+\", \"SO4 2-\", \"CH4\"])\n\n    # Initialize flags which keep track of which model components are present\n    print_source = False\n    print_nodecay = False\n    print_lindecay = False\n    print_instant = False\n    print_electron = False\n\n    # Loop to add each mass balance components to their respective table\n    for key, item in mass_dict.items():\n        # Round mass balance to one decimal to avoid clutter\n        round_item = np.round(item, 1)\n\n        # Time does not need to be renamed and does not need to be added as a row to a table\n        if key != \"time\":\n            # Check if mass balance component is recognized, ignore if it is not.\n            try:\n                # Rename keys to comprehensive table headers\n                rename_key = rename_dict[key]\n            except KeyError:\n                print(f\"The following key is not recognized: '{key}' and is thus ignored\")\n                rename_key = None\n\n            # Add the right mass balance model components to each mass balance table\n            if key in [\"source_mass_0\", \"source_mass_t\", \"source_mass_change\"]:\n                print_source = True\n                # Add time information to name of source mass at t = t\n                if rename_key == \"mass t = \":\n                    rename_key = rename_key + str(mass_dict[\"time\"])\n                table_source.add_row([rename_key, round_item])\n\n            elif key in [\"plume_mass_no_decay\", \"transport_outside_extent_nodecay\"]:\n                print_nodecay = True\n                table_nodecay.add_row([rename_key, round_item])\n\n            elif key in [\n                \"plume_mass_linear_decay\",\n                \"transport_outside_extent_lineardecay\",\n                \"plume_mass_degraded_linear\",\n            ]:\n                print_lindecay = True\n                table_lindecay.add_row([rename_key, round_item])\n\n            elif key in [\n                \"source_mass_instant_t\",\n                \"source_mass_instant_change\",\n                \"plume_mass_no_decay_instant_reaction\",\n                \"plume_mass_instant_reaction\",\n                \"plume_mass_degraded_instant\",\n            ]:\n                print_instant = True\n                if rename_key == \"source mass t = \":\n                    rename_key = rename_key + str(mass_dict[\"time\"])\n                table_instant.add_row([rename_key, round_item])\n\n            elif key == \"electron_acceptor_mass_change\":\n                print_electron = True\n                oxy, no, fe, so, ch = round_item\n                # Oxygen, Nitrate and Sulfate are electron acceptors and thus consumed (negative change),\n                # Iron2+ and Methane are byproducts from electron acceptors and thus generated (positive change).\n                table_electron.add_row([rename_key, -oxy, -no, f\"+{fe}\", -so, f\"+{ch}\"])\n\n    # If mass_balance components were not present in mass balance dictionary, table get set to None,\n    # preventing returning tables with only headers.\n    table_source = table_source if print_source else None\n    table_nodecay = table_nodecay if print_nodecay else None\n    table_lindecay = table_lindecay if print_lindecay else None\n    table_instant = table_instant if print_instant else None\n    table_electron = table_electron if print_electron else None\n\n    return table_source, table_nodecay, table_lindecay, table_instant, table_electron\n</code></pre>"},{"location":"reference/reference/#mibitrans.visualize.show_mass_balance.visualize_mass_balance","title":"<code>visualize_mass_balance(mass_dict)</code>","text":"<p>Takes dictionary with mass balance and prints it as stylized tables.</p> Args <p>mass_dict (dict) : Dictionary with mass balance with the structure as generated by the mass_balance module.</p> Source code in <code>mibitrans/visualize/show_mass_balance.py</code> <pre><code>def visualize_mass_balance(mass_dict) -&gt; None:\n    \"\"\"Takes dictionary with mass balance and prints it as stylized tables.\n\n    Args :\n        mass_dict (dict) : Dictionary with mass balance with the structure as generated by the mass_balance module.\n\n    \"\"\"\n    # Mass balance table generating function separate to allow user to choose whether to print tables\n    # or just get their objects.\n    table_source, table_nodecay, table_lindecay, table_instant, table_electron = generate_mass_balance_tables(mass_dict)\n\n    print(f\"MASS BALANCE FOR t = {mass_dict['time']}\")\n\n    # If a table contained no entries, it is set to None by generating function, allowing this function to only print\n    # filled tables.\n    if table_source is not None:\n        print(table_source)\n    if table_nodecay is not None:\n        print(table_nodecay)\n    if table_lindecay is not None:\n        print(table_lindecay)\n    if table_instant is not None:\n        print(table_instant)\n    if table_electron is not None:\n        print(table_electron)\n</code></pre>"}]}